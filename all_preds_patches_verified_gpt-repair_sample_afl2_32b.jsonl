{"model_name_or_path": "agentless", "instance_id": "django__django-11066", "model_patch": "diff --git a/django/contrib/contenttypes/management/__init__.py b/django/contrib/contenttypes/management/__init__.py\nindex 1e6250e..ae897f9 100644\n--- a/django/contrib/contenttypes/management/__init__.py\n+++ b/django/contrib/contenttypes/management/__init__.py\n@@ -24,7 +24,7 @@ class RenameContentType(migrations.RunPython):\n             content_type.model = new_model\n             try:\n                 with transaction.atomic(using=db):\n-                    content_type.save(update_fields={'model'})\n+                    content_type.save(using=db, update_fields={'model'})\n             except IntegrityError:\n                 # Gracefully fallback if a stale content type causes a\n                 # conflict as remove_stale_contenttypes will take care of\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11099", "model_patch": "diff --git a/django/contrib/auth/validators.py b/django/contrib/auth/validators.py\nindex fe3a5d1..28b2658 100644\n--- a/django/contrib/auth/validators.py\n+++ b/django/contrib/auth/validators.py\n@@ -1,3 +1,4 @@\n+\n import re\n \n from django.core import validators\n@@ -7,7 +8,7 @@ from django.utils.translation import gettext_lazy as _\n \n @deconstructible\n class ASCIIUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only English letters, '\n         'numbers, and @/./+/-/_ characters.'\n@@ -17,9 +18,9 @@ class ASCIIUsernameValidator(validators.RegexValidator):\n \n @deconstructible\n class UnicodeUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only letters, '\n         'numbers, and @/./+/-/_ characters.'\n     )\n-    flags = 0\n+    flags = 0\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11163", "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 0d7da3d..74a2377 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -83,7 +83,7 @@ def model_to_dict(instance, fields=None, exclude=None):\n     for f in chain(opts.concrete_fields, opts.private_fields, opts.many_to_many):\n         if not getattr(f, 'editable', False):\n             continue\n-        if fields and f.name not in fields:\n+        if fields is not None and f.name not in fields:\n             continue\n         if exclude and f.name in exclude:\n             continue\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-7671", "model_patch": "diff --git a/astropy/utils/introspection.py b/astropy/utils/introspection.py\nindex c8df9c0..ce6c795 100644\n--- a/astropy/utils/introspection.py\n+++ b/astropy/utils/introspection.py\n@@ -140,9 +140,9 @@ def minversion(module, version, inclusive=True, version_path='__version__'):\n         have_version = resolve_name(module.__name__, version_path)\n \n     if inclusive:\n-        return LooseVersion(have_version) >= LooseVersion(version)\n+        return Version(have_version) >= Version(version)\n     else:\n-        return LooseVersion(have_version) > LooseVersion(version)\n+        return Version(have_version) > Version(version)\n \n \n def find_current_module(depth=1, finddiff=False):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11179", "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 92b9b8f..1dc0f7d 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -916,7 +916,9 @@ class Model(metaclass=ModelBase):\n \n         collector = Collector(using=using)\n         collector.collect([self], keep_parents=keep_parents)\n-        return collector.delete()\n+        result = collector.delete()\n+        self.pk = None  # Clear the primary key after deletion\n+        return result\n \n     delete.alters_data = True\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11333", "model_patch": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex fa86ab6..966e964 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -65,8 +65,8 @@ class ResolverMatch:\n \n @functools.lru_cache(maxsize=None)\n def get_resolver(urlconf=None):\n-    if urlconf is None:\n-        urlconf = settings.ROOT_URLCONF\n+    # Always default to settings.ROOT_URLCONF when urlconf is not set\n+    urlconf = urlconf or settings.ROOT_URLCONF\n     return URLResolver(RegexPattern(r'^/'), urlconf)\n \n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-10999", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "django__django-11119", "model_patch": "diff --git a/django/template/engine.py b/django/template/engine.py\nindex 8cd3dab..c3c8fea 100644\n--- a/django/template/engine.py\n+++ b/django/template/engine.py\n@@ -160,7 +160,7 @@ class Engine:\n         if isinstance(context, Context):\n             return t.render(context)\n         else:\n-            return t.render(Context(context))\n+            return t.render(Context(context, autoescape=self.autoescape))\n \n     def select_template(self, template_name_list):\n         \"\"\"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11133", "model_patch": "diff --git a/django/http/response.py b/django/http/response.py\nindex 5126111..5de2740 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -231,6 +231,8 @@ class HttpResponseBase:\n         # - when self._charset != 'utf-8' it re-encodes the content\n         if isinstance(value, bytes):\n             return bytes(value)\n+        elif isinstance(value, memoryview):\n+            return value.tobytes()\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n         # Handle non-string types.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-7336", "model_patch": "diff --git a/astropy/units/decorators.py b/astropy/units/decorators.py\nindex 5ce0659..4cccf55 100644\n--- a/astropy/units/decorators.py\n+++ b/astropy/units/decorators.py\n@@ -221,11 +221,14 @@ class QuantityInput:\n             with add_enabled_equivalencies(self.equivalencies):\n                 return_ = wrapped_function(*func_args, **func_kwargs)\n             if wrapped_signature.return_annotation is not inspect.Signature.empty:\n-                return return_.to(wrapped_signature.return_annotation)\n+                if return_ is not None:\n+                    return return_.to(wrapped_signature.return_annotation)\n+                else:\n+                    return return_\n             else:\n                 return return_\n \n         return wrapper\n \n \n-quantity_input = QuantityInput.as_decorator\n+quantity_input = QuantityInput.as_decorator\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14096", "model_patch": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex f158027..5edc107 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -895,9 +895,10 @@ class SkyCoord(ShapedLikeNDArray):\n                 return self.transform_to(attr)\n \n         # Fail\n+        # Explicitly raise AttributeError for the requested attribute name\n         raise AttributeError(\n             f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n-        )\n+        ) from None\n \n     def __setattr__(self, attr, val):\n         # This is to make anything available through __getattr__ immutable\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-10914", "model_patch": "diff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex 39f68c7..4be42a0 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -257,7 +257,7 @@ class FileSystemStorage(Storage):\n                 # This is a normal uploadedfile that we can stream.\n                 else:\n                     # The current umask value is masked out by os.open!\n-                    fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)\n+                    fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o644)\n                     _file = None\n                     try:\n                         locks.lock(fd, locks.LOCK_EX)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14309", "model_patch": "diff --git a/astropy/io/fits/connect.py b/astropy/io/fits/connect.py\nindex c5ff3cd..caf7f05 100644\n--- a/astropy/io/fits/connect.py\n+++ b/astropy/io/fits/connect.py\n@@ -69,7 +69,7 @@ def is_fits(origin, filepath, fileobj, *args, **kwargs):\n             (\".fits\", \".fits.gz\", \".fit\", \".fit.gz\", \".fts\", \".fts.gz\")\n         ):\n             return True\n-    return isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n+    return len(args) > 0 and isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n \n \n def _decode_mixins(tbl):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11095", "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 62b54f5..adc7089 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -580,9 +580,16 @@ class ModelAdmin(BaseModelAdmin):\n     def __str__(self):\n         return \"%s.%s\" % (self.model._meta.app_label, self.__class__.__name__)\n \n+    def get_inlines(self, request, obj=None):\n+        \"\"\"\n+        Hook to allow defining the inlines dynamically based on the request or model instance.\n+        By default, it returns the `self.inlines` attribute.\n+        \"\"\"\n+        return self.inlines\n+\n     def get_inline_instances(self, request, obj=None):\n         inline_instances = []\n-        for inline_class in self.inlines:\n+        for inline_class in self.get_inlines(request, obj):\n             inline = inline_class(self.model, self.admin_site)\n             if request:\n                 if not (inline.has_view_or_change_permission(request, obj) or\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11292", "model_patch": "diff --git a/django/core/management/base.py b/django/core/management/base.py\nindex c0cee4d..c15f0d3 100644\n--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -278,6 +278,10 @@ class BaseCommand:\n             help='A directory to add to the Python path, e.g. \"/home/djangoprojects/myproject\".',\n         )\n         parser.add_argument('--traceback', action='store_true', help='Raise on CommandError exceptions')\n+        parser.add_argument(\n+            '--skip-checks', action='store_true',\n+            help='Skip system checks when running this command.',\n+        )\n         parser.add_argument(\n             '--no-color', action='store_true',\n             help=\"Don't colorize the command output.\",\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-13977", "model_patch": "diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex ef71d2c..d82bcc9 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -667,7 +667,10 @@ class Quantity(np.ndarray):\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+            try:\n+                arrays.append(converter(input_) if converter else input_)\n+            except ValueError:\n+                return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-7166", "model_patch": "diff --git a/astropy/utils/introspection.py b/astropy/utils/introspection.py\nindex 024356b..41a8eed 100644\n--- a/astropy/utils/introspection.py\n+++ b/astropy/utils/introspection.py\n@@ -384,7 +384,7 @@ def isinstancemethod(cls, obj):\n \n \n def _isinstancemethod(cls, obj):\n-    if not isinstance(obj, types.FunctionType):\n+    if not isinstance(obj, (types.FunctionType, property)):\n         return False\n \n     # Unfortunately it seems the easiest way to get to the original\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-13033", "model_patch": "diff --git a/astropy/timeseries/core.py b/astropy/timeseries/core.py\nindex 33e697b..8043fe1 100644\n--- a/astropy/timeseries/core.py\n+++ b/astropy/timeseries/core.py\n@@ -75,10 +75,17 @@ class BaseTimeSeries(QTable):\n                                  .format(self.__class__.__name__, required_columns[0], plural))\n \n             elif self.colnames[:len(required_columns)] != required_columns:\n-\n-                raise ValueError(\"{} object is invalid - expected '{}' \"\n-                                 \"as the first column{} but found '{}'\"\n-                                 .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n+                missing_columns = [col for col in required_columns if col not in self.colnames]\n+                if missing_columns:\n+                    raise ValueError(\n+                        \"{} object is invalid - required column{} '{}' {} missing.\"\n+                        .format(self.__class__.__name__, plural, \"', '\".join(missing_columns),\n+                                \"is\" if len(missing_columns) == 1 else \"are\")\n+                    )\n+                else:\n+                    raise ValueError(\"{} object is invalid - expected '{}' \"\n+                                     \"as the first column{} but found '{}'\"\n+                                     .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n \n             if (self._required_columns_relax\n                     and self._required_columns == self.colnames[:len(self._required_columns)]):\n@@ -89,4 +96,4 @@ class BaseTimeSeries(QTable):\n         self._required_columns_enabled = False\n         yield\n         self._required_columns_enabled = True\n-        self._check_required_columns()\n+        self._check_required_columns()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11532", "model_patch": "diff --git a/django/core/mail/utils.py b/django/core/mail/utils.py\nindex af5ac38..4872906 100644\n--- a/django/core/mail/utils.py\n+++ b/django/core/mail/utils.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Email message and email sending related helper functions.\n \"\"\"\n@@ -9,7 +10,7 @@ import socket\n # seconds, which slows down the restart of the server.\n class CachedDnsName:\n     def __str__(self):\n-        return self.get_fqdn()\n+        return self.get_fqdn().encode('idna').decode('ascii')\n \n     def get_fqdn(self):\n         if not hasattr(self, '_fqdn'):\n@@ -17,4 +18,4 @@ class CachedDnsName:\n         return self._fqdn\n \n \n-DNS_NAME = CachedDnsName()\n+DNS_NAME = CachedDnsName()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11211", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 067de0d..108cf49 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1003,6 +1003,9 @@ class QuerySet:\n                 if isinstance(lookup, Prefetch):\n                     lookup = lookup.prefetch_to\n                 lookup = lookup.split(LOOKUP_SEP, 1)[0]\n+                if isinstance(lookup, GenericForeignKey):\n+                    # Ensure compatibility with UUID primary keys\n+                    lookup.object_id_field_name = 'foo_object_id'\n                 if lookup in self.query._filtered_relations:\n                     raise ValueError('prefetch_related() is not supported with FilteredRelation.')\n             clone._prefetch_related_lookups = clone._prefetch_related_lookups + lookups\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11138", "model_patch": "diff --git a/django/db/backends/mysql/operations.py b/django/db/backends/mysql/operations.py\nindex 3337c6c..178fbb3 100644\n--- a/django/db/backends/mysql/operations.py\n+++ b/django/db/backends/mysql/operations.py\n@@ -70,7 +70,11 @@ class DatabaseOperations(BaseDatabaseOperations):\n \n     def _convert_field_to_tz(self, field_name, tzname):\n         if settings.USE_TZ:\n-            field_name = \"CONVERT_TZ(%s, 'UTC', '%s')\" % (field_name, tzname)\n+            db_tz = getattr(settings, 'DATABASES', {}).get(getattr(connection, 'alias', None), {}).get('TIME_ZONE', 'UTC')\n+            if db_tz == tzname:\n+                # No conversion required if database timezone matches the target timezone\n+                return field_name\n+            field_name = \"CONVERT_TZ(%s, '%s', '%s')\" % (field_name, db_tz, tzname)\n         return field_name\n \n     def datetime_cast_date_sql(self, field_name, tzname):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14369", "model_patch": "diff --git a/astropy/io/ascii/cds.py b/astropy/io/ascii/cds.py\nindex adb3840..ce5e91a 100644\n--- a/astropy/io/ascii/cds.py\n+++ b/astropy/io/ascii/cds.py\n@@ -130,7 +130,10 @@ class CdsHeader(core.BaseHeader):\n                 if unit == \"---\":\n                     col.unit = None  # \"---\" is the marker for no unit in CDS/MRT table\n                 else:\n-                    col.unit = Unit(unit, format=\"cds\", parse_strict=\"warn\")\n+                    # Replace \"/\" with \" / \" and \"^\" with \" ** \" for proper parsing\n+                    normalized_unit = re.sub(r'/', ' / ', unit)\n+                    normalized_unit = re.sub(r'\\^', '**', normalized_unit)\n+                    col.unit = Unit(normalized_unit, format=\"cds\", parse_strict=\"warn\")\n                 col.description = (match.group(\"descr\") or \"\").strip()\n                 col.raw_type = match.group(\"format\")\n                 col.type = self.get_col_type(col)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-7606", "model_patch": "diff --git a/astropy/units/core.py b/astropy/units/core.py\nindex e92aa72..6cc26e1 100644\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -1710,6 +1710,8 @@ class UnrecognizedUnit(IrreducibleUnit):\n         _unrecognized_operator\n \n     def __eq__(self, other):\n+        if other is None:\n+            return False\n         other = Unit(other, parse_strict='silent')\n         return isinstance(other, UnrecognizedUnit) and self.name == other.name\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11299", "model_patch": "diff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 4b9cb31..4784df3 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -37,6 +37,8 @@ class CheckConstraint(BaseConstraint):\n         where = query.build_where(self.check)\n         compiler = query.get_compiler(connection=schema_editor.connection)\n         sql, params = where.as_sql(compiler, schema_editor.connection)\n+        # Strip table qualifiers from column names for compatibility with SQLite and Oracle\n+        sql = sql.replace(f\"{schema_editor.quote_name(model._meta.db_table)}.\", \"\")\n         return sql % tuple(schema_editor.quote_value(p) for p in params)\n \n     def constraint_sql(self, model, schema_editor):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14182", "model_patch": "diff --git a/astropy/io/ascii/core.py b/astropy/io/ascii/core.py\nindex 4656111..5aab41b 100644\n--- a/astropy/io/ascii/core.py\n+++ b/astropy/io/ascii/core.py\n@@ -1812,6 +1812,8 @@ def _get_writer(Writer, fast_writer, **kwargs):\n         return FAST_CLASSES[f\"fast_{Writer._format_name}\"](**kwargs)\n \n     writer_kwargs = {k: v for k, v in kwargs.items() if k not in extra_writer_pars}\n+    if \"header_rows\" in kwargs:\n+        writer_kwargs[\"header_rows\"] = kwargs[\"header_rows\"]\n     writer = Writer(**writer_kwargs)\n \n     if \"delimiter\" in kwargs:\n@@ -1851,4 +1853,4 @@ def _get_writer(Writer, fast_writer, **kwargs):\n         writer.data.fill_include_names = kwargs[\"fill_include_names\"]\n     if \"fill_exclude_names\" in kwargs:\n         writer.data.fill_exclude_names = kwargs[\"fill_exclude_names\"]\n-    return writer\n+    return writer\ndiff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\nindex 00bbbaf..23748ce 100644\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -57,10 +57,18 @@ class RST(FixedWidth):\n     data_class = SimpleRSTData\n     header_class = SimpleRSTHeader\n \n-    def __init__(self):\n+    def __init__(self, header_rows=None):\n         super().__init__(delimiter_pad=None, bookend=False)\n+        self.header_rows = header_rows\n \n     def write(self, lines):\n         lines = super().write(lines)\n-        lines = [lines[1]] + lines + [lines[1]]\n-        return lines\n+        if self.header_rows:\n+            header_row_lines = []\n+            if \"name\" in self.header_rows:\n+                header_row_lines.append(\" \".join(self.header.colnames))\n+            if \"unit\" in self.header_rows:\n+                header_row_lines.append(\" \".join(str(getattr(col, \"unit\", \"\")) for col in self.table.columns.values()))\n+            lines = header_row_lines + lines\n+        lines = [lines[1]] + lines + [lines[1]]  # Surround the table with a border\n+        return lines\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11749", "model_patch": "diff --git a/django/core/management/__init__.py b/django/core/management/__init__.py\nindex b670a73..4844752 100644\n--- a/django/core/management/__init__.py\n+++ b/django/core/management/__init__.py\n@@ -134,7 +134,9 @@ def call_command(command_name, *args, **options):\n     # to parse_args().\n     parse_args += [\n         '{}={}'.format(min(opt.option_strings), arg_options[opt.dest])\n-        for opt in parser_actions if opt.required and opt.dest in options\n+        for opt in parser_actions \n+        if (opt.required or any(group.required and opt in group._group_actions for group in parser._mutually_exclusive_groups))\n+        and opt.dest in options\n     ]\n     defaults = parser.parse_args(args=parse_args)\n     defaults = dict(defaults._get_kwargs(), **arg_options)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11433", "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 74a2377..a4e8f19 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -46,10 +46,11 @@ def construct_instance(form, instance, fields=None, exclude=None):\n             continue\n         if exclude and f.name in exclude:\n             continue\n-        # Leave defaults for fields that aren't in POST data, except for\n-        # checkbox inputs because they don't appear in POST data if not checked.\n+        # Allow cleaned_data to overwrite fields with default values, even if\n+        # those fields aren't in POST data. This ensures cleaned_data always takes precedence.\n         if (f.has_default() and\n-                form[f.name].field.widget.value_omitted_from_data(form.data, form.files, form.add_prefix(f.name))):\n+                form[f.name].field.widget.value_omitted_from_data(form.data, form.files, form.add_prefix(f.name)) and\n+                f.name not in cleaned_data):\n             continue\n         # Defer saving file-type fields until after the other fields, so a\n         # callable upload_to can use the values from other fields.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-13398", "model_patch": "diff --git a/astropy/coordinates/transformations.py b/astropy/coordinates/transformations.py\nindex 59d2041..ced7a93 100644\n--- a/astropy/coordinates/transformations.py\n+++ b/astropy/coordinates/transformations.py\n@@ -1032,43 +1032,49 @@ class FunctionTransformWithFiniteDifference(FunctionTransform):\n             # the frame itself over time\n             attrname = self.finite_difference_frameattr_name\n             if attrname is not None:\n-                if self.symmetric_finite_difference:\n-                    if self._diff_attr_in_fromsys:\n-                        kws = {attrname: getattr(from_diffless, attrname) + halfdt}\n-                        from_diffless_fwd = from_diffless.replicate(**kws)\n-                    else:\n-                        from_diffless_fwd = from_diffless\n-                    if self._diff_attr_in_tosys:\n-                        kws = {attrname: getattr(toframe, attrname) + halfdt}\n-                        fwd_frame = toframe.replicate_without_data(**kws)\n-                    else:\n-                        fwd_frame = toframe\n-                    fwd = supcall(from_diffless_fwd, fwd_frame)\n-\n-                    if self._diff_attr_in_fromsys:\n-                        kws = {attrname: getattr(from_diffless, attrname) - halfdt}\n-                        from_diffless_back = from_diffless.replicate(**kws)\n-                    else:\n-                        from_diffless_back = from_diffless\n-                    if self._diff_attr_in_tosys:\n-                        kws = {attrname: getattr(toframe, attrname) - halfdt}\n-                        back_frame = toframe.replicate_without_data(**kws)\n-                    else:\n-                        back_frame = toframe\n-                    back = supcall(from_diffless_back, back_frame)\n+                # Ensure ITRS coordinates are treated as time-invariant and exclude obstime\n+                if self.fromsys is ITRS or self.tosys is ITRS:\n+                    # Skip synchronization of obstimes for ITRS transforms\n+                    fwd = reprwithoutdiff\n+                    back = reprwithoutdiff\n                 else:\n-                    if self._diff_attr_in_fromsys:\n-                        kws = {attrname: getattr(from_diffless, attrname) + dt}\n-                        from_diffless_fwd = from_diffless.replicate(**kws)\n-                    else:\n-                        from_diffless_fwd = from_diffless\n-                    if self._diff_attr_in_tosys:\n-                        kws = {attrname: getattr(toframe, attrname) + dt}\n-                        fwd_frame = toframe.replicate_without_data(**kws)\n+                    if self.symmetric_finite_difference:\n+                        if self._diff_attr_in_fromsys:\n+                            kws = {attrname: getattr(from_diffless, attrname) + halfdt}\n+                            from_diffless_fwd = from_diffless.replicate(**kws)\n+                        else:\n+                            from_diffless_fwd = from_diffless\n+                        if self._diff_attr_in_tosys:\n+                            kws = {attrname: getattr(toframe, attrname) + halfdt}\n+                            fwd_frame = toframe.replicate_without_data(**kws)\n+                        else:\n+                            fwd_frame = toframe\n+                        fwd = supcall(from_diffless_fwd, fwd_frame)\n+\n+                        if self._diff_attr_in_fromsys:\n+                            kws = {attrname: getattr(from_diffless, attrname) - halfdt}\n+                            from_diffless_back = from_diffless.replicate(**kws)\n+                        else:\n+                            from_diffless_back = from_diffless\n+                        if self._diff_attr_in_tosys:\n+                            kws = {attrname: getattr(toframe, attrname) - halfdt}\n+                            back_frame = toframe.replicate_without_data(**kws)\n+                        else:\n+                            back_frame = toframe\n+                        back = supcall(from_diffless_back, back_frame)\n                     else:\n-                        fwd_frame = toframe\n-                    fwd = supcall(from_diffless_fwd, fwd_frame)\n-                    back = reprwithoutdiff\n+                        if self._diff_attr_in_fromsys:\n+                            kws = {attrname: getattr(from_diffless, attrname) + dt}\n+                            from_diffless_fwd = from_diffless.replicate(**kws)\n+                        else:\n+                            from_diffless_fwd = from_diffless\n+                        if self._diff_attr_in_tosys:\n+                            kws = {attrname: getattr(toframe, attrname) + dt}\n+                            fwd_frame = toframe.replicate_without_data(**kws)\n+                        else:\n+                            fwd_frame = toframe\n+                        fwd = supcall(from_diffless_fwd, fwd_frame)\n+                        back = reprwithoutdiff\n \n                 diffxyz += (fwd.cartesian - back.cartesian).xyz / dt\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-10880", "model_patch": "diff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py\nindex f03a228..dbf3ca2 100644\n--- a/django/db/models/aggregates.py\n+++ b/django/db/models/aggregates.py\n@@ -68,7 +68,7 @@ class Aggregate(Func):\n         return []\n \n     def as_sql(self, compiler, connection, **extra_context):\n-        extra_context['distinct'] = 'DISTINCT' if self.distinct else ''\n+        extra_context['distinct'] = 'DISTINCT ' if self.distinct else ''\n         if self.filter:\n             if connection.features.supports_aggregate_filter_clause:\n                 filter_sql, filter_params = self.filter.as_sql(compiler, connection)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11451", "model_patch": "diff --git a/django/contrib/auth/backends.py b/django/contrib/auth/backends.py\nindex ada7461..4087f6e 100644\n--- a/django/contrib/auth/backends.py\n+++ b/django/contrib/auth/backends.py\n@@ -37,6 +37,8 @@ class ModelBackend(BaseBackend):\n     \"\"\"\n \n     def authenticate(self, request, username=None, password=None, **kwargs):\n+        if username is None or password is None:\n+            return\n         if username is None:\n             username = kwargs.get(UserModel.USERNAME_FIELD)\n         try:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-10097", "model_patch": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 1519f57..17e685d 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -94,7 +94,7 @@ class URLValidator(RegexValidator):\n \n     regex = _lazy_re_compile(\n         r'^(?:[a-z0-9\\.\\-\\+]*)://'  # scheme is validated separately\n-        r'(?:\\S+(?::\\S*)?@)?'  # user:pass authentication\n+        r'(?:[a-zA-Z0-9\\-._~%!$&\\'()*+,;=]+(?::[a-zA-Z0-9\\-._~%!$&\\'()*+,;=]*)?@)?'  # user:pass authentication (encoded)\n         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'\n         r'(?::\\d{2,5})?'  # port\n         r'(?:[/?#][^\\s]*)?'  # resource path\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11087", "model_patch": "diff --git a/django/db/backends/mysql/base.py b/django/db/backends/mysql/base.py\nindex 7f93d07..e2133d6 100644\n--- a/django/db/backends/mysql/base.py\n+++ b/django/db/backends/mysql/base.py\n@@ -243,7 +243,7 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n                 cursor.execute('; '.join(assignments))\n \n     def create_cursor(self, name=None):\n-        cursor = self.connection.cursor()\n+        cursor = self.connection.cursor(use_unicode=False)  # Disable Unicode by default\n         return CursorWrapper(cursor)\n \n     def _rollback(self):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11276", "model_patch": "diff --git a/django/utils/html.py b/django/utils/html.py\nindex 1bacb5c..f9ac236 100644\n--- a/django/utils/html.py\n+++ b/django/utils/html.py\n@@ -24,13 +24,7 @@ word_split_re = re.compile(r'''([\\s<>\"']+)''')\n simple_url_re = re.compile(r'^https?://\\[?\\w', re.IGNORECASE)\n simple_url_2_re = re.compile(r'^www\\.|^(?!http)\\w[^@]+\\.(com|edu|gov|int|mil|net|org)($|/.*)$', re.IGNORECASE)\n \n-_html_escapes = {\n-    ord('&'): '&amp;',\n-    ord('<'): '&lt;',\n-    ord('>'): '&gt;',\n-    ord('\"'): '&quot;',\n-    ord(\"'\"): '&#39;',\n-}\n+import html\n \n \n @keep_lazy(str, SafeString)\n@@ -43,7 +37,7 @@ def escape(text):\n     This may result in double-escaping. If this is a concern, use\n     conditional_escape() instead.\n     \"\"\"\n-    return mark_safe(str(text).translate(_html_escapes))\n+    return mark_safe(html.escape(str(text), quote=True))\n \n \n _js_escapes = {\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11790", "model_patch": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex 4d607f6..ef4d7c6 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -62,11 +62,12 @@ class UsernameField(forms.CharField):\n         return unicodedata.normalize('NFKC', super().to_python(value))\n \n     def widget_attrs(self, widget):\n-        return {\n-            **super().widget_attrs(widget),\n+        attrs = super().widget_attrs(widget)\n+        attrs.update({\n             'autocapitalize': 'none',\n             'autocomplete': 'username',\n-        }\n+        })\n+        return attrs\n \n \n class UserCreationForm(forms.ModelForm):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-13236", "model_patch": "diff --git a/astropy/table/table.py b/astropy/table/table.py\nindex 39b0202..4c23e60 100644\n--- a/astropy/table/table.py\n+++ b/astropy/table/table.py\n@@ -1239,10 +1239,17 @@ class Table:\n                                 f'{fully_qualified_name} '\n                                 'did not return a valid mixin column')\n \n-        # Structured ndarray gets viewed as a mixin unless already a valid\n-        # mixin class\n+        # Temporarily warn users about structured ndarray behavior until the future change\n         if (not isinstance(data, Column) and not data_is_mixin\n                 and isinstance(data, np.ndarray) and len(data.dtype) > 1):\n+            import warnings\n+            warnings.warn(\n+                \"Adding a structured numpy.ndarray to a Table will no longer \"\n+                \"automatically convert it to an NdarrayMixin in version 5.2. \"\n+                \"Wrap the array in a Column explicitly if needed.\",\n+                FutureWarning\n+            )\n+            # Current behavior remains unchanged for now\n             data = data.view(NdarrayMixin)\n             data_is_mixin = True\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-10973", "model_patch": "diff --git a/django/db/backends/postgresql/client.py b/django/db/backends/postgresql/client.py\nindex f49b2f8..5504348 100644\n--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -37,28 +37,13 @@ class DatabaseClient(BaseDatabaseClient):\n         temp_pgpass = None\n         sigint_handler = signal.getsignal(signal.SIGINT)\n         try:\n+            # Set PGPASSWORD in the environment for the subprocess.\n+            env = os.environ.copy()\n             if passwd:\n-                # Create temporary .pgpass file.\n-                temp_pgpass = NamedTemporaryFile(mode='w+')\n-                try:\n-                    print(\n-                        _escape_pgpass(host) or '*',\n-                        str(port) or '*',\n-                        _escape_pgpass(dbname) or '*',\n-                        _escape_pgpass(user) or '*',\n-                        _escape_pgpass(passwd),\n-                        file=temp_pgpass,\n-                        sep=':',\n-                        flush=True,\n-                    )\n-                    os.environ['PGPASSFILE'] = temp_pgpass.name\n-                except UnicodeEncodeError:\n-                    # If the current locale can't encode the data, let the\n-                    # user input the password manually.\n-                    pass\n+                env['PGPASSWORD'] = passwd\n             # Allow SIGINT to pass to psql to abort queries.\n             signal.signal(signal.SIGINT, signal.SIG_IGN)\n-            subprocess.check_call(args)\n+            subprocess.run(args, env=env, check=True)\n         finally:\n             # Restore the original SIGINT handler.\n             signal.signal(signal.SIGINT, sigint_handler)\n@@ -68,4 +53,4 @@ class DatabaseClient(BaseDatabaseClient):\n                     del os.environ['PGPASSFILE']\n \n     def runshell(self):\n-        DatabaseClient.runshell_db(self.connection.get_connection_params())\n+        DatabaseClient.runshell_db(self.connection.get_connection_params())\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11848", "model_patch": "diff --git a/django/utils/http.py b/django/utils/http.py\nindex ab0ad07..3fee263 100644\n--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -176,10 +176,12 @@ def parse_http_date(date):\n     try:\n         year = int(m.group('year'))\n         if year < 100:\n-            if year < 70:\n-                year += 2000\n-            else:\n+            current_year = datetime.datetime.utcnow().year\n+            current_two_digit_year = current_year % 100\n+            if year > current_two_digit_year + 50:\n                 year += 1900\n+            else:\n+                year += 2000\n         month = MONTHS.index(m.group('mon').lower()) + 1\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-12907", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex d6e9246..ae49c23 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -97,9 +97,27 @@ def separability_matrix(transform):\n     if transform.n_inputs == 1 and transform.n_outputs > 1:\n         return np.ones((transform.n_outputs, transform.n_inputs),\n                        dtype=np.bool_)\n-    separable_matrix = _separable(transform)\n-    separable_matrix = np.where(separable_matrix != 0, True, False)\n-    return separable_matrix\n+    # Check if the model is compound and handle nesting properly\n+    if hasattr(transform, 'submodel_names') and transform.n_submodels > 0:\n+        # Initialize a separability matrix for the compound model\n+        n_outputs, n_inputs = transform.n_outputs, transform.n_inputs\n+        separable_matrix = np.zeros((n_outputs, n_inputs), dtype=np.bool_)\n+        output_offset = 0\n+        input_offset = 0\n+        \n+        for submodel in transform._leaflist:\n+            sub_separability = separability_matrix(submodel)\n+            sub_n_outputs, sub_n_inputs = sub_separability.shape\n+            separable_matrix[output_offset:output_offset + sub_n_outputs,\n+                             input_offset:input_offset + sub_n_inputs] = sub_separability\n+            output_offset += sub_n_outputs\n+            input_offset += sub_n_inputs\n+        \n+        return separable_matrix\n+    else:\n+        separable_matrix = _separable(transform)\n+        separable_matrix = np.where(separable_matrix != 0, True, False)\n+        return separable_matrix\n \n \n def _compute_n_outputs(left, right):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11265", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 1309ca5..41e7fd5 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1666,6 +1666,7 @@ class Query(BaseExpression):\n             filter_expr = (filter_lhs, OuterRef(filter_rhs.name))\n         # Generate the inner query.\n         query = Query(self.model)\n+        query.annotations = self.annotations.copy()  # Propagate annotations from the original query\n         query.add_filter(filter_expr)\n         query.clear_ordering(True)\n         # Try to have as simple as possible subquery -> trim leading joins from\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-8707", "model_patch": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 2e9a9bd..7ea4fdb 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -546,6 +546,8 @@ class Card(_Verify):\n \n     @classmethod\n     def fromstring(cls, image):\n+        if isinstance(image, bytes):\n+            image = image.decode('ascii')\n         \"\"\"\n         Construct a `Card` object from a (raw) string. It will pad the string\n         if it is not the length of a card image (80 columns).  If the card\ndiff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py\nindex d23f312..21700ec 100644\n--- a/astropy/io/fits/header.py\n+++ b/astropy/io/fits/header.py\n@@ -328,6 +328,8 @@ class Header:\n \n     @classmethod\n     def fromstring(cls, data, sep=''):\n+        if isinstance(data, bytes):\n+            data = data.decode('ascii')\n         \"\"\"\n         Creates an HDU header from a byte string containing the entire header\n         data.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11141", "model_patch": "diff --git a/django/db/migrations/loader.py b/django/db/migrations/loader.py\nindex ab7f543..be13937 100644\n--- a/django/db/migrations/loader.py\n+++ b/django/db/migrations/loader.py\n@@ -84,9 +84,8 @@ class MigrationLoader:\n                     continue\n                 raise\n             else:\n-                # Empty directories are namespaces.\n-                # getattr() needed on PY36 and older (replace w/attribute access).\n-                if getattr(module, '__file__', None) is None:\n+                # Module is not a package (e.g. migrations.py).\n+                if not hasattr(module, '__path__'):\n                     self.unmigrated_apps.add(app_config.label)\n                     continue\n                 # Module is not a package (e.g. migrations.py).\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11477", "model_patch": "diff --git a/django/urls/base.py b/django/urls/base.py\nindex e420dc6..946ec25 100644\n--- a/django/urls/base.py\n+++ b/django/urls/base.py\n@@ -172,9 +172,11 @@ def translate_url(url, lang_code):\n         to_be_reversed = \"%s:%s\" % (match.namespace, match.url_name) if match.namespace else match.url_name\n         with override(lang_code):\n             try:\n-                url = reverse(to_be_reversed, args=match.args, kwargs=match.kwargs)\n+                # Filter out None values from kwargs for optional named groups.\n+                filtered_kwargs = {k: v for k, v in match.kwargs.items() if v is not None}\n+                url = reverse(to_be_reversed, args=match.args, kwargs=filtered_kwargs)\n             except NoReverseMatch:\n                 pass\n             else:\n                 url = urlunsplit((parsed.scheme, parsed.netloc, url, parsed.query, parsed.fragment))\n-    return url\n+    return url\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11728", "model_patch": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 5b145cc..a7f5199 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -196,7 +196,7 @@ class RegexPattern(CheckURLMixin):\n \n \n _PATH_PARAMETER_COMPONENT_RE = re.compile(\n-    r'<(?:(?P<converter>[^>:]+):)?(?P<parameter>\\w+)>'\n+    r'(?P<whole_pattern><(?:(?P<converter>[^>:]+):)?(?P<parameter>\\w+)>)(?P<trailing>.*)?'\n )\n \n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-13453", "model_patch": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 1220930..fc7d398 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -437,6 +437,9 @@ class HTML(core.BaseReader):\n                                     new_cols.append(new_col)\n                             else:\n \n+                                # Apply column formats if specified\n+                                if col.info.name in self.formats:\n+                                    col.info.format = self.formats[col.info.name]\n                                 col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n                                 col_str_iters.append(col_iter_str_vals)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11603", "model_patch": "diff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py\nindex 8d54185..a2f1d88 100644\n--- a/django/db/models/aggregates.py\n+++ b/django/db/models/aggregates.py\n@@ -99,6 +99,7 @@ class Aggregate(Func):\n class Avg(FixDurationInputMixin, NumericOutputFieldMixin, Aggregate):\n     function = 'AVG'\n     name = 'Avg'\n+    allow_distinct = True\n \n \n class Count(Aggregate):\n@@ -142,6 +143,7 @@ class StdDev(NumericOutputFieldMixin, Aggregate):\n class Sum(FixDurationInputMixin, Aggregate):\n     function = 'SUM'\n     name = 'Sum'\n+    allow_distinct = True\n \n \n class Variance(NumericOutputFieldMixin, Aggregate):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14598", "model_patch": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex c54f5c8..08f2a24 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -768,7 +768,7 @@ class Card(_Verify):\n         if m.group(\"bool\") is not None:\n             value = m.group(\"bool\") == \"T\"\n         elif m.group(\"strg\") is not None:\n-            value = re.sub(\"''\", \"'\", m.group(\"strg\"))\n+            value = m.group(\"strg\")\n         elif m.group(\"numr\") is not None:\n             #  Check for numbers with leading 0s.\n             numr = self._number_NFSC_RE.match(m.group(\"numr\"))\n@@ -859,7 +859,7 @@ class Card(_Verify):\n                     return kw, vc\n \n                 value = m.group(\"strg\") or \"\"\n-                value = value.rstrip().replace(\"''\", \"'\")\n+                value = value.rstrip()\n                 if value and value[-1] == \"&\":\n                     value = value[:-1]\n                 values.append(value)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11490", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e230725..1fd1386 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -820,7 +820,12 @@ class QuerySet:\n             else:\n                 _fields.append(field)\n \n-        clone = self._values(*_fields, **expressions)\n+        # Ensure the composed query correctly updates values for composed queries (e.g., unions).\n+        clone = self._chain()\n+        clone._fields = _fields\n+        clone.query.set_values(_fields)\n+        if expressions:\n+            clone = clone.annotate(**expressions)\n         clone._iterable_class = (\n             NamedValuesListIterable if named\n             else FlatValuesListIterable if flat\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-13579", "model_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex 5827574..10675b3 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -3103,7 +3103,15 @@ reduce these to 2 dimensions using the naxis kwarg.\n             # We need to drop some dimensions, but this may not always be\n             # possible with .sub due to correlated axes, so instead we use the\n             # generalized slicing infrastructure from astropy.wcs.wcsapi.\n-            return SlicedFITSWCS(self, view)\n+            sliced_wcs = SlicedFITSWCS(self, view)\n+\n+            # Fix for preserving PC matrix and CRPIX adjustments\n+            if hasattr(self.wcs, 'pc'):\n+                sliced_wcs.wcs.pc = np.copy(self.wcs.pc)\n+            if hasattr(self.wcs, 'crpix'):\n+                sliced_wcs.wcs.crpix = np.copy(self.wcs.crpix)\n+\n+            return sliced_wcs\n \n         # NOTE: we could in principle use SlicedFITSWCS as above for all slicing,\n         # but in the simple case where there are no axes dropped, we can just\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11815", "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 472049c..8c0e529 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -120,7 +120,7 @@ class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        v_string, v_imports = serializer_factory(self.value.value).serialize()\n+        v_string, v_imports = serializer_factory(self.value.name).serialize()\n         imports = {'import %s' % module, *v_imports}\n         return \"%s.%s(%s)\" % (module, enum_class.__name__, v_string), imports\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12193", "model_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex dc396a1..9959ade 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -521,9 +521,11 @@ class CheckboxInput(Input):\n         return str(value)\n \n     def get_context(self, name, value, attrs):\n+        if attrs is None:\n+            attrs = {}\n+        else:\n+            attrs = attrs.copy()\n         if self.check_test(value):\n-            if attrs is None:\n-                attrs = {}\n             attrs['checked'] = True\n         return super().get_context(name, value, attrs)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12155", "model_patch": "diff --git a/django/contrib/admindocs/utils.py b/django/contrib/admindocs/utils.py\nindex 63ee2fc..51cb1ff 100644\n--- a/django/contrib/admindocs/utils.py\n+++ b/django/contrib/admindocs/utils.py\n@@ -34,7 +34,7 @@ def trim_docstring(docstring):\n         return ''\n     # Convert tabs to spaces and split into lines\n     lines = docstring.expandtabs().splitlines()\n-    indent = min(len(line) - len(line.lstrip()) for line in lines if line.lstrip())\n+    indent = min(len(line) - len(line.lstrip()) for line in lines[1:] if line.lstrip())\n     trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]\n     return \"\\n\".join(trimmed).strip()\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12304", "model_patch": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex ab625f8..92ecbe4 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -1,3 +1,4 @@\n+\n import enum\n \n from django.utils.functional import Promise\n@@ -59,6 +60,8 @@ class ChoicesMeta(enum.EnumMeta):\n \n \n class Choices(enum.Enum, metaclass=ChoicesMeta):\n+    # Prevent Django templates from calling this class.\n+    do_not_call_in_templates = True\n     \"\"\"Class for creating enumerated choices.\"\"\"\n \n     def __str__(self):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11880", "model_patch": "diff --git a/django/forms/fields.py b/django/forms/fields.py\nindex f5c7cc2..db63163 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -200,6 +200,7 @@ class Field:\n         memo[id(self)] = result\n         result.widget = copy.deepcopy(self.widget, memo)\n         result.validators = self.validators[:]\n+        result.error_messages = copy.deepcopy(self.error_messages, memo)\n         return result\n \n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11400", "model_patch": "diff --git a/django/contrib/admin/filters.py b/django/contrib/admin/filters.py\nindex 51b3fb2..33a7935 100644\n--- a/django/contrib/admin/filters.py\n+++ b/django/contrib/admin/filters.py\n@@ -198,6 +198,9 @@ class RelatedFieldListFilter(FieldListFilter):\n         related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n         if related_admin is not None:\n             ordering = related_admin.get_ordering(request)\n+        # Fall back to related model's Meta ordering if ModelAdmin ordering is not defined.\n+        if not ordering:\n+            ordering = field.remote_field.model._meta.ordering\n         return field.get_choices(include_blank=False, ordering=ordering)\n \n     def choices(self, changelist):\n@@ -419,4 +422,11 @@ FieldListFilter.register(lambda f: True, AllValuesFieldListFilter)\n class RelatedOnlyFieldListFilter(RelatedFieldListFilter):\n     def field_choices(self, field, request, model_admin):\n         pk_qs = model_admin.get_queryset(request).distinct().values_list('%s__pk' % self.field_path, flat=True)\n-        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs})\n+        # Apply ordering from related model's ModelAdmin or Meta ordering.\n+        ordering = ()\n+        related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n+        if related_admin is not None:\n+            ordering = related_admin.get_ordering(request)\n+        if not ordering:\n+            ordering = field.remote_field.model._meta.ordering\n+        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs}, ordering=ordering)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11206", "model_patch": "diff --git a/django/utils/numberformat.py b/django/utils/numberformat.py\nindex d5baf57..9d44a69 100644\n--- a/django/utils/numberformat.py\n+++ b/django/utils/numberformat.py\n@@ -1,3 +1,4 @@\n+\n from decimal import Decimal\n \n from django.conf import settings\n@@ -31,6 +32,9 @@ def format(number, decimal_sep, decimal_pos=None, grouping=0, thousand_sep='',\n         # scientific notation to avoid high memory usage in {:f}'.format().\n         _, digits, exponent = number.as_tuple()\n         if abs(exponent) + len(digits) > 200:\n+            if decimal_pos is not None:\n+                # If decimal_pos is provided and the number is too small, format as zero.\n+                return '0' + decimal_sep + ('0' * decimal_pos)\n             number = '{:e}'.format(number)\n             coefficient, exponent = number.split('e')\n             # Format the coefficient.\n@@ -76,4 +80,4 @@ def format(number, decimal_sep, decimal_pos=None, grouping=0, thousand_sep='',\n             int_part_gd += digit\n             cnt += 1\n         int_part = int_part_gd[::-1]\n-    return sign + int_part + dec_part\n+    return sign + int_part + dec_part\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14539", "model_patch": "diff --git a/astropy/io/fits/column.py b/astropy/io/fits/column.py\nindex 73adea9..5915ad5 100644\n--- a/astropy/io/fits/column.py\n+++ b/astropy/io/fits/column.py\n@@ -705,7 +705,7 @@ class Column(NotifierMixin):\n                 except ValueError:\n                     # then try variable length array\n                     # Note: This includes _FormatQ by inheritance\n-                    if isinstance(recformat, _FormatP):\n+                    if isinstance(recformat, ( _FormatP, _FormatQ )):\n                         array = _VLF(array, dtype=recformat.dtype)\n                     else:\n                         raise ValueError(\ndiff --git a/astropy/io/fits/diff.py b/astropy/io/fits/diff.py\nindex 0a08301..35114c6 100644\n--- a/astropy/io/fits/diff.py\n+++ b/astropy/io/fits/diff.py\n@@ -1454,9 +1454,7 @@ class TableDataDiff(_BaseDiff):\n                     [\n                         idx\n                         for idx in range(len(arra))\n-                        if not np.allclose(\n-                            arra[idx], arrb[idx], rtol=self.rtol, atol=self.atol\n-                        )\n+                        if not np.array_equal(arra[idx], arrb[idx])\n                     ],\n                 )\n             else:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12039", "model_patch": "diff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex 1e5b986..8c59011 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -84,7 +84,8 @@ class Columns(TableColumns):\n     def __str__(self):\n         def col_str(column, idx):\n             try:\n-                return self.quote_name(column) + self.col_suffixes[idx]\n+                suffix = self.col_suffixes[idx]\n+                return self.quote_name(column) + (' ' + suffix if suffix else '')\n             except IndexError:\n                 return self.quote_name(column)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12741", "model_patch": "diff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py\nindex 5fc53dc..ed2f91a 100644\n--- a/django/db/backends/base/operations.py\n+++ b/django/db/backends/base/operations.py\n@@ -400,9 +400,9 @@ class BaseDatabaseOperations:\n         \"\"\"\n         raise NotImplementedError('subclasses of BaseDatabaseOperations must provide a sql_flush() method')\n \n-    def execute_sql_flush(self, using, sql_list):\n+    def execute_sql_flush(self, sql_list):\n         \"\"\"Execute a list of SQL statements to flush the database.\"\"\"\n-        with transaction.atomic(using=using, savepoint=self.connection.features.can_rollback_ddl):\n+        with transaction.atomic(using=self.connection.alias, savepoint=self.connection.features.can_rollback_ddl):\n             with self.connection.cursor() as cursor:\n                 for sql in sql_list:\n                     cursor.execute(sql)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13023", "model_patch": "diff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 26e4726..84c061c 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -343,6 +343,8 @@ class DecimalField(IntegerField):\n             return None\n         if self.localize:\n             value = formats.sanitize_separators(value)\n+        if isinstance(value, dict):\n+            raise ValidationError(self.error_messages['invalid'], code='invalid')\n         value = str(value).strip()\n         try:\n             value = Decimal(value)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14995", "model_patch": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex fbb2aba..b1f14d9 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -520,10 +520,14 @@ class NDArithmeticMixin:\n         elif self.mask is None and operand is not None:\n             # Make a copy so there is no reference in the result.\n             return deepcopy(operand.mask)\n-        elif operand is None:\n+        elif operand is None or operand.mask is None:\n+            # If the operand or its mask is None, use self.mask directly.\n             return deepcopy(self.mask)\n+        elif self.mask is None:\n+            # If self.mask is None, use operand.mask directly.\n+            return deepcopy(operand.mask)\n         else:\n-            # Now lets calculate the resulting mask (operation enforces copy)\n+            # Now let's calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\n \n     def _arithmetic_wcs(self, operation, operand, compare_wcs, **kwds):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11239", "model_patch": "diff --git a/django/db/backends/postgresql/client.py b/django/db/backends/postgresql/client.py\nindex c7c6a11..85f56e0 100644\n--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -24,6 +24,17 @@ class DatabaseClient(BaseDatabaseClient):\n             args += ['-h', host]\n         if port:\n             args += ['-p', str(port)]\n+        sslcert = conn_params.get('options', {}).get('sslcert', '')\n+        sslkey = conn_params.get('options', {}).get('sslkey', '')\n+        sslrootcert = conn_params.get('options', {}).get('sslrootcert', '')\n+\n+        if sslcert:\n+            args += ['--sslcert', sslcert]\n+        if sslkey:\n+            args += ['--sslkey', sslkey]\n+        if sslrootcert:\n+            args += ['--sslrootcert', sslrootcert]\n+        \n         args += [dbname]\n \n         sigint_handler = signal.getsignal(signal.SIGINT)\n@@ -39,4 +50,4 @@ class DatabaseClient(BaseDatabaseClient):\n             signal.signal(signal.SIGINT, sigint_handler)\n \n     def runshell(self):\n-        DatabaseClient.runshell_db(self.connection.get_connection_params())\n+        DatabaseClient.runshell_db(self.connection.get_connection_params())\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12273", "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 07c5013..3d7d831 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -843,6 +843,8 @@ class Model(metaclass=ModelBase):\n         if pk_val is None:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n             setattr(self, meta.pk.attname, pk_val)\n+            # Reset the adding state to ensure a new object is created.\n+            self._state.adding = True\n         pk_set = pk_val is not None\n         if not pk_set and (force_update or update_fields):\n             raise ValueError(\"Cannot force an update in save() with no primary key.\")\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13109", "model_patch": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 72731ef..42136c1 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -914,7 +914,7 @@ class ForeignKey(ForeignObject):\n             return\n \n         using = router.db_for_read(self.remote_field.model, instance=model_instance)\n-        qs = self.remote_field.model._default_manager.using(using).filter(\n+        qs = self.remote_field.model._base_manager.using(using).filter(\n             **{self.remote_field.field_name: value}\n         )\n         qs = qs.complex_filter(self.get_limit_choices_to())\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11951", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex ba5549a..8005fa9 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -455,7 +455,11 @@ class QuerySet:\n         # PostgreSQL via the RETURNING ID clause. It should be possible for\n         # Oracle as well, but the semantics for extracting the primary keys is\n         # trickier so it's not done yet.\n-        assert batch_size is None or batch_size > 0\n+        if batch_size is not None:\n+            assert batch_size > 0\n+            batch_size = min(batch_size, connection.ops.bulk_batch_size(fields, objs))\n+        else:\n+            batch_size = connection.ops.bulk_batch_size(fields, objs)\n         # Check that the parents share the same concrete model with the our\n         # model to detect the inheritance pattern ConcreteGrandParent ->\n         # MultiTableParent -> ProxyChild. Simply checking self.model._meta.proxy\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11885", "model_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex da91f5e..65a8b7e 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -310,9 +310,17 @@ class Collector:\n                     )\n \n             # fast deletes\n+            combined_fast_deletes = {}\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                model = qs.model\n+                if model not in combined_fast_deletes:\n+                    combined_fast_deletes[model] = []\n+                combined_fast_deletes[model].append(qs)\n+\n+            for model, querysets in combined_fast_deletes.items():\n+                combined_qs = querysets[0].union(*querysets[1:])\n+                count = combined_qs._raw_delete(using=self.using)\n+                deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12262", "model_patch": "diff --git a/django/template/library.py b/django/template/library.py\nindex e9453ed..99ef57a 100644\n--- a/django/template/library.py\n+++ b/django/template/library.py\n@@ -116,9 +116,10 @@ class Library:\n                 if len(bits) >= 2 and bits[-2] == 'as':\n                     target_var = bits[-1]\n                     bits = bits[:-2]\n+                # Updated to handle keyword-only arguments with defaults correctly\n                 args, kwargs = parse_bits(\n                     parser, bits, params, varargs, varkw, defaults,\n-                    kwonly, kwonly_defaults, takes_context, function_name,\n+                    kwonly, kwonly_defaults or {}, takes_context, function_name,\n                 )\n                 return SimpleNode(func, takes_context, args, kwargs, target_var)\n             self.tag(function_name, compile_func)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12276", "model_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex e858b4f..1faf7a5 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -452,7 +452,10 @@ class ClearableFileInput(FileInput):\n         return upload\n \n     def use_required_attribute(self, initial):\n-        return super().use_required_attribute(initial) and not initial\n+        if initial:\n+            # Do not include the 'required' attribute if initial data exists.\n+            return False\n+        return super().use_required_attribute(initial)\n \n     def value_omitted_from_data(self, data, files, name):\n         return (\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-8872", "model_patch": "diff --git a/astropy/units/core.py b/astropy/units/core.py\nindex 36f248e..31d18de 100644\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -2336,7 +2336,7 @@ def _condition_arg(value):\n     ValueError\n         If value is not as expected\n     \"\"\"\n-    if isinstance(value, (float, int, complex)):\n+    if isinstance(value, (float, int, complex, np.float16)):\n         return value\n \n     if isinstance(value, np.ndarray) and value.dtype.kind in ['i', 'f', 'c']:\n@@ -2355,4 +2355,4 @@ one = dimensionless_unscaled\n \n # Maintain error in old location for backward compatibility\n # TODO: Is this still needed? Should there be a deprecation warning?\n-unit_format.fits.UnitScaleError = UnitScaleError\n+unit_format.fits.UnitScaleError = UnitScaleError\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11964", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 6957452..f4d50cd 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -916,7 +916,11 @@ class Field(RegisterLookupMixin):\n \n     def value_from_object(self, obj):\n         \"\"\"Return the value of this field in the given model instance.\"\"\"\n-        return getattr(obj, self.attname)\n+        value = getattr(obj, self.attname)\n+        # If the value is an Enum instance, return its value attribute.\n+        if isinstance(value, Enum):\n+            return value.value\n+        return value\n \n \n class BooleanField(Field):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12419", "model_patch": "diff --git a/django/middleware/security.py b/django/middleware/security.py\nindex 2cdbbc0..c618420 100644\n--- a/django/middleware/security.py\n+++ b/django/middleware/security.py\n@@ -51,5 +51,8 @@ class SecurityMiddleware(MiddlewareMixin):\n                 [v.strip() for v in self.referrer_policy.split(',')]\n                 if isinstance(self.referrer_policy, str) else self.referrer_policy\n             ))\n+        else:\n+            # Default to \"same-origin\" if no referrer policy is explicitly set.\n+            response.setdefault('Referrer-Policy', 'same-origin')\n \n-        return response\n+        return response\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11551", "model_patch": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 2c6f2d7..f2848a0 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -720,33 +720,33 @@ class ModelAdminChecks(BaseModelAdminChecks):\n             return []\n         elif hasattr(obj, item):\n             return []\n-        elif hasattr(obj.model, item):\n+        else:\n             try:\n                 field = obj.model._meta.get_field(item)\n             except FieldDoesNotExist:\n-                return []\n-            else:\n-                if isinstance(field, models.ManyToManyField):\n+                try:\n+                    field = getattr(obj.model, item)\n+                except AttributeError:\n                     return [\n                         checks.Error(\n-                            \"The value of '%s' must not be a ManyToManyField.\" % label,\n+                            \"The value of '%s' refers to '%s', which is not a callable, \"\n+                            \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n+                                label, item, obj.__class__.__name__,\n+                                obj.model._meta.app_label, obj.model._meta.object_name,\n+                            ),\n                             obj=obj.__class__,\n-                            id='admin.E109',\n+                            id='admin.E108',\n                         )\n                     ]\n-                return []\n-        else:\n-            return [\n-                checks.Error(\n-                    \"The value of '%s' refers to '%s', which is not a callable, \"\n-                    \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n-                        label, item, obj.__class__.__name__,\n-                        obj.model._meta.app_label, obj.model._meta.object_name,\n-                    ),\n-                    obj=obj.__class__,\n-                    id='admin.E108',\n-                )\n-            ]\n+            if isinstance(field, models.ManyToManyField):\n+                return [\n+                    checks.Error(\n+                        \"The value of '%s' must not be a ManyToManyField.\" % label,\n+                        obj=obj.__class__,\n+                        id='admin.E109',\n+                    )\n+                ]\n+            return []\n \n     def _check_list_display_links(self, obj):\n         \"\"\" Check that list_display_links is a unique subset of list_display.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12050", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex e5aab8e..be61769 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1073,7 +1073,7 @@ class Query(BaseExpression):\n                         ))\n                 else:\n                     resolved_values.append(sub_value)\n-            value = tuple(resolved_values)\n+            value = type(value)(resolved_values)\n         return value\n \n     def solve_lookup_type(self, lookup):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11999", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 26d79f0..c83719f 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,8 +763,9 @@ class Field(RegisterLookupMixin):\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\n-            setattr(cls, 'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self))\n+            method_name = 'get_%s_display' % self.name\n+            if not hasattr(cls, method_name):  # Only set if the method does not already exist\n+                setattr(cls, method_name, partialmethod(cls._get_FIELD_display, field=self))\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13513", "model_patch": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex d064033..4c3e42c 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -397,9 +397,10 @@ class ExceptionReporter:\n     def get_traceback_frames(self):\n         def explicit_or_implicit_cause(exc_value):\n             explicit = getattr(exc_value, '__cause__', None)\n-            suppress_context = getattr(exc_value, '__suppress_context__', None)\n+            if getattr(exc_value, '__suppress_context__', False):\n+                return explicit\n             implicit = getattr(exc_value, '__context__', None)\n-            return explicit or (None if suppress_context else implicit)\n+            return explicit or implicit\n \n         # Get the exception and all its causes\n         exceptions = []\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13012", "model_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 48095d5..e920a75 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -349,6 +349,9 @@ class BaseExpression:\n \n     def get_group_by_cols(self, alias=None):\n         if not self.contains_aggregate:\n+            # Exclude constant expressions from GROUP BY clause.\n+            if isinstance(self, Value):\n+                return []\n             return [self]\n         cols = []\n         for source in self.get_source_expressions():\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13195", "model_patch": "diff --git a/django/http/response.py b/django/http/response.py\nindex 244654c..a5c5cfc 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -213,10 +213,13 @@ class HttpResponseBase:\n     def delete_cookie(self, key, path='/', domain=None):\n         # Most browsers ignore the Set-Cookie header if the cookie name starts\n         # with __Host- or __Secure- and the cookie doesn't use the secure flag.\n-        secure = key.startswith(('__Secure-', '__Host-'))\n         self.set_cookie(\n-            key, max_age=0, path=path, domain=domain, secure=secure,\n+            key, max_age=0, path=path,\n             expires='Thu, 01 Jan 1970 00:00:00 GMT',\n+            domain=domain if domain is not None else settings.SESSION_COOKIE_DOMAIN,\n+            secure=settings.SESSION_COOKIE_SECURE or key.startswith(('__Secure-', '__Host-')),\n+            httponly=settings.SESSION_COOKIE_HTTPONLY or None,\n+            samesite=settings.SESSION_COOKIE_SAMESITE,\n         )\n \n     # Common methods used by subclasses\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11740", "model_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 816737e..b56630a 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -1058,6 +1058,9 @@ class MigrationAutodetector:\n                 )\n \n     def _get_dependencies_for_foreign_key(self, field):\n+        \"\"\"\n+        Ensure foreign key dependencies are included in migrations.\n+        \"\"\"\n         # Account for FKs to swappable models\n         swappable_setting = getattr(field, 'swappable_setting', None)\n         if swappable_setting is not None:\n@@ -1067,6 +1070,13 @@ class MigrationAutodetector:\n             dep_app_label = field.remote_field.model._meta.app_label\n             dep_object_name = field.remote_field.model._meta.object_name\n         dependencies = [(dep_app_label, dep_object_name, None, True)]\n+\n+        # Add dependency for the model being referenced by the ForeignKey\n+        if field.remote_field and field.remote_field.model:\n+            foreign_key_model = field.remote_field.model\n+            fk_app_label = foreign_key_model._meta.app_label\n+            fk_model_name = foreign_key_model._meta.object_name\n+            dependencies.append((fk_app_label, fk_model_name, None, True))\n         if getattr(field.remote_field, \"through\", None) and not field.remote_field.through._meta.auto_created:\n             dependencies.append((\n                 field.remote_field.through._meta.app_label,\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13449", "model_patch": "diff --git a/django/db/models/functions/window.py b/django/db/models/functions/window.py\nindex 01e5980..a9ac3f1 100644\n--- a/django/db/models/functions/window.py\n+++ b/django/db/models/functions/window.py\n@@ -46,7 +46,11 @@ class LagLeadFunction(Func):\n \n     def _resolve_output_field(self):\n         sources = self.get_source_expressions()\n-        return sources[0].output_field\n+        output_field = sources[0].output_field\n+        if isinstance(output_field, models.DecimalField):\n+            # Ensure the output is treated correctly for DecimalField.\n+            return models.FloatField()\n+        return output_field\n \n \n class Lag(LagLeadFunction):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12858", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex e39a628..35ab25c 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1912,8 +1912,14 @@ class Query(BaseExpression):\n                 if self.extra and item in self.extra:\n                     continue\n                 # names_to_path() validates the lookup. A descriptive\n-                # FieldError will be raise if it's not.\n-                self.names_to_path(item.split(LOOKUP_SEP), self.model._meta)\n+                # FieldError will be raised if it's not.\n+                path = self.names_to_path(item.split(LOOKUP_SEP), self.model._meta)\n+                # Check whether the final element in the path is a valid transform or lookup.\n+                final_field = path[-1]\n+                if hasattr(final_field, 'get_transform') and not final_field.get_transform(item.split(LOOKUP_SEP)[-1]):\n+                    raise FieldError(\n+                        \"Invalid lookup '%s' for ordering. You must use valid transforms or lookups.\" % item\n+                    )\n             elif not hasattr(item, 'resolve_expression'):\n                 errors.append(item)\n             if getattr(item, 'contains_aggregate', False):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13658", "model_patch": "diff --git a/django/core/management/__init__.py b/django/core/management/__init__.py\nindex 7e30832..f432c1d 100644\n--- a/django/core/management/__init__.py\n+++ b/django/core/management/__init__.py\n@@ -344,7 +344,12 @@ class ManagementUtility:\n         # Preprocess options to extract --settings and --pythonpath.\n         # These options could affect the commands that are available, so they\n         # must be processed early.\n-        parser = CommandParser(usage='%(prog)s subcommand [options] [args]', add_help=False, allow_abbrev=False)\n+        parser = CommandParser(\n+            prog=self.prog_name,\n+            usage='%(prog)s subcommand [options] [args]',\n+            add_help=False,\n+            allow_abbrev=False\n+        )\n         parser.add_argument('--settings')\n         parser.add_argument('--pythonpath')\n         parser.add_argument('args', nargs='*')  # catch-all\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13112", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14365", "model_patch": "diff --git a/astropy/io/ascii/qdp.py b/astropy/io/ascii/qdp.py\nindex 92431f5..ac89de6 100644\n--- a/astropy/io/ascii/qdp.py\n+++ b/astropy/io/ascii/qdp.py\n@@ -60,7 +60,7 @@ def _line_type(line, delimiter=None):\n     ValueError: Unrecognized QDP line...\n     \"\"\"\n     _decimal_re = r\"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?\"\n-    _command_re = r\"READ [TS]ERR(\\s+[0-9]+)+\"\n+    _command_re = r\"(?i)READ [TS]ERR(\\s+[0-9]+)+\"\n \n     sep = delimiter\n     if delimiter is None:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14089", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "django__django-13516", "model_patch": "diff --git a/django/core/management/base.py b/django/core/management/base.py\nindex c1c76e0..ab68a8f 100644\n--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -149,6 +149,7 @@ class OutputWrapper(TextIOBase):\n             msg += ending\n         style_func = style_func or self.style_func\n         self._out.write(style_func(msg))\n+        self._out.flush()\n \n \n class BaseCommand:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11149", "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex acc7653..754c173 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -2114,28 +2114,28 @@ class InlineModelAdmin(BaseModelAdmin):\n     def has_add_permission(self, request, obj):\n         if self.opts.auto_created:\n             # We're checking the rights to an auto-created intermediate model,\n-            # which doesn't have its own individual permissions. The user needs\n-            # to have the view permission for the related model in order to\n-            # be able to do anything with the intermediate model.\n-            return self.has_view_permission(request, obj)\n+            # which doesn't have its own individual permissions.\n+            # Users cannot delete from the intermediate model unless they have change permission\n+            # for the related model.\n+            return self.has_change_permission(request, obj)\n         return super().has_add_permission(request)\n \n     def has_change_permission(self, request, obj=None):\n         if self.opts.auto_created:\n             # We're checking the rights to an auto-created intermediate model,\n-            # which doesn't have its own individual permissions. The user needs\n-            # to have the view permission for the related model in order to\n-            # be able to do anything with the intermediate model.\n-            return self.has_view_permission(request, obj)\n+            # which doesn't have its own individual permissions.\n+            # Users cannot delete from the intermediate model unless they have change permission\n+            # for the related model.\n+            return self.has_change_permission(request, obj)\n         return super().has_change_permission(request)\n \n     def has_delete_permission(self, request, obj=None):\n         if self.opts.auto_created:\n             # We're checking the rights to an auto-created intermediate model,\n-            # which doesn't have its own individual permissions. The user needs\n-            # to have the view permission for the related model in order to\n-            # be able to do anything with the intermediate model.\n-            return self.has_view_permission(request, obj)\n+            # which doesn't have its own individual permissions.\n+            # Users cannot delete from the intermediate model unless they have change permission\n+            # for the related model.\n+            return self.has_change_permission(request, obj)\n         return super().has_delete_permission(request, obj)\n \n     def has_view_permission(self, request, obj=None):\n@@ -2159,4 +2159,4 @@ class StackedInline(InlineModelAdmin):\n \n \n class TabularInline(InlineModelAdmin):\n-    template = 'admin/edit_inline/tabular.html'\n+    template = 'admin/edit_inline/tabular.html'\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12143", "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 0fb4989..b3ffb52 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1631,7 +1631,7 @@ class ModelAdmin(BaseModelAdmin):\n \n     def _get_edited_object_pks(self, request, prefix):\n         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n-        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(prefix, self.model._meta.pk.name))\n+        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name))\n         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n \n     def _get_list_editable_queryset(self, request, prefix):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12308", "model_patch": "diff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex 07cdaa5..80cc496 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -398,6 +398,11 @@ def display_for_field(value, field, empty_value_display):\n         return formats.number_format(value)\n     elif isinstance(field, models.FileField) and value:\n         return format_html('<a href=\"{}\">{}</a>', value.url, value)\n+    elif isinstance(field, models.JSONField):\n+        try:\n+            return field.prepare_value(value)\n+        except Exception:  # Handle InvalidJSONInput or similar issues\n+            return empty_value_display\n     else:\n         return display_for_value(value, empty_value_display)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11555", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 291f673..9eed6c5 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -293,6 +293,11 @@ class SQLCompiler:\n                 order_by.append((OrderBy(Random()), False))\n                 continue\n \n+            if isinstance(field, OrderBy):\n+                # If field is already an OrderBy object, use it directly\n+                order_by.append((field, False))\n+                continue\n+\n             col, order = get_order_dir(field, asc)\n             descending = order == 'DESC'\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12125", "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 824ab10..f1207d1 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -90,12 +90,15 @@ class DeconstructableSerializer(BaseSerializer):\n \n     @staticmethod\n     def _serialize_path(path):\n-        module, name = path.rsplit(\".\", 1)\n+        # Handle nested classes by splitting the full path and reconstructing it\n+        *module_parts, name = path.split(\".\")\n+        module = \".\".join(module_parts)\n         if module == \"django.db.models\":\n             imports = {\"from django.db import models\"}\n             name = \"models.%s\" % name\n         else:\n             imports = {\"import %s\" % module}\n+            # Reconstruct the full path to include nested classes\n             name = path\n         return name, imports\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12774", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 398c1d7..15af05e 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -689,7 +689,13 @@ class QuerySet:\n         \"\"\"\n         assert not self.query.is_sliced, \\\n             \"Cannot use 'limit' or 'offset' with in_bulk\"\n-        if field_name != 'pk' and not self.model._meta.get_field(field_name).unique:\n+        if field_name != 'pk' and not (\n+            self.model._meta.get_field(field_name).unique\n+            or any(\n+                field_name in constraint.fields\n+                for constraint in self.model._meta.total_unique_constraints\n+            )\n+        ):\n             raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n         if id_list is not None:\n             if not id_list:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13089", "model_patch": "diff --git a/django/core/cache/backends/db.py b/django/core/cache/backends/db.py\nindex a65b985..4d67c18 100644\n--- a/django/core/cache/backends/db.py\n+++ b/django/core/cache/backends/db.py\n@@ -267,13 +267,15 @@ class DatabaseCache(BaseDatabaseCache):\n                 cursor.execute(\n                     connection.ops.cache_key_culling_sql() % table,\n                     [cull_num])\n-                cursor.execute(\"DELETE FROM %s \"\n-                               \"WHERE cache_key < %%s\" % table,\n-                               [cursor.fetchone()[0]])\n+                result = cursor.fetchone()\n+                if result is not None:\n+                    cursor.execute(\"DELETE FROM %s \"\n+                                   \"WHERE cache_key < %%s\" % table,\n+                                   [result[0]])\n \n     def clear(self):\n         db = router.db_for_write(self.cache_model_class)\n         connection = connections[db]\n         table = connection.ops.quote_name(self._table)\n         with connection.cursor() as cursor:\n-            cursor.execute('DELETE FROM %s' % table)\n+            cursor.execute('DELETE FROM %s' % table)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14508", "model_patch": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 471c162..42d7d73 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -978,7 +978,15 @@ class Card(_Verify):\n             value = _format_value(self._value).strip()\n             value = f\"'{self.field_specifier}: {value}'\"\n         else:\n-            value = _format_value(value)\n+            if isinstance(value, float):\n+                # Prefer the default string representation of the float if it fits\n+                str_value = str(value)\n+                if len(str_value) <= 20:\n+                    value = str_value\n+                else:\n+                    value = f\"{value:.16G}\"  # Fallback to existing behavior\n+            else:\n+                value = _format_value(value)\n \n         # For HIERARCH cards the value should be shortened to conserve space\n         if not self.field_specifier and len(self.keyword) > KEYWORD_LENGTH:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13670", "model_patch": "diff --git a/django/utils/dateformat.py b/django/utils/dateformat.py\nindex d97c9c0..2c52175 100644\n--- a/django/utils/dateformat.py\n+++ b/django/utils/dateformat.py\n@@ -326,7 +326,7 @@ class DateFormat(TimeFormat):\n \n     def y(self):\n         \"Year, 2 digits; e.g. '99'\"\n-        return str(self.data.year)[2:]\n+        return f\"{self.data.year % 100:02d}\"\n \n     def Y(self):\n         \"Year, 4 digits; e.g. '1999'\"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13410", "model_patch": "diff --git a/django/core/files/locks.py b/django/core/files/locks.py\nindex 19083f2..4938347 100644\n--- a/django/core/files/locks.py\n+++ b/django/core/files/locks.py\n@@ -107,9 +107,15 @@ else:\n             return True\n     else:\n         def lock(f, flags):\n-            ret = fcntl.flock(_fd(f), flags)\n-            return ret == 0\n+            try:\n+                fcntl.flock(_fd(f), flags)\n+                return True\n+            except OSError:\n+                return False\n \n         def unlock(f):\n-            ret = fcntl.flock(_fd(f), fcntl.LOCK_UN)\n-            return ret == 0\n+            try:\n+                fcntl.flock(_fd(f), fcntl.LOCK_UN)\n+                return True\n+            except OSError:\n+                return False\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13279", "model_patch": "diff --git a/django/contrib/sessions/base_session.py b/django/contrib/sessions/base_session.py\nindex f59a2f7..15b1d6a 100644\n--- a/django/contrib/sessions/base_session.py\n+++ b/django/contrib/sessions/base_session.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n This module allows importing AbstractBaseSession even\n when django.contrib.sessions is not in INSTALLED_APPS.\n@@ -12,7 +13,12 @@ class BaseSessionManager(models.Manager):\n         Return the given session dictionary serialized and encoded as a string.\n         \"\"\"\n         session_store_class = self.model.get_session_store_class()\n-        return session_store_class().encode(session_dict)\n+        from django.conf import settings\n+\n+        if settings.DEFAULT_HASHING_ALGORITHM == 'sha1':\n+            return session_store_class().legacy_encode(session_dict)\n+        else:\n+            return session_store_class().encode(session_dict)\n \n     def save(self, session_key, session_dict, expire_date):\n         s = self.model(session_key, self.encode(session_dict), expire_date)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13344", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "django__django-10554", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex ab425fb..1a0b678 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -348,15 +348,18 @@ class SQLCompiler:\n                 # query; necessary since the columns can't be referenced by the\n                 # fully qualified name and the simple column names may collide.\n                 for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n-                    if is_ref and col_alias == src.refs:\n-                        src = src.source\n-                    elif col_alias:\n-                        continue\n-                    if src == sel_expr:\n+                    if col_alias and is_ref and col_alias == src.refs:\n+                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n+                        break\n+                    elif src == sel_expr:\n                         resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n                         break\n                 else:\n-                    raise DatabaseError('ORDER BY term does not match any column in the result set.')\n+                    # Fallback: Ensure the ORDER BY term always matches a valid column\n+                    raise DatabaseError(\n+                        'ORDER BY term does not match any column in the result set. '\n+                        'Ensure all orderings reference valid columns in the SELECT clause.'\n+                    )\n             sql, params = self.compile(resolved)\n             # Don't add the same column twice, but the order direction is\n             # not taken into account so we strip it. When this entire method\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11820", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 9e6898b..dab9905 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -697,6 +697,9 @@ class SQLCompiler:\n         name, order = get_order_dir(name, default_order)\n         descending = order == 'DESC'\n         pieces = name.split(LOOKUP_SEP)\n+        if pieces[-1] == 'pk':\n+            # Resolve 'pk' to the primary key field name of the related model.\n+            pieces[-1] = opts.pk.name\n         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n \n         # If we get to this point and the field is a relation to another model,\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13028", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex a6a3e97..88dd6f2 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1124,10 +1124,9 @@ class Query(BaseExpression):\n \n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n-        if not getattr(expression, 'filterable', True):\n+        if hasattr(expression, 'filterable') and not expression.filterable:\n             raise NotSupportedError(\n-                expression.__class__.__name__ + ' is disallowed in the filter '\n-                'clause.'\n+                f\"{expression.__class__.__name__} is disallowed in the filter clause.\"\n             )\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13315", "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex e59da5c..3b5f8d7 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -100,7 +100,7 @@ def apply_limit_choices_to_to_formfield(formfield):\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n-            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to).distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13121", "model_patch": "diff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py\nindex 0403e91..0233e36 100644\n--- a/django/db/backends/base/operations.py\n+++ b/django/db/backends/base/operations.py\n@@ -580,7 +580,11 @@ class BaseDatabaseOperations:\n \n     def convert_durationfield_value(self, value, expression, connection):\n         if value is not None:\n-            return datetime.timedelta(0, 0, value)\n+            # Convert value to decimal microseconds for compatibility with arithmetic expressions\n+            try:\n+                return decimal.Decimal(value) / decimal.Decimal(1000000)\n+            except decimal.InvalidOperation:\n+                raise ValueError(\"Invalid duration value for conversion: %s\" % value)\n \n     def check_expression_support(self, expression):\n         \"\"\"\ndiff --git a/django/db/backends/mysql/operations.py b/django/db/backends/mysql/operations.py\nindex bdf5359..21a1a74 100644\n--- a/django/db/backends/mysql/operations.py\n+++ b/django/db/backends/mysql/operations.py\n@@ -151,7 +151,8 @@ class DatabaseOperations(BaseDatabaseOperations):\n         return cursor.fetchall()\n \n     def format_for_duration_arithmetic(self, sql):\n-        return 'INTERVAL %s MICROSECOND' % sql\n+        # Ensure the SQL value is properly converted to integer microseconds for MySQL\n+        return 'INTERVAL %s MICROSECOND' % int(sql)\n \n     def force_no_ordering(self):\n         \"\"\"\ndiff --git a/django/db/backends/sqlite3/operations.py b/django/db/backends/sqlite3/operations.py\nindex 302ee8d..0871342 100644\n--- a/django/db/backends/sqlite3/operations.py\n+++ b/django/db/backends/sqlite3/operations.py\n@@ -75,7 +75,8 @@ class DatabaseOperations(BaseDatabaseOperations):\n         return \"django_date_extract('%s', %s)\" % (lookup_type.lower(), field_name)\n \n     def date_interval_sql(self, timedelta):\n-        return str(duration_microseconds(timedelta))\n+        # Convert timedelta to decimal microseconds for SQLite duration arithmetic compatibility\n+        return str(int(duration_microseconds(timedelta)))\n \n     def format_for_duration_arithmetic(self, sql):\n         \"\"\"Do nothing since formatting is handled in the custom function.\"\"\"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13512", "model_patch": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 1bfa7e4..c60f623 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -81,7 +81,7 @@ class JSONField(CheckFieldDefaultMixin, Field):\n     def get_prep_value(self, value):\n         if value is None:\n             return value\n-        return json.dumps(value, cls=self.encoder)\n+        return json.dumps(value, cls=self.encoder, ensure_ascii=False)\n \n     def get_transform(self, name):\n         transform = super().get_transform(name)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13128", "model_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 215532d..4a125d1 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -459,6 +459,7 @@ class CombinedExpression(SQLiteNumericMixin, Expression):\n             return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)\n         datetime_fields = {'DateField', 'DateTimeField', 'TimeField'}\n         if self.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:\n+            self.output_field = DurationField()  # Ensure output_field is set for temporal subtraction\n             return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)\n         expressions = []\n         expression_params = []\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12325", "model_patch": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 0cf39d7..23b2e82 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -240,9 +240,12 @@ class Options:\n \n         if self.pk is None:\n             if self.parents:\n-                # Promote the first parent link in lieu of adding yet another\n-                # field.\n-                field = next(iter(self.parents.values()))\n+                # Explicitly find the first parent link with parent_link=True\n+                # instead of relying on the order of fields.\n+                field = next(\n+                    (fld for fld in self.parents.values() if fld.remote_field.parent_link),\n+                    next(iter(self.parents.values()))  # Fallback to original behavior\n+                )\n                 # Look for a local field with the same name as the\n                 # first parent link. If a local field has already been\n                 # created, use it instead of promoting the parent\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13741", "model_patch": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex ac42308..4e1c8e0 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -56,6 +56,7 @@ class ReadOnlyPasswordHashField(forms.Field):\n \n     def __init__(self, *args, **kwargs):\n         kwargs.setdefault(\"required\", False)\n+        kwargs.setdefault(\"disabled\", True)\n         super().__init__(*args, **kwargs)\n \n     def bound_data(self, data, initial):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13297", "model_patch": "diff --git a/django/views/generic/base.py b/django/views/generic/base.py\nindex 5b48898..bbe82ab 100644\n--- a/django/views/generic/base.py\n+++ b/django/views/generic/base.py\n@@ -178,7 +178,7 @@ def _wrap_url_kwargs_with_deprecation_warning(url_kwargs):\n                 RemovedInDjango40Warning, stacklevel=2,\n             )\n             return value\n-        context_kwargs[key] = access_value\n+        context_kwargs[key] = access_value()\n     return context_kwargs\n \n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex d7d8448..797d792 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -403,10 +403,13 @@ class BaseDatabaseSchemaEditor:\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n-        constraint_names = self._constraint_names(\n-            model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n-        )\n+        constraint_names = [\n+            name for name in self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                **constraint_kwargs\n+            )\n+            if self.connection.introspection.get_constraint_type(model._meta.db_table, name) == \"index\"\n+        ]\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12754", "model_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 12ebcde..c161b8f 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -181,8 +181,8 @@ class MigrationAutodetector:\n         self.generate_removed_indexes()\n         # Generate field operations\n         self.generate_renamed_fields()\n-        self.generate_removed_fields()\n         self.generate_added_fields()\n+        self.generate_removed_fields()\n         self.generate_altered_fields()\n         self.generate_altered_unique_together()\n         self.generate_altered_index_together()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12209", "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex a315aef..bfa9aae 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -852,7 +852,8 @@ class Model(metaclass=ModelBase):\n             not force_insert and\n             self._state.adding and\n             self._meta.pk.default and\n-            self._meta.pk.default is not NOT_PROVIDED\n+            self._meta.pk.default is not NOT_PROVIDED and\n+            pk_val is None\n         ):\n             force_insert = True\n         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12406", "model_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex ed2157a..d6d28a3 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -586,7 +586,11 @@ class ChoiceWidget(Widget):\n \n         for index, (option_value, option_label) in enumerate(self.choices):\n             if option_value is None:\n-                option_value = ''\n+                # Skip the blank option if the field is required (blank=False)\n+                if not self.is_required:\n+                    option_value = ''\n+                else:\n+                    continue\n \n             subgroup = []\n             if isinstance(option_label, (list, tuple)):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13551", "model_patch": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 4505013..e8b80cb 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -94,7 +94,7 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        return str(user.pk) + user.password + str(user.email) + str(login_timestamp) + str(timestamp)\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\n@@ -104,4 +104,4 @@ class PasswordResetTokenGenerator:\n         return datetime.now()\n \n \n-default_token_generator = PasswordResetTokenGenerator()\n+default_token_generator = PasswordResetTokenGenerator()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-11734", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex dbcceb5..a6eec43 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1050,7 +1050,12 @@ class Query(BaseExpression):\n             kwargs = {'reuse': can_reuse, 'allow_joins': allow_joins}\n             if isinstance(value, F):\n                 kwargs['simple_col'] = simple_col\n-            value = value.resolve_expression(self, **kwargs)\n+            # Ensure correct handling of OuterRef within exclude() or ~Q()\n+            if isinstance(value, OuterRef) and self.subquery:\n+                value = value.resolve_expression(self, **kwargs)\n+                value.subquery = True\n+            else:\n+                value = value.resolve_expression(self, **kwargs)\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13807", "model_patch": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex 3a40a2e..4a6bc01 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -327,18 +327,18 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n                     violations = cursor.execute('PRAGMA foreign_key_check').fetchall()\n                 else:\n                     violations = chain.from_iterable(\n-                        cursor.execute('PRAGMA foreign_key_check(%s)' % table_name).fetchall()\n+                        cursor.execute('PRAGMA foreign_key_check(`%s`)' % table_name).fetchall()\n                         for table_name in table_names\n                     )\n                 # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check\n                 for table_name, rowid, referenced_table_name, foreign_key_index in violations:\n                     foreign_key = cursor.execute(\n-                        'PRAGMA foreign_key_list(%s)' % table_name\n+                        'PRAGMA foreign_key_list(`%s`)' % table_name\n                     ).fetchall()[foreign_key_index]\n                     column_name, referenced_column_name = foreign_key[3:5]\n                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n                     primary_key_value, bad_value = cursor.execute(\n-                        'SELECT %s, %s FROM %s WHERE rowid = %%s' % (\n+                        'SELECT `%s`, `%s` FROM `%s` WHERE rowid = %%s' % (\n                             primary_key_column_name, column_name, table_name\n                         ),\n                         (rowid,),\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14539", "model_patch": "diff --git a/django/utils/html.py b/django/utils/html.py\nindex 809fc0f..302f30c 100644\n--- a/django/utils/html.py\n+++ b/django/utils/html.py\n@@ -284,7 +284,7 @@ def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):\n             stripped = middle_unescaped.rstrip(TRAILING_PUNCTUATION_CHARS)\n             if middle_unescaped != stripped:\n                 trail = middle[len(stripped):] + trail\n-                middle = middle[:len(stripped) - len(middle_unescaped)]\n+                middle = middle[:len(stripped)]\n                 trimmed_something = True\n         return lead, middle, trail\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13590", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex cc286ae..5f2c225 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1078,8 +1078,8 @@ class Query(BaseExpression):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n             return type(value)(\n-                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n-                for sub_value in value\n+                *(self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n+                  for sub_value in value)\n             )\n         return value\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14404", "model_patch": "diff --git a/django/http/request.py b/django/http/request.py\nindex 90884ef..d453811 100644\n--- a/django/http/request.py\n+++ b/django/http/request.py\n@@ -146,7 +146,7 @@ class HttpRequest:\n         return self._get_full_path(self.path, force_append_slash)\n \n     def get_full_path_info(self, force_append_slash=False):\n-        return self._get_full_path(self.path_info, force_append_slash)\n+        return self._get_full_path(self.path, force_append_slash)\n \n     def _get_full_path(self, path, force_append_slash):\n         # RFC 3986 requires query string arguments to be in the ASCII range.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13212", "model_patch": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 1b74a94..ab5d84c 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -48,7 +48,7 @@ class RegexValidator:\n         regex_matches = self.regex.search(str(value))\n         invalid_input = regex_matches if self.inverse_match else not regex_matches\n         if invalid_input:\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def __eq__(self, other):\n         return (\n@@ -100,11 +100,11 @@ class URLValidator(RegexValidator):\n \n     def __call__(self, value):\n         if not isinstance(value, str):\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n         # Check if the scheme is valid.\n         scheme = value.split('://')[0].lower()\n         if scheme not in self.schemes:\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         # Then check full URL\n         try:\n@@ -139,7 +139,7 @@ class URLValidator(RegexValidator):\n         # one byte for the length of the name and one byte for the trailing dot\n         # that's used to indicate absolute names in DNS.\n         if len(urlsplit(value).netloc) > 253:\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n \n integer_validator = RegexValidator(\n@@ -208,12 +208,12 @@ class EmailValidator:\n \n     def __call__(self, value):\n         if not value or '@' not in value:\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         user_part, domain_part = value.rsplit('@', 1)\n \n         if not self.user_regex.match(user_part):\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         if (domain_part not in self.domain_allowlist and\n                 not self.validate_domain_part(domain_part)):\n@@ -225,7 +225,7 @@ class EmailValidator:\n             else:\n                 if self.validate_domain_part(domain_part):\n                     return\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def validate_domain_part(self, domain_part):\n         if self.domain_regex.match(domain_part):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13821", "model_patch": "diff --git a/django/db/backends/sqlite3/features.py b/django/db/backends/sqlite3/features.py\nindex c24ce20..f8900a2 100644\n--- a/django/db/backends/sqlite3/features.py\n+++ b/django/db/backends/sqlite3/features.py\n@@ -101,6 +101,8 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n \n     @cached_property\n     def supports_json_field(self):\n+        if self.connection.sqlite_version_info < (3, 9, 0):\n+            return False\n         with self.connection.cursor() as cursor:\n             try:\n                 with transaction.atomic(self.connection.alias):\n@@ -110,4 +112,4 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n         return True\n \n     can_introspect_json_field = property(operator.attrgetter('supports_json_field'))\n-    has_json_object_function = property(operator.attrgetter('supports_json_field'))\n+    has_json_object_function = property(operator.attrgetter('supports_json_field'))\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13401", "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 73f0fe4..0d33381 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -526,7 +526,7 @@ class Model(metaclass=ModelBase):\n     def __eq__(self, other):\n         if not isinstance(other, Model):\n             return NotImplemented\n-        if self._meta.concrete_model != other._meta.concrete_model:\n+        if self._meta.concrete_model != other._meta.concrete_model or self._meta.model != other._meta.model:\n             return False\n         my_pk = self.pk\n         if my_pk is None:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14608", "model_patch": "diff --git a/django/forms/formsets.py b/django/forms/formsets.py\nindex beca557..f9a27e7 100644\n--- a/django/forms/formsets.py\n+++ b/django/forms/formsets.py\n@@ -334,6 +334,7 @@ class BaseFormSet:\n         \"\"\"\n         self._errors = []\n         self._non_form_errors = self.error_class()\n+        self._non_form_errors.class_name = 'nonform'\n         empty_forms_count = 0\n \n         if not self.is_bound:  # Stop further processing.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13406", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 3533127..350ff56 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1284,6 +1284,7 @@ class QuerySet:\n             obj.query.filter_is_sticky = True\n             obj._sticky_filter = False\n         obj.__dict__.update(kwargs)\n+        obj._iterable_class = getattr(self, '_iterable_class', ModelIterable)\n         return obj\n \n     def _clone(self):\n@@ -1296,7 +1297,7 @@ class QuerySet:\n         c._for_write = self._for_write\n         c._prefetch_related_lookups = self._prefetch_related_lookups[:]\n         c._known_related_objects = self._known_related_objects\n-        c._iterable_class = self._iterable_class\n+        c._iterable_class = getattr(self, '_iterable_class', ModelIterable)\n         c._fields = self._fields\n         return c\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12965", "model_patch": "diff --git a/django/db/backends/mysql/compiler.py b/django/db/backends/mysql/compiler.py\nindex b3d1d61..ac06487 100644\n--- a/django/db/backends/mysql/compiler.py\n+++ b/django/db/backends/mysql/compiler.py\n@@ -17,6 +17,14 @@ class SQLDeleteCompiler(compiler.SQLDeleteCompiler, SQLCompiler):\n     def as_sql(self):\n         if self.connection.features.update_can_self_select or self.single_alias:\n             return super().as_sql()\n+        # Optimization: Use simple DELETE FROM when no WHERE clause exists\n+        if not self.query.where and not self.query.having:\n+            result = [\n+                'DELETE FROM %s' % self.quote_name_unless_alias(\n+                    self.query.get_initial_alias()\n+                )\n+            ]\n+            return ' '.join(result), ()\n         # MySQL and MariaDB < 10.3.2 doesn't support deletion with a subquery\n         # which is what the default implementation of SQLDeleteCompiler uses\n         # when multiple tables are involved. Use the MySQL/MariaDB specific\n@@ -40,4 +48,4 @@ class SQLUpdateCompiler(compiler.SQLUpdateCompiler, SQLCompiler):\n \n \n class SQLAggregateCompiler(compiler.SQLAggregateCompiler, SQLCompiler):\n-    pass\n+    pass\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14315", "model_patch": "diff --git a/django/db/backends/postgresql/client.py b/django/db/backends/postgresql/client.py\nindex 8b69ea1..8f69b1e 100644\n--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -1,3 +1,4 @@\n+\n import signal\n \n from django.db.backends.base.client import BaseDatabaseClient\n@@ -51,7 +52,7 @@ class DatabaseClient(BaseDatabaseClient):\n             env['PGSSLKEY'] = str(sslkey)\n         if passfile:\n             env['PGPASSFILE'] = str(passfile)\n-        return args, env\n+        return args, env if env else None\n \n     def runshell(self, parameters):\n         sigint_handler = signal.getsignal(signal.SIGINT)\n@@ -61,4 +62,4 @@ class DatabaseClient(BaseDatabaseClient):\n             super().runshell(parameters)\n         finally:\n             # Restore the original SIGINT handler.\n-            signal.signal(signal.SIGINT, sigint_handler)\n+            signal.signal(signal.SIGINT, sigint_handler)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13569", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 324369a..5a6fe05 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -128,7 +128,8 @@ class SQLCompiler:\n         for expr, (sql, params, is_ref) in order_by:\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n-            if not is_ref:\n+            # Also skip Random() expressions as they should not affect GROUP BY.\n+            if not is_ref and not isinstance(expr, Random):\n                 expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14373", "model_patch": "diff --git a/django/utils/dateformat.py b/django/utils/dateformat.py\nindex 38cb1c1..98b904c 100644\n--- a/django/utils/dateformat.py\n+++ b/django/utils/dateformat.py\n@@ -314,7 +314,7 @@ class DateFormat(TimeFormat):\n \n     def Y(self):\n         \"Year, 4 digits; e.g. '1999'\"\n-        return self.data.year\n+        return '%04d' % self.data.year\n \n     def z(self):\n         \"\"\"Day of the year, i.e. 1 to 366.\"\"\"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15103", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "django__django-13933", "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 72ffbcc..906cb9b 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1284,7 +1284,11 @@ class ModelChoiceField(ChoiceField):\n                 value = getattr(value, key)\n             value = self.queryset.get(**{key: value})\n         except (ValueError, TypeError, self.queryset.model.DoesNotExist):\n-            raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice')\n+            raise ValidationError(\n+                self.error_messages['invalid_choice'],\n+                code='invalid_choice',\n+                params={'value': value},\n+            )\n         return value\n \n     def validate(self, value):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13363", "model_patch": "diff --git a/django/db/models/functions/datetime.py b/django/db/models/functions/datetime.py\nindex 68c26c6..995aab8 100644\n--- a/django/db/models/functions/datetime.py\n+++ b/django/db/models/functions/datetime.py\n@@ -292,7 +292,7 @@ class TruncDate(TruncBase):\n     def as_sql(self, compiler, connection):\n         # Cast to date rather than truncate to date.\n         lhs, lhs_params = compiler.compile(self.lhs)\n-        tzname = timezone.get_current_timezone_name() if settings.USE_TZ else None\n+        tzname = self.tzinfo.tzname(None) if self.tzinfo else (timezone.get_current_timezone_name() if settings.USE_TZ else None)\n         sql = connection.ops.datetime_cast_date_sql(lhs, tzname)\n         return sql, lhs_params\n \n@@ -305,7 +305,7 @@ class TruncTime(TruncBase):\n     def as_sql(self, compiler, connection):\n         # Cast to time rather than truncate to time.\n         lhs, lhs_params = compiler.compile(self.lhs)\n-        tzname = timezone.get_current_timezone_name() if settings.USE_TZ else None\n+        tzname = self.tzinfo.tzname(None) if self.tzinfo else (timezone.get_current_timezone_name() if settings.USE_TZ else None)\n         sql = connection.ops.datetime_cast_time_sql(lhs, tzname)\n         return sql, lhs_params\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14017", "model_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex c757b1f..4288505 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -137,9 +137,9 @@ class Combinable:\n         return self._combine(other, self.POW, True)\n \n     def __rand__(self, other):\n-        raise NotImplementedError(\n-            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n-        )\n+        if isinstance(other, Q):\n+            return other & self\n+        raise TypeError(f\"Unsupported operand type(s) for &: '{type(other).__name__}' and '{type(self).__name__}'\")\n \n     def __ror__(self, other):\n         raise NotImplementedError(\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13810", "model_patch": "diff --git a/django/core/handlers/base.py b/django/core/handlers/base.py\nindex 2cbbab1..e2d6eea 100644\n--- a/django/core/handlers/base.py\n+++ b/django/core/handlers/base.py\n@@ -51,11 +51,11 @@ class BaseHandler:\n                 middleware_is_async = middleware_can_async\n             try:\n                 # Adapt handler, if needed.\n-                handler = self.adapt_method_mode(\n+                adapted_handler = self.adapt_method_mode(\n                     middleware_is_async, handler, handler_is_async,\n                     debug=settings.DEBUG, name='middleware %s' % middleware_path,\n                 )\n-                mw_instance = middleware(handler)\n+                mw_instance = middleware(adapted_handler)\n             except MiddlewareNotUsed as exc:\n                 if settings.DEBUG:\n                     if str(exc):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14765", "model_patch": "diff --git a/django/db/migrations/state.py b/django/db/migrations/state.py\nindex 6496bf2..2b730a1 100644\n--- a/django/db/migrations/state.py\n+++ b/django/db/migrations/state.py\n@@ -91,10 +91,8 @@ class ProjectState:\n     def __init__(self, models=None, real_apps=None):\n         self.models = models or {}\n         # Apps to include from main registry, usually unmigrated ones\n-        if real_apps:\n-            self.real_apps = real_apps if isinstance(real_apps, set) else set(real_apps)\n-        else:\n-            self.real_apps = set()\n+        assert real_apps is None or isinstance(real_apps, set), \"real_apps must be a set or None\"\n+        self.real_apps = real_apps or set()\n         self.is_delayed = False\n         # {remote_model_key: {model_key: [(field_name, field)]}}\n         self.relations = None\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13417", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 5049ae4..b4698ef 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1224,7 +1224,7 @@ class QuerySet:\n             return True\n         if self.query.extra_order_by or self.query.order_by:\n             return True\n-        elif self.query.default_ordering and self.query.get_meta().ordering:\n+        elif self.query.default_ordering and self.query.get_meta().ordering and not self.query.group_by:\n             return True\n         else:\n             return False\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14376", "model_patch": "diff --git a/django/db/backends/mysql/base.py b/django/db/backends/mysql/base.py\nindex 66049be..c23cc0d 100644\n--- a/django/db/backends/mysql/base.py\n+++ b/django/db/backends/mysql/base.py\n@@ -200,9 +200,9 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         if settings_dict['USER']:\n             kwargs['user'] = settings_dict['USER']\n         if settings_dict['NAME']:\n-            kwargs['db'] = settings_dict['NAME']\n+            kwargs['database'] = settings_dict['NAME']\n         if settings_dict['PASSWORD']:\n-            kwargs['passwd'] = settings_dict['PASSWORD']\n+            kwargs['password'] = settings_dict['PASSWORD']\n         if settings_dict['HOST'].startswith('/'):\n             kwargs['unix_socket'] = settings_dict['HOST']\n         elif settings_dict['HOST']:\ndiff --git a/django/db/backends/mysql/client.py b/django/db/backends/mysql/client.py\nindex 443f0d2..2e1552f 100644\n--- a/django/db/backends/mysql/client.py\n+++ b/django/db/backends/mysql/client.py\n@@ -1,3 +1,4 @@\n+\n from django.db.backends.base.client import BaseDatabaseClient\n \n \n@@ -8,11 +9,11 @@ class DatabaseClient(BaseDatabaseClient):\n     def settings_to_cmd_args_env(cls, settings_dict, parameters):\n         args = [cls.executable_name]\n         env = None\n-        db = settings_dict['OPTIONS'].get('db', settings_dict['NAME'])\n+        db = settings_dict['OPTIONS'].get('database', settings_dict['NAME'])\n         user = settings_dict['OPTIONS'].get('user', settings_dict['USER'])\n         password = settings_dict['OPTIONS'].get(\n             'password',\n-            settings_dict['OPTIONS'].get('passwd', settings_dict['PASSWORD'])\n+            settings_dict['PASSWORD']\n         )\n         host = settings_dict['OPTIONS'].get('host', settings_dict['HOST'])\n         port = settings_dict['OPTIONS'].get('port', settings_dict['PORT'])\n@@ -54,4 +55,4 @@ class DatabaseClient(BaseDatabaseClient):\n         if db:\n             args += [db]\n         args.extend(parameters)\n-        return args, env\n+        return args, env\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13809", "model_patch": "diff --git a/django/core/management/commands/runserver.py b/django/core/management/commands/runserver.py\nindex 85f7e9c..1c36bbe 100644\n--- a/django/core/management/commands/runserver.py\n+++ b/django/core/management/commands/runserver.py\n@@ -52,6 +52,8 @@ class Command(BaseCommand):\n             help='Tells Django to NOT use the auto-reloader.',\n         )\n \n+    requires_system_checks = True\n+\n     def execute(self, *args, **options):\n         if options['no_color']:\n             # We rely on the environment because it's currently the only\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13033", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 13e70df..0610eef 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -283,7 +283,8 @@ class SQLCompiler:\n             ordering = self.query.order_by\n         elif self.query.order_by:\n             ordering = self.query.order_by\n-        elif self.query.get_meta().ordering:\n+        elif self.query.get_meta().ordering and not self.query.order_by:\n+            # Only use Meta ordering if no explicit order_by() is set.\n             ordering = self.query.get_meta().ordering\n             self._meta_ordering = ordering\n         else:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14238", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex c552973..dd3ed33 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2524,7 +2524,7 @@ class AutoFieldMeta(type):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12713", "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 75fe555..9eaeb65 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -249,16 +249,17 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n             return None\n         db = kwargs.get('using')\n \n-        autocomplete_fields = self.get_autocomplete_fields(request)\n-        if db_field.name in autocomplete_fields:\n-            kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\n-        elif db_field.name in self.raw_id_fields:\n-            kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n-        elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n-            kwargs['widget'] = widgets.FilteredSelectMultiple(\n-                db_field.verbose_name,\n-                db_field.name in self.filter_vertical\n-            )\n+        if 'widget' not in kwargs:\n+            autocomplete_fields = self.get_autocomplete_fields(request)\n+            if db_field.name in autocomplete_fields:\n+                kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\n+            elif db_field.name in self.raw_id_fields:\n+                kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n+            elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n+                kwargs['widget'] = widgets.FilteredSelectMultiple(\n+                    db_field.verbose_name,\n+                    db_field.name in self.filter_vertical\n+                )\n \n         if 'queryset' not in kwargs:\n             queryset = self.get_field_queryset(db, db_field, request)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14559", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e895f59..a18a978 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -563,9 +563,12 @@ class QuerySet:\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+        total_rows_updated = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                rows_updated = self.filter(pk__in=pks).update(**update_kwargs)\n+                total_rows_updated += rows_updated\n+        return total_rows_updated\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14580", "model_patch": "diff --git a/django/db/migrations/writer.py b/django/db/migrations/writer.py\nindex 36f0ec3..dc46742 100644\n--- a/django/db/migrations/writer.py\n+++ b/django/db/migrations/writer.py\n@@ -162,9 +162,11 @@ class MigrationWriter:\n                 imports.remove(line)\n                 self.needs_manual_porting = True\n \n-        # django.db.migrations is always used, but models import may not be.\n-        # If models import exists, merge it with migrations import.\n-        if \"from django.db import models\" in imports:\n+        # django.db.migrations is always used.\n+        # Check if models import exists or is required based on operations.\n+        if \"from django.db import models\" in imports or any(\n+            \"models.\" in line for line in operations\n+        ):\n             imports.discard(\"from django.db import models\")\n             imports.add(\"from django.db import migrations, models\")\n         else:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13794", "model_patch": "diff --git a/django/template/defaultfilters.py b/django/template/defaultfilters.py\nindex 9115325..50470bf 100644\n--- a/django/template/defaultfilters.py\n+++ b/django/template/defaultfilters.py\n@@ -678,7 +678,7 @@ def add(value, arg):\n         return int(value) + int(arg)\n     except (ValueError, TypeError):\n         try:\n-            return value + arg\n+            return str(value) + str(arg)\n         except Exception:\n             return ''\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14311", "model_patch": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex ac16894..655d269 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -224,7 +224,7 @@ def get_child_arguments():\n     # see https://docs.python.org/3/reference/import.html#main-spec\n     # __spec__ may not exist, e.g. when running in a Conda env.\n     if getattr(__main__, '__spec__', None) is not None and __main__.__spec__.parent:\n-        args += ['-m', __main__.__spec__.parent]\n+        args += ['-m', __main__.__spec__.name]\n         args += sys.argv[1:]\n     elif not py_script.exists():\n         # sys.argv[0] may not exist for several reasons on Windows.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14155", "model_patch": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 43e675a..45072c8 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -59,8 +59,16 @@ class ResolverMatch:\n         return (self.func, self.args, self.kwargs)[index]\n \n     def __repr__(self):\n+        func_repr = self._func_path\n+        if isinstance(self.func, functools.partial):\n+            partial_func = self.func.func\n+            partial_args = self.func.args\n+            partial_kwargs = self.func.keywords\n+            func_repr = \"%s(args=%s, kwargs=%s)\" % (\n+                partial_func.__module__ + '.' + partial_func.__name__, partial_args, partial_kwargs\n+            )\n         return \"ResolverMatch(func=%s, args=%s, kwargs=%s, url_name=%s, app_names=%s, namespaces=%s, route=%s)\" % (\n-            self._func_path, self.args, self.kwargs, self.url_name,\n+            func_repr, self.args, self.kwargs, self.url_name,\n             self.app_names, self.namespaces, self.route,\n         )\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14855", "model_patch": "diff --git a/django/contrib/admin/helpers.py b/django/contrib/admin/helpers.py\nindex f4fe761..61f863f 100644\n--- a/django/contrib/admin/helpers.py\n+++ b/django/contrib/admin/helpers.py\n@@ -209,7 +209,11 @@ class AdminReadonlyField:\n             remote_field.model._meta.model_name,\n         )\n         try:\n-            url = reverse(url_name, args=[quote(remote_obj.pk)])\n+            url = reverse(\n+                url_name,\n+                args=[quote(remote_obj.pk)],\n+                current_app=self.model_admin.admin_site.name\n+            )\n             return format_html('<a href=\"{}\">{}</a>', url, remote_obj)\n         except NoReverseMatch:\n             return str(remote_obj)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13786", "model_patch": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 05e9a94..3947efa 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -141,7 +141,11 @@ class CreateModel(ModelOperation):\n                 CreateModel(\n                     self.name,\n                     fields=self.fields,\n-                    options={**self.options, **operation.options},\n+                    options={\n+                        key: value\n+                        for key, value in {**self.options, **operation.options}.items()\n+                        if key in operation.options or key not in self.options\n+                    },\n                     bases=self.bases,\n                     managers=self.managers,\n                 ),\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14672", "model_patch": "diff --git a/django/db/models/fields/reverse_related.py b/django/db/models/fields/reverse_related.py\nindex 7ae0a4d..ad36493 100644\n--- a/django/db/models/fields/reverse_related.py\n+++ b/django/db/models/fields/reverse_related.py\n@@ -301,7 +301,7 @@ class ManyToManyRel(ForeignObjectRel):\n \n         if through_fields and not through:\n             raise ValueError(\"Cannot specify through_fields without a through model\")\n-        self.through_fields = through_fields\n+        self.through_fields = make_hashable(through_fields) if through_fields else None\n \n         self.symmetrical = symmetrical\n         self.db_constraint = db_constraint\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14534", "model_patch": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 10f75a3..59987ee 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -277,8 +277,8 @@ class BoundWidget:\n \n     @property\n     def id_for_label(self):\n-        return 'id_%s_%s' % (self.data['name'], self.data['index'])\n+        return self.data['attrs'].get('id', 'id_%s_%s' % (self.data['name'], self.data['index']))\n \n     @property\n     def choice_label(self):\n-        return self.data['label']\n+        return self.data['label']\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15128", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "django__django-14349", "model_patch": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex fde6d56..5936d46 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -101,6 +101,10 @@ class URLValidator(RegexValidator):\n     def __call__(self, value):\n         if not isinstance(value, str):\n             raise ValidationError(self.message, code=self.code, params={'value': value})\n+        # Reject URLs containing forbidden characters (CR, LF, tab)\n+        if any(char in value for char in '\\r\\n\\t'):\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n+\n         # Check if the scheme is valid.\n         scheme = value.split('://')[0].lower()\n         if scheme not in self.schemes:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13568", "model_patch": "diff --git a/django/contrib/auth/checks.py b/django/contrib/auth/checks.py\nindex 2983afb..c10fae4 100644\n--- a/django/contrib/auth/checks.py\n+++ b/django/contrib/auth/checks.py\n@@ -1,3 +1,4 @@\n+\n from itertools import chain\n from types import MethodType\n \n@@ -52,7 +53,12 @@ def check_user_model(app_configs=None, **kwargs):\n         )\n \n     # Check that the username field is unique\n-    if not cls._meta.get_field(cls.USERNAME_FIELD).unique:\n+    username_field_is_unique = cls._meta.get_field(cls.USERNAME_FIELD).unique\n+    username_field_has_unique_constraint = any(\n+        isinstance(constraint, models.UniqueConstraint) and cls.USERNAME_FIELD in constraint.fields\n+        for constraint in cls._meta.constraints\n+    )\n+    if not (username_field_is_unique or username_field_has_unique_constraint):\n         if (settings.AUTHENTICATION_BACKENDS ==\n                 ['django.contrib.auth.backends.ModelBackend']):\n             errors.append(\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15127", "model_patch": "diff --git a/django/contrib/messages/storage/base.py b/django/contrib/messages/storage/base.py\nindex b6f1796..c85b05d 100644\n--- a/django/contrib/messages/storage/base.py\n+++ b/django/contrib/messages/storage/base.py\n@@ -38,7 +38,8 @@ class Message:\n \n     @property\n     def level_tag(self):\n-        return LEVEL_TAGS.get(self.level, '')\n+        from django.conf import settings\n+        return getattr(settings, 'MESSAGE_TAGS', {}).get(self.level, '')\n \n \n class BaseStorage:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14007", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e895f59..17dd4e9 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1286,7 +1286,19 @@ class QuerySet:\n             using = self.db\n         query = sql.InsertQuery(self.model, ignore_conflicts=ignore_conflicts)\n         query.insert_values(fields, objs, raw=raw)\n-        return query.get_compiler(using=using).execute_sql(returning_fields)\n+        results = query.get_compiler(using=using).execute_sql(returning_fields)\n+        if returning_fields:\n+            converters = [\n+                (field.get_db_converters(connections[using]), field)\n+                for field in returning_fields\n+            ]\n+            for result in results:\n+                for converters_list, field in converters:\n+                    for converter in converters_list:\n+                        result[field.attname] = converter(\n+                            result[field.attname], None, connections[using]\n+                        )\n+        return results\n     _insert.alters_data = True\n     _insert.queryset_only = False\n \n@@ -1310,6 +1322,13 @@ class QuerySet:\n                 ))\n             else:\n                 self._insert(item, fields=fields, using=self.db, ignore_conflicts=ignore_conflicts)\n+        if bulk_return and not ignore_conflicts:\n+            for row in inserted_rows:\n+                for field in self.model._meta.db_returning_fields:\n+                    for converter in field.get_db_converters(connections[self.db]):\n+                        row[field.attname] = converter(\n+                            row[field.attname], None, connections[self.db]\n+                        )\n         return inserted_rows\n \n     def _chain(self, **kwargs):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14140", "model_patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex b9069df..3435530 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -87,7 +87,10 @@ class Q(tree.Node):\n         args, kwargs = (), {}\n         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n             child = self.children[0]\n-            kwargs = {child[0]: child[1]}\n+            if isinstance(child, tuple) and len(child) == 2:\n+                kwargs = {child[0]: child[1]}\n+            else:\n+                args = (child,)\n         else:\n             args = tuple(self.children)\n             if self.connector != self.default:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14915", "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5a30801..55b3c81 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1171,6 +1171,9 @@ class ModelChoiceIteratorValue:\n             other = other.value\n         return self.value == other\n \n+    def __hash__(self):\n+        return hash(self.value)\n+\n \n class ModelChoiceIterator:\n     def __init__(self, field):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13820", "model_patch": "diff --git a/django/db/migrations/loader.py b/django/db/migrations/loader.py\nindex 3ec0678..99b47ae 100644\n--- a/django/db/migrations/loader.py\n+++ b/django/db/migrations/loader.py\n@@ -90,7 +90,7 @@ class MigrationLoader:\n             else:\n                 # Empty directories are namespaces.\n                 # getattr() needed on PY36 and older (replace w/attribute access).\n-                if getattr(module, '__file__', None) is None:\n+                if getattr(module, '__file__', None) is None and not isinstance(getattr(module, '__path__', None), list):\n                     self.unmigrated_apps.add(app_config.label)\n                     continue\n                 # Module is not a package (e.g. migrations.py).\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14434", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 941fcdc..1ba4f23 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1251,7 +1251,7 @@ class BaseDatabaseSchemaEditor:\n         else:\n             sql = self.sql_create_unique\n         if columns:\n-            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n+            columns = self._index_columns(table.name, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n             columns = Expressions(model._meta.db_table, expressions, compiler, self.quote_value)\n         return Statement(\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15572", "model_patch": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex 8bb0dd2..43235cf 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -1,3 +1,4 @@\n+\n from pathlib import Path\n \n from django.dispatch import receiver\n@@ -17,7 +18,7 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        items.update(cwd / to_path(dir) for dir in filter(None, backend.engine.dirs))\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, \"get_dirs\"):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15851", "model_patch": "diff --git a/django/db/backends/postgresql/client.py b/django/db/backends/postgresql/client.py\nindex 55aff39..5a580e9 100644\n--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -1,3 +1,4 @@\n+\n import signal\n \n from django.db.backends.base.client import BaseDatabaseClient\n@@ -32,9 +33,9 @@ class DatabaseClient(BaseDatabaseClient):\n             args += [\"-h\", host]\n         if port:\n             args += [\"-p\", str(port)]\n+        args.extend(parameters)\n         if dbname:\n             args += [dbname]\n-        args.extend(parameters)\n \n         env = {}\n         if passwd:\n@@ -61,4 +62,4 @@ class DatabaseClient(BaseDatabaseClient):\n             super().runshell(parameters)\n         finally:\n             # Restore the original SIGINT handler.\n-            signal.signal(signal.SIGINT, sigint_handler)\n+            signal.signal(signal.SIGINT, sigint_handler)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14787", "model_patch": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 9a57ac9..327c0dc 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -38,6 +38,8 @@ def _multi_decorate(decorators, method):\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n         bound_method = partial(method.__get__(self, type(self)))\n+        # Ensure that the wrapper retains the function attributes.\n+        bound_method = wraps(method)(bound_method)\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15467", "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 471e637..259c018 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -269,7 +269,7 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n                         \"class\": get_ul_class(self.radio_fields[db_field.name]),\n                     }\n                 )\n-                kwargs[\"empty_label\"] = _(\"None\") if db_field.blank else None\n+                kwargs[\"empty_label\"] = (kwargs.get(\"empty_label\") or _(\"None\")) if db_field.blank else None\n \n         if \"queryset\" not in kwargs:\n             queryset = self.get_field_queryset(db, db_field, request)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15277", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0cf1917..422b890 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1010,7 +1010,8 @@ class CharField(Field):\n     def __init__(self, *args, db_collation=None, **kwargs):\n         super().__init__(*args, **kwargs)\n         self.db_collation = db_collation\n-        self.validators.append(validators.MaxLengthValidator(self.max_length))\n+        if self.max_length is not None:\n+            self.validators.append(validators.MaxLengthValidator(self.max_length))\n \n     def check(self, **kwargs):\n         databases = kwargs.get('databases') or []\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14034", "model_patch": "diff --git a/django/forms/fields.py b/django/forms/fields.py\nindex b31d0ed..e6d9ec9 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1035,18 +1035,16 @@ class MultiValueField(Field):\n             except IndexError:\n                 field_value = None\n             if field_value in self.empty_values:\n-                if self.require_all_fields:\n+                if self.require_all_fields and self.required:\n                     # Raise a 'required' error if the MultiValueField is\n                     # required and any field is empty.\n-                    if self.required:\n-                        raise ValidationError(self.error_messages['required'], code='required')\n-                elif field.required:\n-                    # Otherwise, add an 'incomplete' error to the list of\n-                    # collected errors and skip field cleaning, if a required\n-                    # field is empty.\n-                    if field.error_messages['incomplete'] not in errors:\n+                    raise ValidationError(self.error_messages['required'], code='required')\n+                if field.required:\n+                    # Add an 'incomplete' error to the list of collected errors and \n+                    # skip field cleaning, if a required field is empty.\n+                    if field_value in self.empty_values:\n                         errors.append(field.error_messages['incomplete'])\n-                    continue\n+                        continue\n             try:\n                 clean_data.append(field.clean(field_value))\n             except ValidationError as e:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14011", "model_patch": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex 9aa8a59..e06cefb 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -81,6 +81,15 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n     \"\"\"A threaded version of the WSGIServer\"\"\"\n     daemon_threads = True\n \n+    def process_request_thread(self, request, client_address):\n+        \"\"\"Override to ensure database connections are closed.\"\"\"\n+        try:\n+            super().process_request_thread(request, client_address)\n+        finally:\n+            from django.db import connections\n+            for conn in connections.all():\n+                conn.close()\n+\n \n class ServerHandler(simple_server.ServerHandler):\n     http_version = '1.1'\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14771", "model_patch": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex b817434..7e5c4ab 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -219,7 +219,9 @@ def get_child_arguments():\n     import __main__\n     py_script = Path(sys.argv[0])\n \n-    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n+    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions] + [\n+        '-X%s' % k if v is True else f'-X{k}={v}' for k, v in sys._xoptions.items()\n+    ]\n     # __spec__ is set when the server was started with the `-m` option,\n     # see https://docs.python.org/3/reference/import.html#main-spec\n     # __spec__ may not exist, e.g. when running in a Conda env.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13158", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0d8d05..c84e326 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -991,7 +991,10 @@ class QuerySet:\n         # Clear limits and ordering so they can be reapplied\n         clone.query.clear_ordering(True)\n         clone.query.clear_limits()\n-        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+        if self.query.is_empty():\n+            clone.query.set_empty()\n+        else:\n+            clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n         clone.query.combinator = combinator\n         clone.query.combinator_all = all\n         return clone\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-12663", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 141497c..4f31e6b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -804,6 +804,8 @@ class Field(RegisterLookupMixin):\n         \"\"\"Perform preliminary non-db specific value checks and conversions.\"\"\"\n         if isinstance(value, Promise):\n             value = value._proxy____cast()\n+        if isinstance(value, SimpleLazyObject):\n+            value = value._wrapped if hasattr(value, '_wrapped') else value\n         return value\n \n     def get_db_prep_value(self, value, connection, prepared=False):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15561", "model_patch": "diff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex 86692c3..02f269b 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -121,7 +121,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             super().alter_db_table(model, old_db_table, new_db_table)\n \n     def alter_field(self, model, old_field, new_field, strict=False):\n-        if not self._field_should_be_altered(old_field, new_field):\n+        if not self._field_should_be_altered(old_field, new_field) or old_field.choices != new_field.choices:\n             return\n         old_field_name = old_field.name\n         table_name = model._meta.db_table\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14752", "model_patch": "diff --git a/django/contrib/admin/views/autocomplete.py b/django/contrib/admin/views/autocomplete.py\nindex cbda0a6..9c69ec5 100644\n--- a/django/contrib/admin/views/autocomplete.py\n+++ b/django/contrib/admin/views/autocomplete.py\n@@ -26,12 +26,18 @@ class AutocompleteJsonView(BaseListView):\n         context = self.get_context_data()\n         return JsonResponse({\n             'results': [\n-                {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}\n-                for obj in context['object_list']\n+                self.serialize_result(obj, to_field_name) for obj in context['object_list']\n             ],\n             'pagination': {'more': context['page_obj'].has_next()},\n         })\n \n+    def serialize_result(self, obj, to_field_name):\n+        \"\"\"\n+        Serialize a single result object to a dictionary.\n+        Can be overridden by subclasses for customization.\n+        \"\"\"\n+        return {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}\n+\n     def get_paginator(self, *args, **kwargs):\n         \"\"\"Use the ModelAdmin's paginator.\"\"\"\n         return self.model_admin.get_paginator(self.request, *args, **kwargs)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13964", "model_patch": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex b13a962..26cbac7 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -254,7 +254,17 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                related_value = getattr(value, rh_field.attname)\n+                setattr(instance, lh_field.attname, related_value)\n+            # Ensure the parent's foreign key field updates correctly\n+            # when the related object's primary key changes.\n+            if value._state.adding or value._state.db is None:\n+                def update_parent_pk(sender, **kwargs):\n+                    for lh_field, rh_field in self.field.related_fields:\n+                        related_value = getattr(value, rh_field.attname)\n+                        setattr(instance, lh_field.attname, related_value)\n+                from django.db.models.signals import post_save\n+                post_save.connect(update_parent_pk, sender=type(value), weak=False)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13343", "model_patch": "diff --git a/django/db/models/fields/files.py b/django/db/models/fields/files.py\nindex 4e9ee79..f60bed6 100644\n--- a/django/db/models/fields/files.py\n+++ b/django/db/models/fields/files.py\n@@ -279,7 +279,7 @@ class FileField(Field):\n             del kwargs[\"max_length\"]\n         kwargs['upload_to'] = self.upload_to\n         if self.storage is not default_storage:\n-            kwargs['storage'] = self.storage\n+            kwargs['storage'] = self.storage if not callable(self.storage) else self.storage.__name__\n         return name, path, args, kwargs\n \n     def get_internal_type(self):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13925", "model_patch": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex c6d9d53..469496c 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -279,7 +279,8 @@ class Options:\n                 already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                 if already_created:\n                     field = already_created[0]\n-                field.primary_key = True\n+                if not field.primary_key:\n+                    field.primary_key = True\n                 self.setup_pk(field)\n             else:\n                 pk_class = self._get_default_pk_class()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16255", "model_patch": "diff --git a/django/contrib/sitemaps/__init__.py b/django/contrib/sitemaps/__init__.py\nindex 012efea..8076c09 100644\n--- a/django/contrib/sitemaps/__init__.py\n+++ b/django/contrib/sitemaps/__init__.py\n@@ -168,7 +168,7 @@ class Sitemap:\n         if callable(self.lastmod):\n             try:\n                 return max([self.lastmod(item) for item in self.items()])\n-            except TypeError:\n+            except (TypeError, ValueError):\n                 return None\n         else:\n             return self.lastmod\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15268", "model_patch": "diff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py\nindex f01e0f5..cce5791 100644\n--- a/django/db/migrations/optimizer.py\n+++ b/django/db/migrations/optimizer.py\n@@ -44,6 +44,12 @@ class MigrationOptimizer:\n             right = True  # Should we reduce on the right or on the left.\n             # Compare it to each operation after it\n             for j, other in enumerate(operations[i + 1:]):\n+                # Add logic to merge consecutive AlterFooTogether operations\n+                if isinstance(operation, (operations.AlterUniqueTogether, operations.AlterIndexTogether)) and isinstance(other, type(operation)):\n+                    if operation.name == other.name:\n+                        combined_constraints = operation.option_value.union(other.option_value)\n+                        operation.option_value = combined_constraints\n+                        continue\n                 result = operation.reduce(other, app_label)\n                 if isinstance(result, list):\n                     in_between = operations[i + 1:i + j + 1]\n@@ -66,4 +72,4 @@ class MigrationOptimizer:\n                     right = False\n             else:\n                 new_operations.append(operation)\n-        return new_operations\n+        return new_operations\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15104", "model_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 7df5f70..6db1dcc 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -96,7 +96,7 @@ class MigrationAutodetector:\n         for name, field in sorted(fields.items()):\n             deconstruction = self.deep_deconstruct(field)\n             if field.remote_field and field.remote_field.model:\n-                del deconstruction[2]['to']\n+                deconstruction[2].pop('to', None)\n             fields_def.append(deconstruction)\n         return fields_def\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15731", "model_patch": "diff --git a/django/db/models/manager.py b/django/db/models/manager.py\nindex 768c26e..00c52b8 100644\n--- a/django/db/models/manager.py\n+++ b/django/db/models/manager.py\n@@ -84,8 +84,10 @@ class BaseManager:\n             def manager_method(self, *args, **kwargs):\n                 return getattr(self.get_queryset(), name)(*args, **kwargs)\n \n-            manager_method.__name__ = method.__name__\n-            manager_method.__doc__ = method.__doc__\n+            from functools import wraps\n+            @wraps(method)\n+            def manager_method(self, *args, **kwargs):\n+                return getattr(self.get_queryset(), name)(*args, **kwargs)\n             return manager_method\n \n         new_methods = {}\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14351", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex e16dbc0..dfd294f 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -226,6 +226,8 @@ class SQLCompiler:\n         assert not (self.query.select and self.query.default_cols)\n         if self.query.default_cols:\n             cols = self.get_default_columns()\n+            # Filter cols to ensure only primary key fields are included in subqueries\n+            cols = [col for col in cols if getattr(col.target, 'primary_key', False)]\n         else:\n             # self.query.select is a special case. These columns never go to\n             # any model.\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 9591387..0c73229 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -701,6 +701,9 @@ class Query(BaseExpression):\n                 add_to_dict(must_include, cur_model, opts.pk)\n             field = opts.get_field(parts[-1])\n             is_reverse_object = field.auto_created and not field.concrete\n+            # Ensure only primary key fields are included when fetching default columns\n+            if not field.primary_key:\n+                continue\n             model = field.related_model if is_reverse_object else field.model\n             model = model._meta.concrete_model\n             if model == opts.model:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15368", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 8c5f021..4c7bdcf 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -670,7 +670,7 @@ class QuerySet:\n                 when_statements = []\n                 for obj in batch_objs:\n                     attr = getattr(obj, field.attname)\n-                    if not isinstance(attr, Expression):\n+                    if not isinstance(attr, (Expression, F)):\n                         attr = Value(attr, output_field=field)\n                     when_statements.append(When(pk=obj.pk, then=attr))\n                 case_statement = Case(*when_statements, output_field=field)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14170", "model_patch": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 5eaf345..371e3bc 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -538,6 +538,10 @@ class IRegex(Regex):\n \n \n class YearLookup(Lookup):\n+    def is_iso_year_lookup(self):\n+        if isinstance(self.lhs.lhs.output_field, DateField) and self.lookup_name == 'iso_year':\n+            return True\n+        return False\n     def year_lookup_bounds(self, connection, year):\n         output_field = self.lhs.lhs.output_field\n         if isinstance(output_field, DateTimeField):\n@@ -548,8 +552,8 @@ class YearLookup(Lookup):\n \n     def as_sql(self, compiler, connection):\n         # Avoid the extract operation if the rhs is a direct value to allow\n-        # indexes to be used.\n-        if self.rhs_is_direct_value():\n+        # indexes to be used, except for iso_year lookups.\n+        if self.rhs_is_direct_value() and not self.is_iso_year_lookup():\n             # Skip the extract part by directly using the originating field,\n             # that is self.lhs.lhs.\n             lhs_sql, params = self.process_lhs(compiler, connection, self.lhs.lhs)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14500", "model_patch": "diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py\nindex 9e05ef1..ce58cc4 100644\n--- a/django/db/migrations/executor.py\n+++ b/django/db/migrations/executor.py\n@@ -254,6 +254,8 @@ class MigrationExecutor:\n         if migration.replaces:\n             for app_label, name in migration.replaces:\n                 self.recorder.record_unapplied(app_label, name)\n+            # Ensure the squashed migration itself is also marked as unapplied\n+            self.recorder.record_unapplied(migration.app_label, migration.name)\n         else:\n             self.recorder.record_unapplied(migration.app_label, migration.name)\n         # Report progress\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15278", "model_patch": "diff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex be6e066..a2d09c0 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -327,7 +327,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Fields with default values cannot by handled by ALTER TABLE ADD\n         # COLUMN statement because DROP DEFAULT is not supported in\n         # ALTER TABLE.\n-        if not field.null or self.effective_default(field) is not None:\n+        if not field.null or self.effective_default(field) is not None or field.unique:\n             self._remake_table(model, create_field=field)\n         else:\n             super().add_field(model, field)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15814", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 0f2a6be..b94a302 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,7 +748,7 @@ class Query(BaseExpression):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n-                opts = cur_model._meta\n+                opts = cur_model._meta.concrete_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n                 # (if it's not a reverse relation) to the things we select.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15863", "model_patch": "diff --git a/django/template/defaultfilters.py b/django/template/defaultfilters.py\nindex 9a0415d..a04d047 100644\n--- a/django/template/defaultfilters.py\n+++ b/django/template/defaultfilters.py\n@@ -151,11 +151,14 @@ def floatformat(text, arg=-1):\n             use_l10n = False\n             arg = arg[:-1] or -1\n     try:\n-        input_val = repr(text)\n-        d = Decimal(input_val)\n+        if isinstance(text, Decimal):\n+            d = text\n+        else:\n+            input_val = repr(text)\n+            d = Decimal(input_val)\n     except InvalidOperation:\n         try:\n-            d = Decimal(str(float(text)))\n+            d = Decimal(str(text))\n         except (ValueError, InvalidOperation, TypeError):\n             return \"\"\n     try:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15315", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 422b890..a7ecc1d 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -542,11 +542,7 @@ class Field(RegisterLookupMixin):\n         return NotImplemented\n \n     def __hash__(self):\n-        return hash((\n-            self.creation_counter,\n-            self.model._meta.app_label if hasattr(self, 'model') else None,\n-            self.model._meta.model_name if hasattr(self, 'model') else None,\n-        ))\n+        return hash(self.creation_counter)\n \n     def __deepcopy__(self, memodict):\n         # We don't have to deepcopy very much here, since most things are not\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14631", "model_patch": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex b5c646b..c53986a 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -120,7 +120,23 @@ class BoundField:\n         \"\"\"\n         return self.form._field_data_value(self.field, self.html_name)\n \n-    def value(self):\n+    def did_change(self):\n+        \"\"\"\n+        Determine if the field's data has changed from its initial value.\n+        \"\"\"\n+        data_value = self.form._field_data_value(self.field, self.html_name)\n+        initial_value = self.initial\n+        if self.field.show_hidden_initial:\n+            initial_prefixed_name = self.form.add_initial_prefix(self.name)\n+            hidden_widget = self.field.hidden_widget()\n+            try:\n+                initial_value = self.field.to_python(\n+                    self.form._widget_data_value(hidden_widget, initial_prefixed_name)\n+                )\n+            except ValidationError:\n+                # Always assume data has changed if validation fails.\n+                return True\n+        return self.field.has_changed(initial_value, data_value)\n         \"\"\"\n         Return the value for this BoundField, using the initial value if\n         the form is not bound or the data otherwise.\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 2c0336e..256dace 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -388,10 +388,8 @@ class BaseForm:\n \n     def _clean_fields(self):\n         for name, field in self.fields.items():\n-            if field.disabled:\n-                value = self.get_initial_for_field(field, name)\n-            else:\n-                value = self._field_data_value(field, self.add_prefix(name))\n+            bound_field = self[name]\n+            value = bound_field.value()\n             try:\n                 if isinstance(field, FileField):\n                     initial = self.get_initial_for_field(field, name)\n@@ -437,25 +435,7 @@ class BaseForm:\n     @cached_property\n     def changed_data(self):\n         data = []\n-        for name, field in self.fields.items():\n-            data_value = self._field_data_value(field, self.add_prefix(name))\n-            if not field.show_hidden_initial:\n-                # Use the BoundField's initial as this is the value passed to\n-                # the widget.\n-                initial_value = self[name].initial\n-            else:\n-                initial_prefixed_name = self.add_initial_prefix(name)\n-                hidden_widget = field.hidden_widget()\n-                try:\n-                    initial_value = field.to_python(\n-                        self._widget_data_value(hidden_widget, initial_prefixed_name)\n-                    )\n-                except ValidationError:\n-                    # Always assume data has changed if validation fails.\n-                    data.append(name)\n-                    continue\n-            if field.has_changed(initial_value, data_value):\n-                data.append(name)\n+        return [name for name, bf in self._bound_items() if bf.did_change()]\n         return data\n \n     @property\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14122", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex be54ccd..eb3a376 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -128,7 +128,8 @@ class SQLCompiler:\n         for expr, (sql, params, is_ref) in order_by:\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n-            if not is_ref:\n+            # Also skip expressions coming from Meta.ordering to avoid adding them to GROUP BY.\n+            if not is_ref and not getattr(expr, \"is_meta_ordering\", False):\n                 expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14999", "model_patch": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 165c6f5..9895061 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -320,12 +320,13 @@ class RenameModel(ModelOperation):\n         new_model = to_state.apps.get_model(app_label, self.new_name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n             old_model = from_state.apps.get_model(app_label, self.old_name)\n-            # Move the main table\n-            schema_editor.alter_db_table(\n-                new_model,\n-                old_model._meta.db_table,\n-                new_model._meta.db_table,\n-            )\n+            # Move the main table only if db_table is not explicitly defined\n+            if old_model._meta.db_table != new_model._meta.db_table:\n+                schema_editor.alter_db_table(\n+                    new_model,\n+                    old_model._meta.db_table,\n+                    new_model._meta.db_table,\n+                )\n             # Alter the fields pointing to us\n             for related_object in old_model._meta.related_objects:\n                 if related_object.related_model == old_model:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15375", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 3a34bd9..b9dea50 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1683,7 +1683,7 @@ class SQLAggregateCompiler(SQLCompiler):\n         inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(\n             self.using, elide_empty=self.elide_empty,\n         ).as_sql(with_col_aliases=True)\n-        sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)\n+        sql = 'SELECT %s FROM (%s) subquery' % (sql or '*', inner_query_sql)\n         params = params + inner_query_params\n         return sql, params\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15695", "model_patch": "diff --git a/django/db/backends/postgresql/schema.py b/django/db/backends/postgresql/schema.py\nindex fdd1271..c2456c9 100644\n--- a/django/db/backends/postgresql/schema.py\n+++ b/django/db/backends/postgresql/schema.py\n@@ -251,7 +251,8 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         )\n \n     def remove_index(self, model, index, concurrently=False):\n-        self.execute(index.remove_sql(model, self, concurrently=concurrently))\n+        if self._index_exists(model._meta.db_table, index.name):\n+            self.execute(index.remove_sql(model, self, concurrently=concurrently))\n \n     def _delete_index_sql(self, model, name, sql=None, concurrently=False):\n         sql = (\n@@ -259,6 +260,8 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             if concurrently\n             else self.sql_delete_index\n         )\n+        if not self._index_exists(model._meta.db_table, name):\n+            return None  # Skip deletion if the index doesn't exist.\n         return super()._delete_index_sql(model, name, sql)\n \n     def _create_index_sql(\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15022", "model_patch": "diff --git a/django/contrib/admin/views/main.py b/django/contrib/admin/views/main.py\nindex 4492771..ed43dce 100644\n--- a/django/contrib/admin/views/main.py\n+++ b/django/contrib/admin/views/main.py\n@@ -483,7 +483,8 @@ class ChangeList:\n             raise IncorrectLookupParameters(e)\n \n         # Apply search results\n-        qs, search_may_have_duplicates = self.model_admin.get_search_results(\n+        # Optimize search query to reduce unnecessary JOINs\n+        qs, search_may_have_duplicates = self.model_admin.get_search_results_optimized(\n             request, qs, self.query,\n         )\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14792", "model_patch": "diff --git a/django/db/backends/postgresql/operations.py b/django/db/backends/postgresql/operations.py\nindex 12df5a3..941a53d 100644\n--- a/django/db/backends/postgresql/operations.py\n+++ b/django/db/backends/postgresql/operations.py\n@@ -44,7 +44,10 @@ class DatabaseOperations(BaseDatabaseOperations):\n         return \"DATE_TRUNC('%s', %s)\" % (lookup_type, field_name)\n \n     def _prepare_tzname_delta(self, tzname):\n-        if '+' in tzname:\n+        if tzname.startswith('Etc/GMT'):\n+            # Do not reverse the sign for Etc/GMT time zones, as their naming is reversed by convention.\n+            return tzname\n+        elif '+' in tzname:\n             return tzname.replace('+', '-')\n         elif '-' in tzname:\n             return tzname.replace('-', '+')\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16502", "model_patch": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex 70fd79d..f99233a 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -225,6 +225,9 @@ class WSGIRequestHandler(simple_server.WSGIRequestHandler):\n         )\n         handler.request_handler = self  # backpointer for logging & connection closing\n         handler.run(self.server.get_app())\n+        # Remove the response body for HEAD requests to comply with RFC 2616\n+        if self.command == \"HEAD\":\n+            self.wfile = self.wfile.__class__(self.wfile.fp, close_connection=True)\n \n \n def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24026", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-22719", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "django__django-16429", "model_patch": "diff --git a/django/utils/timesince.py b/django/utils/timesince.py\nindex 4a5247a..bd99a92 100644\n--- a/django/utils/timesince.py\n+++ b/django/utils/timesince.py\n@@ -97,6 +97,7 @@ def timesince(d, now=None, reversed=False, time_strings=None, depth=2):\n             d.hour,\n             d.minute,\n             d.second,\n+            tzinfo=d.tzinfo,\n         )\n     else:\n         pivot = d\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15629", "model_patch": "diff --git a/django/db/backends/mysql/schema.py b/django/db/backends/mysql/schema.py\nindex a65d38d..a98c513 100644\n--- a/django/db/backends/mysql/schema.py\n+++ b/django/db/backends/mysql/schema.py\n@@ -167,8 +167,10 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n     def _alter_column_type_sql(self, model, old_field, new_field, new_type):\n         new_type = self._set_field_new_type_null_status(old_field, new_type)\n+        if getattr(new_field, 'db_collation', None):\n+            new_type += f\" COLLATE {new_field.db_collation}\"\n         return super()._alter_column_type_sql(model, old_field, new_field, new_type)\n \n     def _rename_field_sql(self, table, old_field, new_field, new_type):\n         new_type = self._set_field_new_type_null_status(old_field, new_type)\n-        return super()._rename_field_sql(table, old_field, new_field, new_type)\n+        return super()._rename_field_sql(table, old_field, new_field, new_type)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14493", "model_patch": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex 94188f6..9ccdd8a 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -261,8 +261,8 @@ class HashedFilesMixin:\n \n         paths = {path: paths[path] for path in adjustable_paths}\n \n+        substitutions = False\n         for i in range(self.max_post_process_passes):\n-            substitutions = False\n             for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):\n                 # Overwrite since hashed_name may be newer.\n                 processed_adjustable_paths[name] = (name, hashed_name, processed)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16333", "model_patch": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex 9d4c3a8..e964f19 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -141,6 +141,8 @@ class UserCreationForm(forms.ModelForm):\n         user.set_password(self.cleaned_data[\"password1\"])\n         if commit:\n             user.save()\n+        if commit:\n+            self.save_m2m()\n         return user\n \n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13837", "model_patch": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 3b7178c..3c33d4a 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -216,14 +216,13 @@ def get_child_arguments():\n     executable is reported to not have the .exe extension which can cause bugs\n     on reloading.\n     \"\"\"\n-    import django.__main__\n-    django_main_path = Path(django.__main__.__file__)\n-    py_script = Path(sys.argv[0])\n-\n+    import __main__\n     args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n-    if py_script == django_main_path:\n-        # The server was started with `python -m django runserver`.\n-        args += ['-m', 'django']\n+    if getattr(__main__, '__spec__', None) is not None:\n+        # The server was started with `python -m pkg_other_than_django runserver`.\n+        parent_module = __main__.__spec__.parent\n+        if parent_module:\n+            args += ['-m', parent_module]\n         args += sys.argv[1:]\n     elif not py_script.exists():\n         # sys.argv[0] may not exist for several reasons on Windows.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16612", "model_patch": "diff --git a/django/contrib/admin/sites.py b/django/contrib/admin/sites.py\nindex d64bf65..8459b34 100644\n--- a/django/contrib/admin/sites.py\n+++ b/django/contrib/admin/sites.py\n@@ -453,7 +453,11 @@ class AdminSite:\n                 pass\n             else:\n                 if getattr(match.func, \"should_append_slash\", True):\n-                    return HttpResponsePermanentRedirect(\"%s/\" % request.path)\n+                    query_string = request.META.get('QUERY_STRING', '')\n+                    redirect_url = \"%s/\" % request.path\n+                    if query_string:\n+                        redirect_url = \"%s?%s\" % (redirect_url, query_string)\n+                    return HttpResponsePermanentRedirect(redirect_url)\n         raise Http404\n \n     def _build_app_dict(self, request, label=None):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16116", "model_patch": "diff --git a/django/core/management/commands/makemigrations.py b/django/core/management/commands/makemigrations.py\nindex f0e76b4..646cee5 100644\n--- a/django/core/management/commands/makemigrations.py\n+++ b/django/core/management/commands/makemigrations.py\n@@ -250,9 +250,9 @@ class Command(BaseCommand):\n         else:\n             if self.update:\n                 self.write_to_last_migration_files(changes)\n-            else:\n+            elif not check_changes:\n                 self.write_migration_files(changes)\n-            if check_changes:\n+            else:\n                 sys.exit(1)\n \n     def write_to_last_migration_files(self, changes):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15503", "model_patch": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 0a76a39..36377da 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -227,9 +227,9 @@ class HasKeyLookup(PostgresOperatorLookup):\n         return super().as_postgresql(compiler, connection)\n \n     def as_sqlite(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_TYPE(%s, %%s) IS NOT NULL\"\n-        )\n+        # Cast numeric keys to text for correct lookup in SQLite\n+        template = \"JSON_TYPE(%s, CASE WHEN JSON_VALID(%%s) THEN %%s ELSE QUOTE(%%s) END) IS NOT NULL\"\n+        return self.as_sql(compiler, connection, template=template)\n \n \n class HasKey(HasKeyLookup):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15569", "model_patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex a485155..d8674ef 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -217,6 +217,7 @@ class RegisterLookupMixin:\n         if lookup_name is None:\n             lookup_name = lookup.lookup_name\n         del cls.class_lookups[lookup_name]\n+        cls._clear_cached_lookups()\n \n \n def select_related_descend(field, restricted, requested, load_fields, reverse=False):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16139", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "django__django-15499", "model_patch": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 111e13a..15feeaf 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -202,6 +202,19 @@ class CreateModel(ModelOperation):\n                     managers=self.managers,\n                 ),\n             ]\n+        elif (\n+            isinstance(operation, AlterModelManagers)\n+            and self.name_lower == operation.name_lower\n+        ):\n+            return [\n+                CreateModel(\n+                    self.name,\n+                    fields=self.fields,\n+                    options=self.options,\n+                    bases=self.bases,\n+                    managers=operation.managers,\n+                ),\n+            ]\n         elif (\n             isinstance(operation, FieldOperation)\n             and self.name_lower == operation.model_name_lower\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16145", "model_patch": "diff --git a/django/core/management/commands/runserver.py b/django/core/management/commands/runserver.py\nindex c4f663b..67a36ef 100644\n--- a/django/core/management/commands/runserver.py\n+++ b/django/core/management/commands/runserver.py\n@@ -147,7 +147,7 @@ class Command(BaseCommand):\n                 \"version\": self.get_version(),\n                 \"settings\": settings.SETTINGS_MODULE,\n                 \"protocol\": self.protocol,\n-                \"addr\": \"[%s]\" % self.addr if self._raw_ipv6 else self.addr,\n+                \"addr\": \"[%s]\" % self.addr if self._raw_ipv6 else (\"0.0.0.0\" if self.addr == \"0\" else self.addr),\n                 \"port\": self.port,\n                 \"quit_command\": quit_command,\n             }\n@@ -180,4 +180,4 @@ class Command(BaseCommand):\n         except KeyboardInterrupt:\n             if shutdown_message:\n                 self.stdout.write(shutdown_message)\n-            sys.exit(0)\n+            sys.exit(0)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14053", "model_patch": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex 04c866a..31acd6b 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -228,15 +228,20 @@ class HashedFilesMixin:\n         ]\n         # Do a single pass first. Post-process all files once, then repeat for\n         # adjustable files.\n+        yielded_files = set()\n         for name, hashed_name, processed, _ in self._post_process(paths, adjustable_paths, hashed_files):\n-            yield name, hashed_name, processed\n+            if name not in yielded_files:\n+                yield name, hashed_name, processed\n+                yielded_files.add(name)\n \n         paths = {path: paths[path] for path in adjustable_paths}\n \n         for i in range(self.max_post_process_passes):\n             substitutions = False\n             for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):\n-                yield name, hashed_name, processed\n+                if name not in yielded_files:\n+                    yield name, hashed_name, processed\n+                    yielded_files.add(name)\n                 substitutions = substitutions or subst\n \n             if not substitutions:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16136", "model_patch": "diff --git a/django/views/generic/base.py b/django/views/generic/base.py\nindex d6fb4a7..a28d4e1 100644\n--- a/django/views/generic/base.py\n+++ b/django/views/generic/base.py\n@@ -148,7 +148,14 @@ class View:\n             request.path,\n             extra={\"status_code\": 405, \"request\": request},\n         )\n-        return HttpResponseNotAllowed(self._allowed_methods())\n+        if self.view_is_async:\n+\n+            async def func():\n+                return HttpResponseNotAllowed(self._allowed_methods())\n+\n+            return func()\n+        else:\n+            return HttpResponseNotAllowed(self._allowed_methods())\n \n     def options(self, request, *args, **kwargs):\n         \"\"\"Handle responding to requests for the OPTIONS HTTP verb.\"\"\"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-14725", "model_patch": "diff --git a/django/forms/formsets.py b/django/forms/formsets.py\nindex 920d2a8..35455a3 100644\n--- a/django/forms/formsets.py\n+++ b/django/forms/formsets.py\n@@ -206,8 +206,8 @@ class BaseFormSet(RenderableFormMixin):\n             except IndexError:\n                 pass\n         # Allow extra forms to be empty, unless they're part of\n-        # the minimum forms.\n-        if i >= self.initial_form_count() and i >= self.min_num:\n+        # the minimum forms or creation is disallowed.\n+        if i >= self.initial_form_count() and i >= self.min_num and self.allow_creation:\n             defaults['empty_permitted'] = True\n         defaults.update(kwargs)\n         form = self.form(**defaults)\n@@ -478,7 +478,7 @@ class BaseFormSet(RenderableFormMixin):\n def formset_factory(form, formset=BaseFormSet, extra=1, can_order=False,\n                     can_delete=False, max_num=None, validate_max=False,\n                     min_num=None, validate_min=False, absolute_max=None,\n-                    can_delete_extra=True, renderer=None):\n+                    can_delete_extra=True, allow_creation=True, renderer=None):\n     \"\"\"Return a FormSet for the given form class.\"\"\"\n     if min_num is None:\n         min_num = DEFAULT_MIN_NUM\n@@ -495,7 +495,7 @@ def formset_factory(form, formset=BaseFormSet, extra=1, can_order=False,\n         )\n     attrs = {\n         'form': form,\n-        'extra': extra,\n+        'extra': extra if allow_creation else 0,\n         'can_order': can_order,\n         'can_delete': can_delete,\n         'can_delete_extra': can_delete_extra,\n@@ -504,6 +504,7 @@ def formset_factory(form, formset=BaseFormSet, extra=1, can_order=False,\n         'absolute_max': absolute_max,\n         'validate_min': validate_min,\n         'validate_max': validate_max,\n+        'allow_creation': allow_creation,\n         'renderer': renderer or get_default_renderer(),\n     }\n     return type(form.__name__ + 'FormSet', (formset,), attrs)\n@@ -512,4 +513,4 @@ def formset_factory(form, formset=BaseFormSet, extra=1, can_order=False,\n def all_valid(formsets):\n     \"\"\"Validate every formset and return True if all are valid.\"\"\"\n     # List comprehension ensures is_valid() is called for all formsets.\n-    return all([formset.is_valid() for formset in formsets])\n+    return all([formset.is_valid() for formset in formsets])\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16527", "model_patch": "diff --git a/django/contrib/admin/templatetags/admin_modify.py b/django/contrib/admin/templatetags/admin_modify.py\nindex 4d29402..1814767 100644\n--- a/django/contrib/admin/templatetags/admin_modify.py\n+++ b/django/contrib/admin/templatetags/admin_modify.py\n@@ -100,6 +100,7 @@ def submit_row(context):\n                 and context.get(\"show_delete\", True)\n             ),\n             \"show_save_as_new\": not is_popup\n+            and has_add_permission\n             and has_change_permission\n             and change\n             and save_as,\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15280", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 1013471..168e390 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1944,6 +1944,9 @@ def prefetch_one_level(instances, prefetcher, lookup, level):\n                 # cache_name points to a field name in obj.\n                 # This field is a descriptor for a related object.\n                 setattr(obj, cache_name, val)\n+                if isinstance(val, Model):\n+                    # Clear deferred fields cache for the inner object to prevent inheritance from the parent.\n+                    val._state.fields_cache.clear()\n             else:\n                 # No to_attr has been given for this prefetch operation and the\n                 # cache_name does not point to a descriptor. Store the value of\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15252", "model_patch": "diff --git a/django/db/migrations/recorder.py b/django/db/migrations/recorder.py\nindex cf1aec2..562b01c 100644\n--- a/django/db/migrations/recorder.py\n+++ b/django/db/migrations/recorder.py\n@@ -58,6 +58,9 @@ class MigrationRecorder:\n \n     def ensure_schema(self):\n         \"\"\"Ensure the table exists and has the correct schema.\"\"\"\n+        # Check if migrations are allowed for this connection using db_router\n+        if not router.allow_migrate(self.connection.alias, self.Migration):\n+            return\n         # If the table's there, that's fine - we've never changed its schema\n         # in the codebase.\n         if self.has_table():\n@@ -83,14 +86,20 @@ class MigrationRecorder:\n \n     def record_applied(self, app, name):\n         \"\"\"Record that a migration was applied.\"\"\"\n+        # Check if migrations are allowed for this connection using db_router\n+        if not router.allow_migrate(self.connection.alias, self.Migration):\n+            return\n         self.ensure_schema()\n         self.migration_qs.create(app=app, name=name)\n \n     def record_unapplied(self, app, name):\n         \"\"\"Record that a migration was unapplied.\"\"\"\n+        # Check if migrations are allowed for this connection using db_router\n+        if not router.allow_migrate(self.connection.alias, self.Migration):\n+            return\n         self.ensure_schema()\n         self.migration_qs.filter(app=app, name=name).delete()\n \n     def flush(self):\n         \"\"\"Delete all migration records. Useful for testing migrations.\"\"\"\n-        self.migration_qs.all().delete()\n+        self.migration_qs.all().delete()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15380", "model_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 6db1dcc..3005e7e 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -824,7 +824,7 @@ class MigrationAutodetector:\n         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):\n             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n             old_model_state = self.from_state.models[app_label, old_model_name]\n-            new_model_state = self.to_state.models[app_label, old_model_name]\n+            new_model_state = self.to_state.models[app_label, model_name]\n             field = new_model_state.get_field(field_name)\n             # Scan to see if this is actually a rename!\n             field_dec = self.deep_deconstruct(field)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16082", "model_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex c783b41..ab39ce7 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -650,11 +650,20 @@ class CombinedExpression(SQLiteNumericMixin, Expression):\n     def _resolve_output_field(self):\n         # We avoid using super() here for reasons given in\n         # Expression._resolve_output_field()\n-        combined_type = _resolve_combined_type(\n-            self.connector,\n-            type(self.lhs._output_field_or_none),\n-            type(self.rhs._output_field_or_none),\n-        )\n+        if self.connector == \"MOD\":\n+            # Special case for MOD operator to resolve to Decimal when combining Decimal and Integer\n+            lhs_type = type(self.lhs._output_field_or_none)\n+            rhs_type = type(self.rhs._output_field_or_none)\n+            if issubclass(lhs_type, DecimalField) or issubclass(rhs_type, DecimalField):\n+                combined_type = DecimalField\n+            else:\n+                combined_type = _resolve_combined_type(self.connector, lhs_type, rhs_type)\n+        else:\n+            combined_type = _resolve_combined_type(\n+                self.connector,\n+                type(self.lhs._output_field_or_none),\n+                type(self.rhs._output_field_or_none),\n+            )\n         if combined_type is None:\n             raise FieldError(\n                 f\"Cannot infer type of {self.connector!r} expression involving these \"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16485", "model_patch": "diff --git a/django/template/defaultfilters.py b/django/template/defaultfilters.py\nindex edd25c0..10a52b8 100644\n--- a/django/template/defaultfilters.py\n+++ b/django/template/defaultfilters.py\n@@ -183,7 +183,8 @@ def floatformat(text, arg=-1):\n     tupl = d.as_tuple()\n     units = len(tupl[1])\n     units += -tupl[2] if m else tupl[2]\n-    prec = abs(p) + units + 1\n+    # Ensure prec meets valid range for Decimal context (at least 1).\n+    prec = max(abs(p) + units + 1, 1)\n \n     # Avoid conversion to scientific notation by accessing `sign`, `digits`,\n     # and `exponent` from Decimal.as_tuple() directly.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16569", "model_patch": "diff --git a/django/forms/formsets.py b/django/forms/formsets.py\nindex d028801..d179ddf 100644\n--- a/django/forms/formsets.py\n+++ b/django/forms/formsets.py\n@@ -490,7 +490,7 @@ class BaseFormSet(RenderableFormMixin):\n                     required=False,\n                     widget=self.get_ordering_widget(),\n                 )\n-        if self.can_delete and (self.can_delete_extra or index < initial_form_count):\n+        if self.can_delete and (self.can_delete_extra or (index is not None and index < initial_form_count)):\n             form.fields[DELETION_FIELD_NAME] = BooleanField(\n                 label=_(\"Delete\"),\n                 required=False,\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15525", "model_patch": "diff --git a/django/core/serializers/base.py b/django/core/serializers/base.py\nindex e82a744..eff4d7b 100644\n--- a/django/core/serializers/base.py\n+++ b/django/core/serializers/base.py\n@@ -329,14 +329,16 @@ def build_instance(Model, data, db):\n     If the model instance doesn't have a primary key and the model supports\n     natural keys, try to retrieve it from the database.\n     \"\"\"\n-    default_manager = Model._meta.default_manager\n+    # Ensure the manager uses the correct database\n+    default_manager = Model._meta.default_manager.db_manager(db)\n     pk = data.get(Model._meta.pk.attname)\n     if (\n         pk is None\n         and hasattr(default_manager, \"get_by_natural_key\")\n         and hasattr(Model, \"natural_key\")\n     ):\n-        natural_key = Model(**data).natural_key()\n+        # Correctly initialize the model instance to generate natural keys\n+        natural_key = Model(**data, using=db).natural_key()\n         try:\n             data[Model._meta.pk.attname] = Model._meta.pk.to_python(\n                 default_manager.db_manager(db).get_by_natural_key(*natural_key).pk\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pallets__flask-5014", "model_patch": "diff --git a/src/flask/blueprints.py b/src/flask/blueprints.py\nindex 678f5f0..133ed97 100644\n--- a/src/flask/blueprints.py\n+++ b/src/flask/blueprints.py\n@@ -190,6 +190,8 @@ class Blueprint(Scaffold):\n             root_path=root_path,\n         )\n \n+        if not name:\n+            raise ValueError(\"'name' must not be empty.\")\n         if \".\" in name:\n             raise ValueError(\"'name' may not contain a dot '.' character.\")\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15957", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 5314293..194be31 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -438,6 +438,8 @@ class QuerySet:\n             else:\n                 stop = None\n             qs.query.set_limits(start, stop)\n+            # Mark the queryset to allow filtering in prefetch_related scenarios\n+            qs.query._allow_prefetch_after_slice = True\n             return list(qs)[:: k.step] if k.step else qs\n \n         qs = self._chain()\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 0bcddc7..2a16e3f 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -2095,7 +2095,8 @@ class Query(BaseExpression):\n \n         Typically, this means no limits or offsets have been put on the results.\n         \"\"\"\n-        return not self.is_sliced\n+        # Allow filtering for prefetch-related querysets even if sliced.\n+        return not self.is_sliced or getattr(self, '_allow_prefetch_after_slice', False)\n \n     def clear_select_clause(self):\n         \"\"\"Remove all fields from SELECT clause.\"\"\"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15741", "model_patch": "diff --git a/django/utils/formats.py b/django/utils/formats.py\nindex 82173e8..53bc251 100644\n--- a/django/utils/formats.py\n+++ b/django/utils/formats.py\n@@ -125,7 +125,7 @@ def get_format(format_type, lang=None, use_l10n=None):\n     val = None\n     if use_l10n:\n         for module in get_format_modules(lang):\n-            val = getattr(module, format_type, None)\n+            val = getattr(module, str(format_type), None)\n             if val is not None:\n                 break\n     if val is None:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16631", "model_patch": "diff --git a/django/core/signing.py b/django/core/signing.py\nindex 6cd40ee..2024dff 100644\n--- a/django/core/signing.py\n+++ b/django/core/signing.py\n@@ -222,8 +222,14 @@ class Signer:\n             )\n \n     def signature(self, value, key=None):\n-        key = key or self.key\n-        return base64_hmac(self.salt + \"signer\", value, key, algorithm=self.algorithm)\n+        keys = [key] if key else [self.key, *self.fallback_keys]\n+        for idx, current_key in enumerate(keys):\n+            try:\n+                return base64_hmac(self.salt + \"signer\", value, current_key, algorithm=self.algorithm)\n+            except Exception as e:\n+                # If fallback key fails, try the next key\n+                if idx == len(keys) - 1:\n+                    raise e\n \n     def sign(self, value):\n         return \"%s%s%s\" % (value, self.sep, self.signature(value))\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-26208", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "django__django-16642", "model_patch": "diff --git a/django/http/response.py b/django/http/response.py\nindex b918697..f1894c0 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -613,6 +613,11 @@ class FileResponse(StreamingHttpResponse):\n                     \"gzip\": \"application/gzip\",\n                     \"xz\": \"application/x-xz\",\n                 }.get(encoding, content_type)\n+                # Explicitly handle .br and .Z file extensions\n+                if filename.endswith(\".br\"):\n+                    content_type = \"application/x-brotli\"\n+                elif filename.endswith(\".Z\"):\n+                    content_type = \"application/x-compress\"\n                 self.headers[\"Content-Type\"] = (\n                     content_type or \"application/octet-stream\"\n                 )\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15930", "model_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 47df1a9..cee233b 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1385,7 +1385,11 @@ class Case(SQLiteNumericMixin, Expression):\n         sql_params = []\n         for case in self.cases:\n             try:\n-                case_sql, case_params = compiler.compile(case)\n+                # Ensure proper SQL compilation for negated conditions\n+                case_condition_sql, case_condition_params = compiler.compile(case.condition)\n+                case_result_sql, case_result_params = compiler.compile(case.result)\n+                case_sql = f\"WHEN {case_condition_sql} THEN {case_result_sql}\"\n+                case_params = case_condition_params + case_result_params\n             except EmptyResultSet:\n                 continue\n             case_parts.append(case_sql)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15987", "model_patch": "diff --git a/django/core/management/commands/loaddata.py b/django/core/management/commands/loaddata.py\nindex c98b0b6..a52a5af 100644\n--- a/django/core/management/commands/loaddata.py\n+++ b/django/core/management/commands/loaddata.py\n@@ -283,7 +283,7 @@ class Command(BaseCommand):\n         if os.path.isabs(fixture_name):\n             fixture_dirs = [dirname]\n         else:\n-            fixture_dirs = self.fixture_dirs\n+            fixture_dirs = [str(to_path(dir_)) for dir_ in self.fixture_dirs]\n             if os.path.sep in os.path.normpath(fixture_name):\n                 fixture_dirs = [os.path.join(dir_, dirname) for dir_ in fixture_dirs]\n         return basename, fixture_dirs\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15037", "model_patch": "diff --git a/django/db/backends/postgresql/introspection.py b/django/db/backends/postgresql/introspection.py\nindex bdb6b4c..187ac09 100644\n--- a/django/db/backends/postgresql/introspection.py\n+++ b/django/db/backends/postgresql/introspection.py\n@@ -129,12 +129,11 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n             FROM pg_constraint con\n             LEFT JOIN pg_class c1 ON con.conrelid = c1.oid\n             LEFT JOIN pg_class c2 ON con.confrelid = c2.oid\n-            LEFT JOIN pg_attribute a1 ON c1.oid = a1.attrelid AND a1.attnum = con.conkey[1]\n-            LEFT JOIN pg_attribute a2 ON c2.oid = a2.attrelid AND a2.attnum = con.confkey[1]\n+            LEFT JOIN pg_attribute a1 ON c1.oid = a1.attrelid AND a1.attnum = ANY(con.conkey)\n+            LEFT JOIN pg_attribute a2 ON c2.oid = a2.attrelid AND a2.attnum = ANY(con.confkey)\n             WHERE\n                 c1.relname = %s AND\n                 con.contype = 'f' AND\n-                c1.relnamespace = c2.relnamespace AND\n                 pg_catalog.pg_table_is_visible(c1.oid)\n         \"\"\", [table_name])\n         return cursor.fetchall()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-13346", "model_patch": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex a0dea96..f94462f 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -294,6 +294,9 @@ class KeyTransform(Transform):\n     def as_mysql(self, compiler, connection):\n         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n         json_path = compile_json_path(key_transforms)\n+        if self.lookup_name == 'in':\n+            # Generate SQL for `IN` lookups on JSON keys\n+            return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)\n         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)\n \n     def as_oracle(self, compiler, connection):\n@@ -317,6 +320,9 @@ class KeyTransform(Transform):\n     def as_sqlite(self, compiler, connection):\n         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n         json_path = compile_json_path(key_transforms)\n+        if self.lookup_name == 'in':\n+            # Generate SQL for `IN` lookups on JSON keys\n+            return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)\n         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)\n \n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15098", "model_patch": "diff --git a/django/conf/urls/i18n.py b/django/conf/urls/i18n.py\nindex 4745fd6..4c4e814 100644\n--- a/django/conf/urls/i18n.py\n+++ b/django/conf/urls/i18n.py\n@@ -1,3 +1,4 @@\n+\n import functools\n \n from django.conf import settings\n@@ -14,6 +15,7 @@ def i18n_patterns(*urls, prefix_default_language=True):\n         return list(urls)\n     return [\n         URLResolver(\n+            # Apply case-insensitive prefix matching for BCP 47 compatibility\n             LocalePrefixPattern(prefix_default_language=prefix_default_language),\n             list(urls),\n         )\ndiff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 6ccbc95..1437310 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -318,6 +318,8 @@ class LocalePrefixPattern:\n         if language_code == settings.LANGUAGE_CODE and not self.prefix_default_language:\n             return ''\n         else:\n+            # Normalize language codes to match BCP 47 standard (case-insensitive)\n+            language_code = language_code.lower()\n             return '%s/' % language_code\n \n     def match(self, path):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16493", "model_patch": "diff --git a/django/db/models/fields/files.py b/django/db/models/fields/files.py\nindex 53d7755..3f99d83 100644\n--- a/django/db/models/fields/files.py\n+++ b/django/db/models/fields/files.py\n@@ -295,7 +295,7 @@ class FileField(Field):\n         if kwargs.get(\"max_length\") == 100:\n             del kwargs[\"max_length\"]\n         kwargs[\"upload_to\"] = self.upload_to\n-        if self.storage is not default_storage:\n+        if getattr(self, \"_storage_callable\", None) or self.storage is not default_storage:\n             kwargs[\"storage\"] = getattr(self, \"_storage_callable\", self.storage)\n         return name, path, args, kwargs\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16032", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 5314293..f51545b 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1588,7 +1588,10 @@ class QuerySet:\n         Return a query set with added aliases for extra data or aggregations.\n         \"\"\"\n         self._not_support_combined_queries(\"alias\")\n-        return self._annotate(args, kwargs, select=False)\n+        clone = self._annotate(args, kwargs, select=False)\n+        # Clear annotations when aliasing to prevent inclusion in subqueries\n+        clone.query.annotation_select.clear()\n+        return clone\n \n     def _annotate(self, args, kwargs, select=True):\n         self._validate_values_are_expressions(\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 006c631..636a05b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -228,7 +228,9 @@ class SQLCompiler:\n             expressions = [\n                 expr\n                 for expr in expressions\n-                if expr in pks or getattr(expr, \"alias\", None) not in aliases\n+                if expr in pks or (\n+                    getattr(expr, \"alias\", None) not in aliases and not hasattr(expr, \"annotation\")\n+                )\n             ]\n         return expressions\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-7530", "model_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 1d76f25..1cf741a 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -222,7 +222,9 @@ class MigrationAutodetector(object):\n         \"\"\"\n         Through model map generation\n         \"\"\"\n-        for app_label, model_name in sorted(self.old_model_keys):\n+        for app_label, model_name in sorted(\n+            key for key in self.old_model_keys if key[0] == app_label\n+        ):\n             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n             old_model_state = self.from_state.models[app_label, old_model_name]\n             for field_name, field in old_model_state.fields:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16662", "model_patch": "diff --git a/django/db/migrations/writer.py b/django/db/migrations/writer.py\nindex bdf1f93..5d89e7b 100644\n--- a/django/db/migrations/writer.py\n+++ b/django/db/migrations/writer.py\n@@ -175,7 +175,17 @@ class MigrationWriter:\n \n         # Sort imports by the package / module to be imported (the part after\n         # \"from\" in \"from ... import ...\" or after \"import\" in \"import ...\").\n-        sorted_imports = sorted(imports, key=lambda i: i.split()[1])\n+        # Separate \"import module\" from \"from module import object\" statements\n+        import_statements = sorted(\n+            [imp for imp in imports if imp.startswith(\"import \")],\n+            key=lambda i: i.split()[1],\n+        )\n+        from_import_statements = sorted(\n+            [imp for imp in imports if imp.startswith(\"from \")],\n+            key=lambda i: i.split()[1],\n+        )\n+        # Combine them, ensuring \"import\" statements come first\n+        sorted_imports = \"\\n\".join(import_statements + from_import_statements)\n         items[\"imports\"] = \"\\n\".join(sorted_imports) + \"\\n\" if imports else \"\"\n         if migration_imports:\n             items[\"imports\"] += (\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20859", "model_patch": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex f63ebf0..dd62d0f 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -434,7 +434,7 @@ class Legend(Artist):\n             self.isaxes = True\n             self.axes = parent\n             self.set_figure(parent.figure)\n-        elif isinstance(parent, Figure):\n+        elif isinstance(parent, FigureBase):\n             self.isaxes = False\n             self.set_figure(parent)\n         else:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16454", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "django__django-16263", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ab02d72..de8299c 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -550,6 +550,12 @@ class Query(BaseExpression):\n         Perform a COUNT() query using the current filter constraints.\n         \"\"\"\n         obj = self.clone()\n+        # Remove unused annotations when performing a count query.\n+        obj.annotations = {\n+            alias: annotation\n+            for alias, annotation in obj.annotations.items()\n+            if alias in obj.annotation_select or alias in obj.annotation_group_by\n+        }\n         obj.add_annotation(Count(\"*\"), alias=\"__count\", is_summary=True)\n         return obj.get_aggregation(using, [\"__count\"])[\"__count\"]\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15563", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 33ea6ed..f15b287 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1853,7 +1853,13 @@ class SQLUpdateCompiler(SQLCompiler):\n             idents = []\n             for rows in query.get_compiler(self.using).execute_sql(MULTI):\n                 idents.extend(r[0] for r in rows)\n-            self.query.add_filter(\"pk__in\", idents)\n+            # Ensure updates target the correct model in multi-table inheritance\n+            concrete_model_ids = [\n+                ident\n+                for ident in idents\n+                if self.query.get_meta().model._meta.concrete_model.objects.filter(pk=ident).exists()\n+            ]\n+            self.query.add_filter(\"pk__in\", concrete_model_ids)\n             self.query.related_ids = idents\n         else:\n             # The fast path. Filters and updates in one query.\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 2c88fe4..dd1ed5c 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1692,7 +1692,12 @@ class Query(BaseExpression):\n             # field lives in parent, but we are currently in one of its\n             # children)\n             if opts is not None and model is not opts.model:\n-                path_to_parent = opts.get_path_to_parent(model)\n+                # Ensure the path resolves correctly for multi-table inheritance.\n+                if model._meta.proxy or model._meta.parents:\n+                    # Prioritize the concrete child model.\n+                    path_to_parent = opts.get_path_to_parent(model)\n+                else:\n+                    path_to_parent = opts.get_path_to_parent(model._meta.concrete_model)\n                 if path_to_parent:\n                     path.extend(path_to_parent)\n                     cur_names_with_path[1].extend(path_to_parent)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25122", "model_patch": "diff --git a/lib/matplotlib/mlab.py b/lib/matplotlib/mlab.py\nindex e9c7d39..2e2a34d 100644\n--- a/lib/matplotlib/mlab.py\n+++ b/lib/matplotlib/mlab.py\n@@ -424,7 +424,7 @@ def _spectral_helper(x, y=None, NFFT=None, Fs=None, detrend_func=None,\n             result /= Fs\n             # Scale the spectrum by the norm of the window to compensate for\n             # windowing loss; see Bendat & Piersol Sec 11.5.2.\n-            result /= (np.abs(window)**2).sum()\n+            result /= (window**2).sum()\n         else:\n             # In this case, preserve power in the segment, not amplitude\n             result /= np.abs(window).sum()**2\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15161", "model_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 626b8ab..89312e0 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -652,6 +652,11 @@ class OuterRef(F):\n \n \n class Func(SQLiteNumericMixin, Expression):\n+    def deconstruct(self):\n+        path = f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n+        if path.startswith(\"django.db.models.expressions.\"):\n+            path = f\"django.db.models.{self.__class__.__name__}\"\n+        return path, self._constructor_args, self.extra\n     \"\"\"An SQL function call.\"\"\"\n     function = None\n     template = '%(function)s(%(expressions)s)'\n@@ -732,6 +737,11 @@ class Func(SQLiteNumericMixin, Expression):\n \n \n class Value(SQLiteNumericMixin, Expression):\n+    def deconstruct(self):\n+        path = f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n+        if path.startswith(\"django.db.models.expressions.\"):\n+            path = f\"django.db.models.{self.__class__.__name__}\"\n+        return path, (self.value,), {'output_field': self._output_field_or_none}\n     \"\"\"Represent a wrapped value as a node within an expression.\"\"\"\n     # Provide a default value for `for_save` in order to allow unresolved\n     # instances to be compiled until a decision is taken in #25425.\n@@ -808,6 +818,11 @@ class Value(SQLiteNumericMixin, Expression):\n \n \n class RawSQL(Expression):\n+    def deconstruct(self):\n+        path = f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n+        if path.startswith(\"django.db.models.expressions.\"):\n+            path = f\"django.db.models.{self.__class__.__name__}\"\n+        return path, (self.sql, self.params), {'output_field': self._output_field_or_none}\n     def __init__(self, sql, params, output_field=None):\n         if output_field is None:\n             output_field = fields.Field()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16801", "model_patch": "diff --git a/django/db/models/fields/files.py b/django/db/models/fields/files.py\nindex 3d75101..0106f9b 100644\n--- a/django/db/models/fields/files.py\n+++ b/django/db/models/fields/files.py\n@@ -437,11 +437,10 @@ class ImageField(FileField):\n \n     def contribute_to_class(self, cls, name, **kwargs):\n         super().contribute_to_class(cls, name, **kwargs)\n-        # Attach update_dimension_fields so that dimension fields declared\n-        # after their corresponding image field don't stay cleared by\n-        # Model.__init__, see bug #11196.\n-        # Only run post-initialization dimension update on non-abstract models\n-        if not cls._meta.abstract:\n+        # Attach update_dimension_fields only if width_field or height_field\n+        # is defined, to avoid unnecessary overhead when they're not used.\n+        # Only run post-initialization dimension update on non-abstract models.\n+        if not cls._meta.abstract and (self.width_field or self.height_field):\n             signals.post_init.connect(self.update_dimension_fields, sender=cls)\n \n     def update_dimension_fields(self, instance, force=False, *args, **kwargs):\n@@ -507,4 +506,4 @@ class ImageField(FileField):\n                 \"form_class\": forms.ImageField,\n                 **kwargs,\n             }\n-        )\n+        )\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16667", "model_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex d370339..469c701 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -1156,7 +1156,22 @@ class SelectDateWidget(Widget):\n             input_format = get_format(\"DATE_INPUT_FORMATS\")[0]\n             input_format = formats.sanitize_strftime_format(input_format)\n             try:\n-                date_value = datetime.date(int(y), int(m), int(d))\n+                try:\n+                    year = int(y)\n+                    month = int(m)\n+                    day = int(d)\n+                    # Validate range for year, month, and day\n+                    if not (1 <= month <= 12):\n+                        raise ValueError(\"Month out of range\")\n+                    if not (1 <= day <= 31):  # Simplified validation; detailed checks depend on month/year\n+                        raise ValueError(\"Day out of range\")\n+                    # Limit year to reasonable bounds to prevent OverflowError\n+                    if not (datetime.MINYEAR <= year <= datetime.MAXYEAR):\n+                        raise OverflowError(\"Year out of range\")\n+                    date_value = datetime.date(year, month, day)\n+                except (ValueError, OverflowError):\n+                    # Return pseudo-ISO dates with zeros for any unselected or invalid values\n+                    return \"%s-%s-%s\" % (y or 0, m or 0, d or 0)\n             except ValueError:\n                 # Return pseudo-ISO dates with zeros for any unselected values,\n                 # e.g. '2017-0-23'.\n@@ -1168,4 +1183,4 @@ class SelectDateWidget(Widget):\n         return not any(\n             (\"{}_{}\".format(name, interval) in data)\n             for interval in (\"year\", \"month\", \"day\")\n-        )\n+        )\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15916", "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 646bf68..18a2c76 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -632,6 +632,8 @@ def modelform_factory(\n     Meta = type(\"Meta\", bases, attrs)\n     if formfield_callback:\n         Meta.formfield_callback = staticmethod(formfield_callback)\n+    elif hasattr(form.Meta, \"formfield_callback\"):\n+        Meta.formfield_callback = form.Meta.formfield_callback\n     # Give this new form class a reasonable name.\n     class_name = model.__name__ + \"Form\"\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "psf__requests-2931", "model_patch": "diff --git a/requests/utils.py b/requests/utils.py\nindex 7aa8a2f..0273db5 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -683,7 +683,7 @@ def get_auth_from_url(url):\n     return auth\n \n \n-def to_native_string(string, encoding='ascii'):\n+def to_native_string(string, encoding='utf-8'):\n     \"\"\"\n     Given a string object, regardless of type, returns a representation of that\n     string in the native string type, encoding and decoding where necessary.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-26342", "model_patch": "diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py\nindex 37c6dcb..7023783 100644\n--- a/lib/matplotlib/collections.py\n+++ b/lib/matplotlib/collections.py\n@@ -207,7 +207,8 @@ class Collection(artist.Artist, cm.ScalarMappable):\n         return self._paths\n \n     def set_paths(self, paths):\n-        raise NotImplementedError\n+        \"\"\"Set the paths for this collection.\"\"\"\n+        self._paths = paths\n \n     def get_transforms(self):\n         return self._transforms\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-17084", "model_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ac042d4..7ebe112 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -428,7 +428,7 @@ class BaseExpression:\n         return clone\n \n     def get_group_by_cols(self):\n-        if not self.contains_aggregate:\n+        if not self.contains_aggregate and not self.contains_over_clause:\n             return [self]\n         cols = []\n         for source in self.get_source_expressions():\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15382", "model_patch": "diff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex 7a540c9..6890cec 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -96,6 +96,9 @@ class WhereNode(tree.Node):\n                 if self.negated:\n                     return '', []\n                 else:\n+                    if self.negated:\n+                        # Negation of an empty node should always match everything.\n+                        return '', []\n                     raise EmptyResultSet\n             if full_needed == 0:\n                 if self.negated:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-17087", "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 941a5ed..b450ae6 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -168,6 +168,13 @@ class FunctionTypeSerializer(BaseSerializer):\n         ):\n             klass = self.value.__self__\n             module = klass.__module__\n+            # Check if the function belongs to a nested class and include its full path.\n+            qualname_parts = klass.__qualname__.split('.')\n+            if len(qualname_parts) > 1:\n+                nested_path = '.'.join(qualname_parts[:-1])  # Include parent class path.\n+                return \"%s.%s.%s.%s\" % (module, nested_path, klass.__name__, self.value.__name__), {\n+                    \"import %s\" % module\n+                }\n             return \"%s.%s.%s\" % (module, klass.__name__, self.value.__name__), {\n                 \"import %s\" % module\n             }\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-17029", "model_patch": "diff --git a/django/apps/registry.py b/django/apps/registry.py\nindex ca85962..61b5345 100644\n--- a/django/apps/registry.py\n+++ b/django/apps/registry.py\n@@ -376,6 +376,7 @@ class Apps:\n         # Call expire cache on each model. This will purge\n         # the relation tree and the fields cache.\n         self.get_models.cache_clear()\n+        self.get_swappable_settings_name.cache_clear()\n         if self.ready:\n             # Circumvent self.get_models() to prevent that the cache is refilled.\n             # This particularly prevents that an empty value is cached while cloning.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23412", "model_patch": "diff --git a/lib/matplotlib/patches.py b/lib/matplotlib/patches.py\nindex 1eefb1e..da448be 100644\n--- a/lib/matplotlib/patches.py\n+++ b/lib/matplotlib/patches.py\n@@ -586,9 +586,9 @@ class Patch(artist.Artist):\n         # docstring inherited\n         if not self.get_visible():\n             return\n-        # Patch has traditionally ignored the dashoffset.\n+        # Respect the dash offset specified in the dash pattern.\n         with cbook._setattr_cm(\n-                 self, _dash_pattern=(0, self._dash_pattern[1])), \\\n+                 self, _dash_pattern=self._dash_pattern), \\\n              self._bind_draw_path_function(renderer) as draw_path:\n             path = self.get_path()\n             transform = self.get_transform()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3187", "model_patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 609c102..7e890d7 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -648,6 +648,10 @@ class Continuous(ContinuousBase):\n \n         else:\n             formatter = ScalarFormatter()\n+            if hasattr(formatter, 'get_offset'):\n+                offset = formatter.get_offset()\n+                if offset:\n+                    formatter.set_offset_string(f\" (+{offset})\")\n \n         return formatter\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "psf__requests-5414", "model_patch": "diff --git a/requests/models.py b/requests/models.py\nindex b6afac6..1456f7c 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -354,7 +354,7 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         try:\n             host = idna.encode(host, uts46=True).decode('utf-8')\n         except idna.IDNAError:\n-            raise UnicodeError\n+            raise InvalidURL('URL has an invalid label.')\n         return host\n \n     def prepare_url(self, url, params):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "psf__requests-1766", "model_patch": "diff --git a/requests/auth.py b/requests/auth.py\nindex ff8249e..7248f53 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -144,7 +144,7 @@ class HTTPDigestAuth(AuthBase):\n         if entdig:\n             base += ', digest=\"%s\"' % entdig\n         if qop:\n-            base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+            base += ', qop=\"auth\", nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n \n         return 'Digest %s' % (base)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16899", "model_patch": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex b568a3a..a1c89b9 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -771,10 +771,11 @@ class BaseModelAdminChecks:\n             except FieldDoesNotExist:\n                 return [\n                     checks.Error(\n-                        \"The value of '%s' is not a callable, an attribute of \"\n+                        \"The value of '%s' (field name: '%s') is not a callable, an attribute of \"\n                         \"'%s', or an attribute of '%s'.\"\n                         % (\n                             label,\n+                            field_name,\n                             obj.__class__.__name__,\n                             obj.model._meta.label,\n                         ),\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23299", "model_patch": "diff --git a/lib/matplotlib/_pylab_helpers.py b/lib/matplotlib/_pylab_helpers.py\nindex 3123d3a..685bb6a 100644\n--- a/lib/matplotlib/_pylab_helpers.py\n+++ b/lib/matplotlib/_pylab_helpers.py\n@@ -64,7 +64,12 @@ class Gcf:\n                 return\n         if hasattr(manager, \"_cidgcf\"):\n             manager.canvas.mpl_disconnect(manager._cidgcf)\n-        manager.destroy()\n+        try:\n+            manager.destroy()\n+        except RuntimeError:\n+            # Backend or rc_context changes may lead to issues during figure destruction.\n+            # Ensure Gcf.figs remain intact.\n+            pass\n         del manager, num\n         # Full cyclic garbage collection may be too expensive to do on every\n         # figure destruction, so we collect only the youngest two generations.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16819", "model_patch": "diff --git a/django/db/migrations/operations/base.py b/django/db/migrations/operations/base.py\nindex d8e72ed..345c1b1 100644\n--- a/django/db/migrations/operations/base.py\n+++ b/django/db/migrations/operations/base.py\n@@ -132,7 +132,13 @@ class Operation:\n         replaced with or a boolean that indicates whether or not the specified\n         operation can be optimized across.\n         \"\"\"\n-        if self.elidable:\n+        if isinstance(self, AddIndex) and isinstance(operation, RemoveIndex):\n+            if self.name == operation.name:  # Match indexes by name\n+                return []\n+        elif isinstance(self, RemoveIndex) and isinstance(operation, AddIndex):\n+            if self.name == operation.name:  # Match indexes by name\n+                return [operation]  # Replace RemoveIndex with AddIndex\n+        elif self.elidable:\n             return [operation]\n         elif operation.elidable:\n             return [self]\n@@ -143,4 +149,4 @@ class Operation:\n             self.__class__.__name__,\n             \", \".join(map(repr, self._constructor_args[0])),\n             \",\".join(\" %s=%r\" % x for x in self._constructor_args[1].items()),\n-        )\n+        )\ndiff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py\nindex a9ec258..609c7a4 100644\n--- a/django/db/migrations/optimizer.py\n+++ b/django/db/migrations/optimizer.py\n@@ -64,6 +64,13 @@ class MigrationOptimizer:\n                 elif not result:\n                     # Can't perform a right reduction.\n                     right = False\n+                    # Special handling for AddIndex/RemoveIndex operations\n+                    if isinstance(operation, AddIndex) and isinstance(other, RemoveIndex):\n+                        if operation.name == other.name:\n+                            continue  # Skip this pair since it cancels out\n+                    elif isinstance(operation, RemoveIndex) and isinstance(other, AddIndex):\n+                        if operation.name == other.name:\n+                            continue  # Skip this pair since it cancels out\n             else:\n                 new_operations.append(operation)\n-        return new_operations\n+        return new_operations\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16595", "model_patch": "diff --git a/django/db/migrations/operations/fields.py b/django/db/migrations/operations/fields.py\nindex d35a2ee..ec566af 100644\n--- a/django/db/migrations/operations/fields.py\n+++ b/django/db/migrations/operations/fields.py\n@@ -264,6 +264,8 @@ class AlterField(FieldOperation):\n                     field=self.field,\n                 ),\n             ]\n+        elif isinstance(operation, AlterField) and self.is_same_field_operation(operation):\n+            return [operation]\n         return super().reduce(operation, app_label)\n \n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23314", "model_patch": "diff --git a/lib/mpl_toolkits/mplot3d/axes3d.py b/lib/mpl_toolkits/mplot3d/axes3d.py\nindex 392f89b..1db56c2 100644\n--- a/lib/mpl_toolkits/mplot3d/axes3d.py\n+++ b/lib/mpl_toolkits/mplot3d/axes3d.py\n@@ -387,6 +387,9 @@ class Axes3D(Axes):\n \n     @martist.allow_rasterization\n     def draw(self, renderer):\n+        if not self.get_visible():\n+            return\n+\n         self._unstale_viewLim()\n \n         # draw the background patch\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-14623", "model_patch": "diff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex bf0245b..772e983 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -425,8 +425,9 @@ class LogScale(ScaleBase):\n             minpos = 1e-300  # This value should rarely if ever\n                              # end up with a visible effect.\n \n-        return (minpos if vmin <= 0 else vmin,\n-                minpos if vmax <= 0 else vmax)\n+        vmin = minpos if vmin <= 0 else vmin\n+        vmax = minpos if vmax <= 0 else vmax\n+        return (vmin, vmax) if vmin < vmax else (vmax, vmin)\n \n \n class FuncScaleLog(LogScale):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-9296", "model_patch": "diff --git a/django/core/paginator.py b/django/core/paginator.py\nindex 30a29ab..36dc162 100644\n--- a/django/core/paginator.py\n+++ b/django/core/paginator.py\n@@ -73,6 +73,10 @@ class Paginator:\n             top = self.count\n         return self._get_page(self.object_list[bottom:top], number, self)\n \n+    def __iter__(self):\n+        for page_num in self.page_range:\n+            yield self.page(page_num)\n+\n     def _get_page(self, *args, **kwargs):\n         \"\"\"\n         Return an instance of a single page.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15554", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex b69bf1f..420b48c 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1598,7 +1598,9 @@ class Query(BaseExpression):\n                         \"relations deeper than the relation_name (got %r for \"\n                         \"%r).\" % (lookup, filtered_relation.relation_name)\n                     )\n-        self._filtered_relations[filtered_relation.alias] = filtered_relation\n+        if filtered_relation.alias not in self._filtered_relations:\n+            self._filtered_relations[filtered_relation.alias] = []\n+        self._filtered_relations[filtered_relation.alias].append(filtered_relation)\n \n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4075", "model_patch": "diff --git a/xarray/core/weighted.py b/xarray/core/weighted.py\nindex 8119fa7..eb44dfe 100644\n--- a/xarray/core/weighted.py\n+++ b/xarray/core/weighted.py\n@@ -142,7 +142,7 @@ class Weighted:\n         # we need to mask data values that are nan; else the weights are wrong\n         mask = da.notnull()\n \n-        sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)\n+        sum_of_weights = self._reduce(mask, self.weights * 1.0, dim=dim, skipna=False)\n \n         # 0-weights are not valid\n         valid_weights = sum_of_weights != 0.0\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16877", "model_patch": "diff --git a/django/template/defaultfilters.py b/django/template/defaultfilters.py\nindex 693c70d..cd469e5 100644\n--- a/django/template/defaultfilters.py\n+++ b/django/template/defaultfilters.py\n@@ -497,6 +497,15 @@ def safeseq(value):\n     \"\"\"\n     return [mark_safe(obj) for obj in value]\n \n+@register.filter(is_safe=True)\n+def escapeseq(value):\n+    \"\"\"\n+    An \"escape\" filter for sequences. Escape each element in the sequence,\n+    individually, after converting them to strings. Return a list with \n+    the results.\n+    \"\"\"\n+    return [escape(obj) for obj in value]\n+\n \n @register.filter(is_safe=True)\n @stringfilter\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "psf__requests-1724", "model_patch": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex e1a79e6..955167a 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -311,7 +311,7 @@ class Session(SessionRedirectMixin):\n         \"\"\"\n         # Create the Request.\n         req = Request(\n-            method = method.upper(),\n+            method = str(method).upper(),\n             url = url,\n             headers = headers,\n             files = files,\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5840", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "psf__requests-2317", "model_patch": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 76c9998..56bd6cd 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -425,7 +425,10 @@ class Session(SessionRedirectMixin):\n             If Tuple, ('cert', 'key') pair.\n         \"\"\"\n \n-        method = builtin_str(method)\n+        if isinstance(method, bytes):\n+            method = method.decode('ascii')\n+        else:\n+            method = builtin_str(method)\n \n         # Create the Request.\n         req = Request(\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-21568", "model_patch": "diff --git a/lib/matplotlib/dates.py b/lib/matplotlib/dates.py\nindex f565bc8..8ac0822 100644\n--- a/lib/matplotlib/dates.py\n+++ b/lib/matplotlib/dates.py\n@@ -592,11 +592,15 @@ def drange(dstart, dend, delta):\n \n \n def _wrap_in_tex(text):\n-    p = r'([a-zA-Z]+)'\n+    p = r'([a-zA-Z]+|\\d+)'\n     ret_text = re.sub(p, r'}$\\1$\\\\mathdefault{', text)\n \n-    # Braces ensure dashes are not spaced like binary operators.\n-    ret_text = '$\\\\mathdefault{'+ret_text.replace('-', '{-}')+'}$'\n+    # Braces ensure dashes and colons are not spaced like binary operators.\n+    replacements = {'-': '{-}', ':': '{:}'}\n+    for old, new in replacements.items():\n+        ret_text = ret_text.replace(old, new)\n+        \n+    ret_text = '$\\\\mathdefault{' + ret_text + '}$'\n     ret_text = ret_text.replace('$\\\\mathdefault{}$', '')\n     return ret_text\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-13989", "model_patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 6b68737..57efec6 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6686,7 +6686,7 @@ optional.\n \n         density = bool(density) or bool(normed)\n         if density and not stacked:\n-            hist_kwargs = dict(density=density)\n+            hist_kwargs = dict(density=density, range=bin_range)\n \n         # List to store all the top coordinates of the histograms\n         tops = []\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "psf__requests-1921", "model_patch": "diff --git a/requests/structures.py b/requests/structures.py\nindex 37202b8..ebf57a1 100644\n--- a/requests/structures.py\n+++ b/requests/structures.py\n@@ -71,7 +71,10 @@ class CaseInsensitiveDict(collections.MutableMapping):\n     def __setitem__(self, key, value):\n         # Use the lowercased key for lookups, but store the actual\n         # key alongside the value.\n-        self._store[key.lower()] = (key, value)\n+        if value is None:\n+            self.__delitem__(key)\n+        else:\n+            self._store[key.lower()] = (key, value)\n \n     def __getitem__(self, key):\n         return self._store[key.lower()][1]\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16315", "model_patch": "diff --git a/django/db/backends/postgresql/operations.py b/django/db/backends/postgresql/operations.py\nindex 7b1b714..ca4fa2b 100644\n--- a/django/db/backends/postgresql/operations.py\n+++ b/django/db/backends/postgresql/operations.py\n@@ -353,18 +353,22 @@ class DatabaseOperations(BaseDatabaseOperations):\n         if on_conflict == OnConflict.IGNORE:\n             return \"ON CONFLICT DO NOTHING\"\n         if on_conflict == OnConflict.UPDATE:\n+            opts = fields[0].model._meta\n+            unique_columns = [\n+                self.quote_name(opts.get_field(field).db_column or field)\n+                for field in unique_fields\n+            ]\n+            update_columns = [\n+                f\"{self.quote_name(opts.get_field(field).db_column or field)} = EXCLUDED.{self.quote_name(opts.get_field(field).db_column or field)}\"\n+                for field in update_fields\n+            ]\n             return \"ON CONFLICT(%s) DO UPDATE SET %s\" % (\n-                \", \".join(map(self.quote_name, unique_fields)),\n-                \", \".join(\n-                    [\n-                        f\"{field} = EXCLUDED.{field}\"\n-                        for field in map(self.quote_name, update_fields)\n-                    ]\n-                ),\n+                \", \".join(unique_columns),\n+                \", \".join(update_columns),\n             )\n         return super().on_conflict_suffix_sql(\n             fields,\n             on_conflict,\n             update_fields,\n             unique_fields,\n-        )\n+        )\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25960", "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex eeb18de..d9d65f8 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -1582,10 +1582,12 @@ default: %(va)s\n             If not given, all rows will have the same height.\n         \"\"\"\n         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self,\n-                      wspace=wspace, hspace=hspace,\n                       width_ratios=width_ratios,\n                       height_ratios=height_ratios)\n \n+        if wspace is not None or hspace is not None:\n+            self.subplots_adjust(wspace=wspace, hspace=hspace)\n+\n         sfarr = np.empty((nrows, ncols), dtype=object)\n         for i in range(ncols):\n             for j in range(nrows):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16100", "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 32995ac..604dc33 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1911,6 +1911,7 @@ class ModelAdmin(BaseModelAdmin):\n         return queryset.filter(pk__in=object_pks)\n \n     @csrf_protect_m\n+    @transaction.atomic\n     def changelist_view(self, request, extra_context=None):\n         \"\"\"\n         The 'change list' admin view for this model.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-22865", "model_patch": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex 5ebeaf9..815a0de 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -1270,6 +1270,13 @@ class Colorbar:\n         yunique = self._y\n \n         z = np.interp(xn, bunique, yunique)\n+        \n+        # Ensure edges are drawn for extended regions\n+        if self.extend in ['both', 'min']:\n+            z[x < bunique[0]] = self._y[0]\n+        if self.extend in ['both', 'max']:\n+            z[x > bunique[-1]] = self._y[-1]\n+            \n         return z\n \n     # trivial helpers\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24570", "model_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex a767323..752306d 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -166,10 +166,10 @@ def _get_aligned_offsets(hd_list, height, align=\"baseline\"):\n         descent = max(d for h, d in hd_list)\n         height = height_descent + descent\n         offsets = [0. for h, d in hd_list]\n-    elif align in [\"left\", \"top\"]:\n+    elif align in [\"left\", \"bottom\"]:\n         descent = 0.\n         offsets = [d for h, d in hd_list]\n-    elif align in [\"right\", \"bottom\"]:\n+    elif align in [\"right\", \"top\"]:\n         descent = 0.\n         offsets = [height - h + d for h, d in hd_list]\n     elif align == \"center\":\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pylint-dev__pylint-6903", "model_patch": "diff --git a/pylint/lint/run.py b/pylint/lint/run.py\nindex aabf0aa..e29581f 100644\n--- a/pylint/lint/run.py\n+++ b/pylint/lint/run.py\n@@ -52,12 +52,12 @@ def _query_cpu() -> int | None:\n         with open(\"/sys/fs/cgroup/cpu/cpu.cfs_period_us\", encoding=\"utf-8\") as file:\n             cpu_period = int(file.read().rstrip())\n         # Divide quota by period and you should get num of allotted CPU to the container, rounded down if fractional.\n-        avail_cpu = int(cpu_quota / cpu_period)\n+        avail_cpu = max(1, int(cpu_quota / cpu_period))\n     elif Path(\"/sys/fs/cgroup/cpu/cpu.shares\").is_file():\n         with open(\"/sys/fs/cgroup/cpu/cpu.shares\", encoding=\"utf-8\") as file:\n             cpu_shares = int(file.read().rstrip())\n         # For AWS, gives correct value * 1024.\n-        avail_cpu = int(cpu_shares / 1024)\n+        avail_cpu = max(1, int(cpu_shares / 1024))\n     return avail_cpu\n \n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15732", "model_patch": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 42e02c2..435cb03 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -1081,6 +1081,12 @@ class RemoveConstraint(IndexOperation):\n         if self.allow_migrate_model(schema_editor.connection.alias, model):\n             from_model_state = from_state.models[app_label, self.model_name_lower]\n             constraint = from_model_state.get_constraint_by_name(self.name)\n+            if constraint.primary_key:\n+                raise ValueError(\n+                    f\"Cannot remove primary key constraint '{self.name}' on model \"\n+                    f\"'{app_label}.{self.model_name}'. Primary key constraints are \"\n+                    f\"intrinsic to the model and cannot be dropped.\"\n+                )\n             schema_editor.remove_constraint(model, constraint)\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-3305", "model_patch": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex baab678..ad4857d 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -2822,7 +2822,10 @@ class DataArray(AbstractArray, DataWithCoords):\n           * time     (time) datetime64[ns] 2000-01-03 2000-01-04 2000-01-05 ...\n         \"\"\"\n         ds = self._to_temp_dataset().sortby(variables, ascending=ascending)\n-        return self._from_temp_dataset(ds)\n+        result = self._from_temp_dataset(ds)\n+        if keep_attrs:\n+            result.attrs = self.attrs\n+        return result\n \n     def quantile(\n         self,\n@@ -2875,7 +2878,10 @@ class DataArray(AbstractArray, DataWithCoords):\n         ds = self._to_temp_dataset().quantile(\n             q, dim=dim, keep_attrs=keep_attrs, interpolation=interpolation\n         )\n-        return self._from_temp_dataset(ds)\n+        result = self._from_temp_dataset(ds)\n+        if keep_attrs:\n+            result.attrs = self.attrs\n+        return result\n \n     def rank(\n         self, dim: Hashable, pct: bool = False, keep_attrs: bool = None\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20676", "model_patch": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex a6bed3c..1e13745 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -2321,7 +2321,7 @@ class SpanSelector(_SelectorWidget):\n     def extents(self):\n         \"\"\"Return extents of the span selector.\"\"\"\n         if self.direction == 'horizontal':\n-            vmin = self._rect.get_x()\n+            vmin = max(self._rect.get_x(), self.ax.get_xlim()[0])\n             vmax = vmin + self._rect.get_width()\n         else:\n             vmin = self._rect.get_y()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-26291", "model_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 8110df0..1c6944e 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -395,7 +395,11 @@ class OffsetBox(martist.Artist):\n     def get_window_extent(self, renderer=None):\n         # docstring inherited\n         if renderer is None:\n-            renderer = self.figure._get_renderer()\n+            if self.figure is not None:\n+                renderer = self.figure._get_renderer()\n+            else:\n+                from matplotlib.backend_bases import _get_renderer\n+                renderer = _get_renderer(self.axes.figure)\n         bbox = self.get_bbox(renderer)\n         try:  # Some subclasses redefine get_offset to take no args.\n             px, py = self.get_offset(bbox, renderer)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16901", "model_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ac042d4..6b39d93 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -685,7 +685,11 @@ class CombinedExpression(SQLiteNumericMixin, Expression):\n         expression_params.extend(params)\n         # order of precedence\n         expression_wrapper = \"(%s)\"\n-        sql = connection.ops.combine_expression(self.connector, expressions)\n+        if self.connector == '^' and len(expressions) > 2 and not connection.features.supports_native_xor:\n+            # Generate SQL for XOR fallback: true if an odd number of arguments are true\n+            sql = \" MOD(%s, 2) = 1\" % \" + \".join(f\"CAST({expr} AS INTEGER)\" for expr in expressions)\n+        else:\n+            sql = connection.ops.combine_expression(self.connector, expressions)\n         return expression_wrapper % sql, expression_params\n \n     def resolve_expression(\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3069", "model_patch": "diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 5b43615..2e8bc9e 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -1638,12 +1638,17 @@ class Plotter:\n                     a, b = p._limits[axis_key]\n                     lo = a if a is None else convert_units(a)\n                     hi = b if b is None else convert_units(b)\n-                    if isinstance(a, str):\n+                    # Adjust limits for Nominal scales (similar to categorical behavior)\n+                    nominal_adjustment = axis_key in p._scales and isinstance(p._scales[axis_key], Nominal)\n+                    if isinstance(a, str) or nominal_adjustment:\n                         lo = cast(float, lo) - 0.5\n-                    if isinstance(b, str):\n+                    if isinstance(b, str) or nominal_adjustment:\n                         hi = cast(float, hi) + 0.5\n+                    # Invert axis for Nominal scales on the y-axis\n+                    if nominal_adjustment and axis == \"y\":\n+                        ax.invert_yaxis()\n                     ax.set(**{f\"{axis}lim\": (lo, hi)})\n \n         engine_default = None if p._target is not None else \"tight\"\n         layout_engine = p._layout_spec.get(\"engine\", engine_default)\n-        set_layout_engine(self._figure, layout_engine)\n+        set_layout_engine(self._figure, layout_engine)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25479", "model_patch": "diff --git a/lib/matplotlib/cm.py b/lib/matplotlib/cm.py\nindex 79762f1..2e96ebd 100644\n--- a/lib/matplotlib/cm.py\n+++ b/lib/matplotlib/cm.py\n@@ -127,7 +127,10 @@ class ColormapRegistry(Mapping):\n         \"\"\"\n         _api.check_isinstance(colors.Colormap, cmap=cmap)\n \n-        name = name or cmap.name\n+        if name:\n+            cmap.name = name\n+        else:\n+            name = cmap.name\n         if name in self:\n             if not force:\n                 # don't allow registering an already existing cmap\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25311", "model_patch": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex a038473..943b6b7 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -1208,6 +1208,17 @@ class Legend(Artist):\n         \"\"\"Return ``True`` if the legend is draggable, ``False`` otherwise.\"\"\"\n         return self._draggable is not None\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Exclude the unpicklable _draggable attribute for pickling\n+        state['_draggable'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Reset _draggable to None during unpickling\n+        self._draggable = None\n+\n \n # Helper functions to parse legend arguments for both `figure.legend` and\n # `axes.legend`:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16661", "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 20a301b..165b1e9 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -461,6 +461,14 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n                 # Lookups on nonexistent fields are ok, since they're ignored\n                 # later.\n                 break\n+            # Skip checking parent links if the field is a foreign key and the primary key.\n+            if (\n+                prev_field\n+                and prev_field.is_relation\n+                and prev_field.many_to_one\n+                and prev_field.primary_key\n+            ):\n+                model = field.related_model\n             # It is allowed to filter on values that would be found from local\n             # model anyways. For example, if you filter on employee__department__id,\n             # then the id value would be found already from employee__department_id.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23476", "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex cd28277..9b102cc 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3044,6 +3044,8 @@ class Figure(FigureBase):\n         self.__dict__ = state\n \n         # re-initialise some of the unstored state information\n+        # Avoid reapplying DPI scaling during unpickling. Use original DPI.\n+        self._set_dpi(self._original_dpi, forward=False)\n         FigureCanvasBase(self)  # Set self.canvas.\n \n         if restore_to_pylab:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24637", "model_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex e7f0196..042fdf2 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1457,8 +1457,10 @@ or callable, default: value of *xycoords*\n             if self.arrow_patch.figure is None and self.figure is not None:\n                 self.arrow_patch.figure = self.figure\n             self.arrow_patch.draw(renderer)\n+        renderer.open_group('annotationbbox', gid=self.get_gid())\n         self.patch.draw(renderer)\n         self.offsetbox.draw(renderer)\n+        renderer.close_group('annotationbbox')\n         self.stale = False\n \n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16938", "model_patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 4465765..38709e3 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -343,6 +343,7 @@ def select_related_descend(field, restricted, requested, select_mask, reverse=Fa\n         and select_mask\n         and field.name in requested\n         and field not in select_mask\n+        and not (select_mask and requested.get(field.name) is True)\n     ):\n         raise FieldError(\n             f\"Field {field.model._meta.object_name}.{field.name} cannot be both \"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "psf__requests-6028", "model_patch": "diff --git a/requests/adapters.py b/requests/adapters.py\nindex d47134b..5499e09 100644\n--- a/requests/adapters.py\n+++ b/requests/adapters.py\n@@ -190,7 +190,10 @@ class HTTPAdapter(BaseAdapter):\n                 **proxy_kwargs\n             )\n         else:\n+            username, password = get_auth_from_url(proxy)\n             proxy_headers = self.proxy_headers(proxy)\n+            if username and password:\n+                proxy_headers[\"Proxy-Authorization\"] = _basic_auth_str(username, password)\n             manager = self.proxy_manager[proxy] = proxy_from_url(\n                 proxy,\n                 proxy_headers=proxy_headers,\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "psf__requests-1142", "model_patch": "diff --git a/requests/models.py b/requests/models.py\nindex 0d4482a..f259d64 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -386,13 +386,15 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         self.body = body\n \n     def prepare_content_length(self, body):\n-        self.headers['Content-Length'] = '0'\n-        if hasattr(body, 'seek') and hasattr(body, 'tell'):\n-            body.seek(0, 2)\n-            self.headers['Content-Length'] = str(body.tell())\n-            body.seek(0, 0)\n-        elif body is not None:\n-            self.headers['Content-Length'] = str(len(body))\n+        # Do not set 'Content-Length' for methods like GET that do not have a body.\n+        if self.method not in ('GET', 'HEAD'):\n+            self.headers['Content-Length'] = '0'\n+            if hasattr(body, 'seek') and hasattr(body, 'tell'):\n+                body.seek(0, 2)\n+                self.headers['Content-Length'] = str(body.tell())\n+                body.seek(0, 0)\n+            elif body is not None:\n+                self.headers['Content-Length'] = str(len(body))\n \n     def prepare_auth(self, auth):\n         \"\"\"Prepares the given HTTP auth data.\"\"\"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-26113", "model_patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 0510462..5273775 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -5014,7 +5014,7 @@ default: :rc:`scatter.edgecolors`\n             if mincnt is None:\n                 mincnt = 0\n             accum = np.array(\n-                [reduce_C_function(acc) if len(acc) > mincnt else np.nan\n+                [reduce_C_function(acc) if len(acc) >= mincnt else np.nan\n                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]\n                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.\n                 float)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25287", "model_patch": "diff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex 40bf7c6..7a90bea 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -969,7 +969,9 @@ class Axis(martist.Artist):\n                     self._major_tick_kw.get('label1On', False)\n                     or self._major_tick_kw.get('label2On', False))\n             if 'labelcolor' in kwtrans:\n-                self.offsetText.set_color(kwtrans['labelcolor'])\n+                self.offsetText.set_color(\n+                    kwtrans['labelcolor'] if kwtrans['labelcolor'] != 'inherit' else self._major_tick_kw.get('color', 'black')\n+                )\n \n         self.stale = True\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pylint-dev__pylint-6528", "model_patch": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 94af730..aea9564 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -128,9 +128,11 @@ def expand_modules(\n             ):\n                 if filepath == subfilepath:\n                     continue\n-                if _is_in_ignore_list_re(\n-                    os.path.basename(subfilepath), ignore_list_re\n-                ) or _is_in_ignore_list_re(subfilepath, ignore_list_paths_re):\n+                if (\n+                    os.path.basename(subfilepath) in ignore_list\n+                    or _is_in_ignore_list_re(os.path.basename(subfilepath), ignore_list_re)\n+                    or _is_in_ignore_list_re(subfilepath, ignore_list_paths_re)\n+                ):\n                     continue\n \n                 modpath = _modpath_from_file(\n@@ -146,4 +148,4 @@ def expand_modules(\n                         \"basename\": modname,\n                     }\n                 )\n-    return result, errors\n+    return result, errors\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-7205", "model_patch": "diff --git a/src/_pytest/setuponly.py b/src/_pytest/setuponly.py\nindex 7d5414b..3243695 100644\n--- a/src/_pytest/setuponly.py\n+++ b/src/_pytest/setuponly.py\n@@ -66,7 +66,8 @@ def _show_fixture_action(fixturedef, msg):\n             tw.write(\" (fixtures used: {})\".format(\", \".join(deps)))\n \n     if hasattr(fixturedef, \"cached_param\"):\n-        tw.write(\"[{}]\".format(fixturedef.cached_param))\n+        from _pytest._io.saferepr import saferepr\n+        tw.write(\"[{}]\".format(saferepr(fixturedef.cached_param)))\n \n     tw.flush()\n \n@@ -77,4 +78,4 @@ def _show_fixture_action(fixturedef, msg):\n @pytest.hookimpl(tryfirst=True)\n def pytest_cmdline_main(config):\n     if config.option.setuponly:\n-        config.option.setupshow = True\n+        config.option.setupshow = True\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pylint-dev__pylint-8898", "model_patch": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 58062ab..3d079f8 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -112,10 +112,11 @@ def _regex_transformer(value: str) -> Pattern[str]:\n \n \n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n-    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    \"\"\"Transforms a semicolon-separated list of regular expressions.\"\"\"\n+    # Change the delimiter from ',' to ';' to avoid mangling regular expressions with commas\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n-        patterns.append(_regex_transformer(pattern))\n+    for pattern in value.split(\";\"):  # Use semicolon as a delimiter\n+        patterns.append(_regex_transformer(pattern.strip()))\n     return patterns\n \n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16950", "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex f9e6a6e..35dfcd0 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1283,6 +1283,10 @@ class ModelAdmin(BaseModelAdmin):\n         already been called.\n         \"\"\"\n         form.save_m2m()\n+        # Ensure the parent instance is saved before saving related inlines\n+        if form.instance._state.adding:\n+            form.instance.save()\n+\n         for formset in formsets:\n             self.save_formset(request, form, formset, change=change)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pylint-dev__pylint-4551", "model_patch": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex 0111bb1..6e5525a 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -91,8 +91,18 @@ class ClassDiagram(Figure, FilterMixIn):\n         ):\n             if not self.show_attr(node_name):\n                 continue\n+            # Check for type hints\n+            type_hint = None\n+            for assoc_node in associated_nodes:\n+                if hasattr(assoc_node, 'parent') and hasattr(assoc_node.parent, 'args'):\n+                    for arg in assoc_node.parent.args.args:\n+                        if arg.name == node_name and hasattr(arg, 'annotation'):\n+                            type_hint = arg.annotation.as_string()\n+                            break\n             names = self.class_names(associated_nodes)\n-            if names:\n+            if type_hint:\n+                node_name = \"{} : {}\".format(node_name, type_hint)\n+            elif names:\n                 node_name = \"{} : {}\".format(node_name, \", \".join(names))\n             attrs.append(node_name)\n         return sorted(attrs)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24870", "model_patch": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 908a24f..0ef7b90 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -1131,7 +1131,11 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n         if isinstance(levels_arg, Integral):\n             self.levels = self._autolev(levels_arg)\n         else:\n-            self.levels = np.asarray(levels_arg, np.float64)\n+            # Auto-detect boolean arrays and set default levels to [0.5].\n+            if np.issubdtype(self.z.dtype, np.bool_):\n+                self.levels = np.array([0.5], dtype=np.float64)\n+            else:\n+                self.levels = np.asarray(levels_arg, np.float64)\n \n         if not self.filled:\n             inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pylint-dev__pylint-7080", "model_patch": "diff --git a/pylint/lint/pylinter.py b/pylint/lint/pylinter.py\nindex 440e6fe..d4170a7 100644\n--- a/pylint/lint/pylinter.py\n+++ b/pylint/lint/pylinter.py\n@@ -598,11 +598,12 @@ class PyLinter(\n                         continue\n \n                     if _is_ignored_file(\n-                        root,\n-                        self.config.ignore,\n-                        self.config.ignore_patterns,\n-                        self.config.ignore_paths,\n+                        element=root,\n+                        ignore_list=self.config.ignore,\n+                        ignore_list_re=self.config.ignore_patterns,\n+                        ignore_list_paths_re=self.config.ignore_paths,\n                     ):\n+                        # Entire subtree should be ignored if the root is matched.\n                         skip_subtrees.append(root)\n                         continue\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20826", "model_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 07605b5..cbe363d 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1190,6 +1190,17 @@ class _AxesBase(martist.Artist):\n             patch_visible = True\n \n         xaxis_visible = self.xaxis.get_visible()\n+\n+        # Ensure shared axes constraints are respected after clearing\n+        if self._sharex is not None:\n+            self.xaxis.major = self._sharex.xaxis.major\n+            self.xaxis.minor = self._sharex.xaxis.minor\n+            self.xaxis.set_tick_params(which='both', label1On=False, label2On=False)\n+\n+        if self._sharey is not None:\n+            self.yaxis.major = self._sharey.yaxis.major\n+            self.yaxis.minor = self._sharey.yaxis.minor\n+            self.yaxis.set_tick_params(which='both', label1On=False, label2On=False)\n         yaxis_visible = self.yaxis.get_visible()\n \n         self.xaxis.clear()\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex 93c576e..fa1b87a 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -810,6 +810,15 @@ class Axis(martist.Artist):\n         self._reset_minor_tick_kw()\n         self.reset_ticks()\n \n+        # Handle shared axis visibility for ticks and labels\n+        if hasattr(self, '_shared_axes') and self in self._shared_axes['x']:\n+            for shared_axis in self._shared_axes['x']:\n+                shared_axis.set_tick_params(which='both', label1On=False, label2On=False)\n+\n+        if hasattr(self, '_shared_axes') and self in self._shared_axes['y']:\n+            for shared_axis in self._shared_axes['y']:\n+                shared_axis.set_tick_params(which='both', label1On=False, label2On=False)\n+\n         self.converter = None\n         self.units = None\n         self.set_units(None)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pylint-dev__pylint-4970", "model_patch": "diff --git a/pylint/checkers/similar.py b/pylint/checkers/similar.py\nindex 79a566f..a2e0992 100644\n--- a/pylint/checkers/similar.py\n+++ b/pylint/checkers/similar.py\n@@ -396,6 +396,8 @@ class Similar:\n         \"\"\"compute similarities in appended files\"\"\"\n         no_duplicates: Dict[int, List[Set[LinesChunkLimits_T]]] = defaultdict(list)\n \n+        if self.config.min_similarity_lines == 0:\n+            return []\n         for commonality in self._iter_sims():\n             num = commonality.cmn_lines_nb\n             lineset1 = commonality.fst_lset\ndiff --git a/pylint/config/option_manager_mixin.py b/pylint/config/option_manager_mixin.py\nindex 78b7ebf..9b670c8 100644\n--- a/pylint/config/option_manager_mixin.py\n+++ b/pylint/config/option_manager_mixin.py\n@@ -184,7 +184,10 @@ class OptionsManagerMixIn:\n \n     def global_set_option(self, opt, value):\n         \"\"\"set option on the correct option provider\"\"\"\n-        self._all_options[opt].set_option(opt, value)\n+        if opt == \"min-similarity-lines\" and value == 0:\n+            self._all_options[opt].set_option(opt, value)\n+        else:\n+            self._all_options[opt].set_option(opt, value)\n \n     def generate_config(self, stream=None, skipsections=()):\n         \"\"\"write a configuration file according to the current configuration\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20488", "model_patch": "diff --git a/lib/matplotlib/image.py b/lib/matplotlib/image.py\nindex 7f3e359..7914f61 100644\n--- a/lib/matplotlib/image.py\n+++ b/lib/matplotlib/image.py\n@@ -533,8 +533,8 @@ class _ImageBase(martist.Artist, cm.ScalarMappable):\n                 # that may have moved input values in/out of range\n                 s_vmin, s_vmax = vrange\n                 if isinstance(self.norm, mcolors.LogNorm):\n-                    if s_vmin < 0:\n-                        s_vmin = max(s_vmin, np.finfo(scaled_dtype).eps)\n+                    if s_vmin <= 0:\n+                        s_vmin = np.finfo(scaled_dtype).eps\n                 with cbook._setattr_cm(self.norm,\n                                        vmin=s_vmin,\n                                        vmax=s_vmax,\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-10081", "model_patch": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 28c146e..319cf8b 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -316,7 +316,7 @@ class TestCaseFunction(Function):\n             # Arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed.\n-            if self.config.getoption(\"usepdb\") and not _is_skipped(self.obj):\n+            if self.config.getoption(\"usepdb\") and not _is_skipped(self._testcase):\n                 self._explicit_tearDown = self._testcase.tearDown\n                 setattr(self._testcase, \"tearDown\", lambda *args: None)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4966", "model_patch": "diff --git a/xarray/coding/variables.py b/xarray/coding/variables.py\nindex 30db316..c81163c 100644\n--- a/xarray/coding/variables.py\n+++ b/xarray/coding/variables.py\n@@ -316,6 +316,13 @@ class UnsignedIntegerCoder(VariableCoder):\n                     if \"_FillValue\" in attrs:\n                         new_fill = unsigned_dtype.type(attrs[\"_FillValue\"])\n                         attrs[\"_FillValue\"] = new_fill\n+                elif unsigned == \"false\":\n+                    signed_dtype = np.dtype(\"i%s\" % data.dtype.itemsize)\n+                    transform = partial(np.asarray, dtype=signed_dtype)\n+                    data = lazy_elemwise_func(data, transform, signed_dtype)\n+                    if \"_FillValue\" in attrs:\n+                        new_fill = signed_dtype.type(attrs[\"_FillValue\"])\n+                        attrs[\"_FillValue\"] = new_fill\n             else:\n                 warnings.warn(\n                     \"variable %r has _Unsigned attribute but is not \"\n@@ -324,4 +331,4 @@ class UnsignedIntegerCoder(VariableCoder):\n                     stacklevel=3,\n                 )\n \n-        return Variable(dims, data, attrs, encoding)\n+        return Variable(dims, data, attrs, encoding)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-6202", "model_patch": "diff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 26752a6..46129d3 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -286,7 +286,7 @@ class PyobjMixin(PyobjContext):\n             parts.append(name)\n         parts.reverse()\n         s = \".\".join(parts)\n-        return s.replace(\".[\", \"[\")\n+        return s\n \n     def reportinfo(self):\n         # XXX caching?\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5262", "model_patch": "diff --git a/src/_pytest/capture.py b/src/_pytest/capture.py\nindex 6b2d076..b4657a3 100644\n--- a/src/_pytest/capture.py\n+++ b/src/_pytest/capture.py\n@@ -429,6 +429,11 @@ class EncodedFile(object):\n         self.buffer = buffer\n         self.encoding = encoding\n \n+    @property\n+    def mode(self):\n+        \"\"\"Ensure that mode reflects text mode, not binary.\"\"\"\n+        return \"r+\"\n+\n     def write(self, obj):\n         if isinstance(obj, six.text_type):\n             obj = obj.encode(self.encoding, \"replace\")\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pylint-dev__pylint-7277", "model_patch": "diff --git a/pylint/__init__.py b/pylint/__init__.py\nindex 79f7224..8c3f68d 100644\n--- a/pylint/__init__.py\n+++ b/pylint/__init__.py\n@@ -96,7 +96,10 @@ def modify_sys_path() -> None:\n       if pylint is installed in an editable configuration (as the last item).\n       https://github.com/PyCQA/pylint/issues/4161\n     \"\"\"\n-    sys.path.pop(0)\n+    first_entry = sys.path[0] if sys.path else None\n+    cwd = os.getcwd()\n+    if first_entry in (\"\", \".\", cwd):\n+        sys.path.pop(0)\n     env_pythonpath = os.environ.get(\"PYTHONPATH\", \"\")\n     cwd = os.getcwd()\n     if env_pythonpath.startswith(\":\") and env_pythonpath not in (f\":{cwd}\", \":.\"):\n@@ -105,4 +108,4 @@ def modify_sys_path() -> None:\n         sys.path.pop(1)\n \n \n-version = __version__\n+version = __version__\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25332", "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 973eb1a..a937d68 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3174,6 +3174,8 @@ None}, default: None\n         from matplotlib import _pylab_helpers\n         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n             state['_restore_to_pylab'] = True\n+        # Exclude _align_label_groups, which contains weakref objects\n+        state.pop(\"_align_label_groups\", None)\n         return state\n \n     def __setstate__(self, state):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-7324", "model_patch": "diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex 337bbf3..2f95fcb 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -129,7 +129,7 @@ class Scanner:\n \n def expression(s: Scanner) -> ast.Expression:\n     if s.accept(TokenType.EOF):\n-        ret = ast.NameConstant(False)  # type: ast.expr\n+        ret = ast.Constant(value=False)  # type: ast.expr\n     else:\n         ret = expr(s)\n         s.accept(TokenType.EOF, reject=True)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24177", "model_patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 36d6e8e..13245dc 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6883,12 +6883,14 @@ such objects\n                     edgecolor=None if fill else c,\n                     fill=fill if fill else None,\n                     zorder=None if fill else mlines.Line2D.zorder))\n-            for patch_list in patches:\n+            for patch_list, top in zip(patches, tops):\n                 for patch in patch_list:\n                     if orientation == 'vertical':\n                         patch.sticky_edges.y.append(0)\n+                        patch.sticky_edges.y.append(np.max(top))  # Ensure proper scaling\n                     elif orientation == 'horizontal':\n                         patch.sticky_edges.x.append(0)\n+                        patch.sticky_edges.x.append(np.max(top))  # Ensure proper scaling\n \n             # we return patches, so put it back in the expected order\n             patches.reverse()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pylint-dev__pylint-4604", "model_patch": "diff --git a/pylint/checkers/variables.py b/pylint/checkers/variables.py\nindex 8c0035f..2cf70cd 100644\n--- a/pylint/checkers/variables.py\n+++ b/pylint/checkers/variables.py\n@@ -2033,6 +2033,11 @@ class VariablesChecker(BaseChecker):\n                 is_type_annotation_import = (\n                     imported_name in self._type_annotation_names\n                     or as_name in self._type_annotation_names\n+                    or any(\n+                        imported_name in type_comment\n+                        or as_name in type_comment\n+                        for type_comment in self._type_annotation_names\n+                    )\n                 )\n                 if isinstance(stmt, astroid.Import) or (\n                     isinstance(stmt, astroid.ImportFrom) and not stmt.modname\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4094", "model_patch": "diff --git a/xarray/core/merge.py b/xarray/core/merge.py\nindex 3a09d85..01aa3a9 100644\n--- a/xarray/core/merge.py\n+++ b/xarray/core/merge.py\n@@ -139,10 +139,15 @@ def unique_variable(\n                     break\n \n     if not equals:\n-        raise MergeError(\n-            f\"conflicting values for variable {name!r} on objects to be combined. \"\n-            \"You can skip this check by specifying compat='override'.\"\n-        )\n+        # Handle single-dimensional variables gracefully during unstacking\n+        if len(variables[0].dims) == 1:\n+            # If single-dimensional, default to the first variable in the list\n+            return out\n+        else:\n+            raise MergeError(\n+                f\"conflicting values for variable {name!r} on objects to be combined. \"\n+                \"You can skip this check by specifying compat='override'.\"\n+            )\n \n     if combine_method:\n         for var in variables[1:]:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16560", "model_patch": "diff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 8b23275..efdf20a 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -19,11 +19,12 @@ __all__ = [\"BaseConstraint\", \"CheckConstraint\", \"Deferrable\", \"UniqueConstraint\"\n class BaseConstraint:\n     default_violation_error_message = _(\"Constraint \u201c%(name)s\u201d is violated.\")\n     violation_error_message = None\n+    violation_error_code = None\n \n     # RemovedInDjango60Warning: When the deprecation ends, replace with:\n-    # def __init__(self, *, name, violation_error_message=None):\n-    def __init__(self, *args, name=None, violation_error_message=None):\n-        # RemovedInDjango60Warning.\n+    # def __init__(self, *, name, violation_error_message=None, violation_error_code=None):\n+    def __init__(self, *args, name=None, violation_error_message=None, violation_error_code=None):\n+        self.violation_error_code = violation_error_code\n         if name is None and not args:\n             raise TypeError(\n                 f\"{self.__class__.__name__}.__init__() missing 1 required keyword-only \"\n@@ -34,7 +35,7 @@ class BaseConstraint:\n             self.violation_error_message = violation_error_message\n         else:\n             self.violation_error_message = self.default_violation_error_message\n-        # RemovedInDjango60Warning.\n+        self.violation_error_code = violation_error_code\n         if args:\n             warnings.warn(\n                 f\"Passing positional arguments to {self.__class__.__name__} is \"\n@@ -42,7 +43,7 @@ class BaseConstraint:\n                 RemovedInDjango60Warning,\n                 stacklevel=2,\n             )\n-            for arg, attr in zip(args, [\"name\", \"violation_error_message\"]):\n+            for arg, attr in zip(args, [\"name\", \"violation_error_message\", \"violation_error_code\"]):\n                 if arg:\n                     setattr(self, attr, arg)\n \n@@ -63,7 +64,10 @@ class BaseConstraint:\n         raise NotImplementedError(\"This method must be implemented by a subclass.\")\n \n     def get_violation_error_message(self):\n-        return self.violation_error_message % {\"name\": self.name}\n+        return {\n+            \"message\": self.violation_error_message % {\"name\": self.name},\n+            \"code\": self.violation_error_code,\n+        }\n \n     def deconstruct(self):\n         path = \"%s.%s\" % (self.__class__.__module__, self.__class__.__name__)\n@@ -74,6 +78,8 @@ class BaseConstraint:\n             and self.violation_error_message != self.default_violation_error_message\n         ):\n             kwargs[\"violation_error_message\"] = self.violation_error_message\n+        if self.violation_error_code is not None:\n+            kwargs[\"violation_error_code\"] = self.violation_error_code\n         return (path, (), kwargs)\n \n     def clone(self):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-7982", "model_patch": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex 0e3c4ba..242ce25 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -411,7 +411,7 @@ def parts(s: str) -> Set[str]:\n def symlink_or_skip(src, dst, **kwargs):\n     \"\"\"Make a symlink, or skip the test in case symlinks are not supported.\"\"\"\n     try:\n-        os.symlink(str(src), str(dst), **kwargs)\n+        os.symlink(str(src), str(dst))\n     except OSError as e:\n         skip(f\"symlinks not supported: {e}\")\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4356", "model_patch": "diff --git a/xarray/core/nanops.py b/xarray/core/nanops.py\nindex 74e25c7..3aced8b 100644\n--- a/xarray/core/nanops.py\n+++ b/xarray/core/nanops.py\n@@ -32,7 +32,7 @@ def _maybe_null_out(result, axis, mask, min_count=1):\n         )\n \n     if axis is not None and getattr(result, \"ndim\", False):\n-        null_mask = (mask.shape[axis] - mask.sum(axis) - min_count) < 0\n+        null_mask = (np.prod(np.take(mask.shape, axis)) - mask.sum(axis) - min_count) < 0\n         if null_mask.any():\n             dtype, fill_value = dtypes.maybe_promote(result.dtype)\n             result = result.astype(dtype)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5809", "model_patch": "diff --git a/src/_pytest/pastebin.py b/src/_pytest/pastebin.py\nindex 9c2c4cd..7200d8d 100644\n--- a/src/_pytest/pastebin.py\n+++ b/src/_pytest/pastebin.py\n@@ -79,7 +79,7 @@ def create_new_paste(contents):\n \n     params = {\n         \"code\": contents,\n-        \"lexer\": \"python3\" if sys.version_info[0] >= 3 else \"python\",\n+        \"lexer\": \"text\",\n         \"expiry\": \"1week\",\n     }\n     url = \"https://bpaste.net\"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24627", "model_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex eec4e31..267bc3e 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1403,6 +1403,9 @@ class _AxesBase(martist.Artist):\n \n     def cla(self):\n         \"\"\"Clear the Axes.\"\"\"\n+        # Unset the `axes` attribute of all artists in the Axes.\n+        for artist in self.get_children():\n+            artist.axes = None\n         # Act as an alias, or as the superclass implementation depending on the\n         # subclass implementation.\n         if self._subclass_uses_cla:\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 916d57a..7b9f7b0 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -947,6 +947,9 @@ default: %(va)s\n \n         for ax in tuple(self.axes):  # Iterate over the copy.\n             ax.clear()\n+            # Unset the `figure` attribute of all artists in the Axes.\n+            for artist in ax.get_children():\n+                artist.figure = None\n             self.delaxes(ax)  # Remove ax from self._axstack.\n \n         self.artists = []\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-2905", "model_patch": "diff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex d82c4a0..79283a7 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -218,7 +218,8 @@ def as_compatible_data(data, fastpath=False):\n         data = np.timedelta64(getattr(data, \"value\", data), \"ns\")\n \n     # we don't want nested self-described arrays\n-    data = getattr(data, \"values\", data)\n+    if isinstance(data, (pd.Series, pd.DataFrame, np.ndarray)):\n+        data = getattr(data, \"values\", data)\n \n     if isinstance(data, np.ma.MaskedArray):\n         mask = np.ma.getmaskarray(data)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pylint-dev__pylint-6386", "model_patch": "diff --git a/pylint/config/option.py b/pylint/config/option.py\nindex ea80179..6ea0e3c 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -177,6 +177,9 @@ class Option(optparse.Option):\n             \"Option has been deprecated and will be removed in pylint 3.0\",\n             DeprecationWarning,\n         )\n+        # Ensure short options like '-v' for 'verbose' work as flags without expecting arguments\n+        if \"action\" not in attrs or attrs[\"action\"] not in [\"store\", \"store_true\", \"store_false\"]:\n+            attrs[\"action\"] = \"store_true\"\n         super().__init__(*opts, **attrs)\n         if hasattr(self, \"hide\") and self.hide:\n             self.help = optparse.SUPPRESS_HELP\n@@ -215,4 +218,4 @@ class Option(optparse.Option):\n         # And then take whatever action is expected of us.\n         # This is a separate method to make life easier for\n         # subclasses to add new actions.\n-        return self.take_action(self.action, self.dest, opt, value, values, parser)\n+        return self.take_action(self.action, self.dest, opt, value, values, parser)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-6599", "model_patch": "diff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 5a38507..e029a28 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1934,13 +1934,21 @@ def _ensure_numeric(data: T_Xarray) -> T_Xarray:\n \n     def to_floatable(x: DataArray) -> DataArray:\n         if x.dtype.kind in \"mM\":\n-            return x.copy(\n-                data=datetime_to_numeric(\n-                    x.data,\n-                    offset=np.datetime64(\"1970-01-01\"),\n-                    datetime_unit=\"ns\",\n-                ),\n-            )\n+            if x.dtype.kind == \"m\":  # timedelta64\n+                return x.copy(\n+                    data=timedelta_to_numeric(\n+                        x.data,\n+                        datetime_unit=\"ns\",  # Ensure correct unit conversion for timedelta64\n+                    ),\n+                )\n+            else:  # datetime64\n+                return x.copy(\n+                    data=datetime_to_numeric(\n+                        x.data,\n+                        offset=np.datetime64(\"1970-01-01\"),\n+                        datetime_unit=\"ns\",\n+                    ),\n+                )\n         return x\n \n     if isinstance(data, Dataset):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5631", "model_patch": "diff --git a/src/_pytest/compat.py b/src/_pytest/compat.py\nindex c84507d..ec52e9f 100644\n--- a/src/_pytest/compat.py\n+++ b/src/_pytest/compat.py\n@@ -68,7 +68,7 @@ def num_mock_patch_args(function):\n     if any(mock_modules):\n         sentinels = [m.DEFAULT for m in mock_modules if m is not None]\n         return len(\n-            [p for p in patchings if not p.attribute_name and p.new in sentinels]\n+            [p for p in patchings if not p.attribute_name and any(p.new is sentinel for sentinel in sentinels)]\n         )\n     return len(patchings)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-3095", "model_patch": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex 9bfa66f..001fabc 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -849,7 +849,7 @@ class DataArray(AbstractArray, DataWithCoords):\n         pandas.DataFrame.copy\n         \"\"\"\n         variable = self.variable.copy(deep=deep, data=data)\n-        coords = OrderedDict((k, v.copy(deep=deep))\n+        coords = OrderedDict((k, v.copy(deep=deep, data=np.array(v.data, dtype=v.data.dtype)))\n                              for k, v in self._coords.items())\n         return self._replace(variable, coords)\n \ndiff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex 6942a04..024bcc1 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -933,7 +933,7 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         pandas.DataFrame.copy\n         \"\"\"  # noqa\n         if data is None:\n-            variables = OrderedDict((k, v.copy(deep=deep))\n+            variables = OrderedDict((k, v.copy(deep=deep, data=np.array(v.data, dtype=v.data.dtype)))\n                                     for k, v in self._variables.items())\n         elif not utils.is_dict_like(data):\n             raise ValueError('Data must be dict-like')\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex c3f88b5..bae5782 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -808,8 +808,8 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,\n                 if isinstance(data, dask_array_type):\n                     data = data.copy()\n                 elif not isinstance(data, PandasIndexAdapter):\n-                    # pandas.Index is immutable\n-                    data = np.array(data)\n+                    # Preserve dtype when creating a deep copy\n+                    data = np.array(data, dtype=data.dtype)\n         else:\n             data = as_compatible_data(data)\n             if self.shape != data.shape:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-6197", "model_patch": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex 56dcb06..09d40af 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -533,7 +533,8 @@ class Session(nodes.FSCollector):\n                     seen_dirs.add(dirpath)\n                     pkginit = dirpath.join(\"__init__.py\")\n                     if pkginit.exists():\n-                        for x in self._collectfile(pkginit):\n+                        # Only collect __init__.py if explicitly marked for test collection\n+                        for x in self._collectfile(pkginit) if self.session.is_python_pkg(pkginit.dirpath()) else []:\n                             yield x\n                             if isinstance(x, Package):\n                                 self._pkg_roots[dirpath] = x\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-14141", "model_patch": "diff --git a/sklearn/utils/_show_versions.py b/sklearn/utils/_show_versions.py\nindex 72f054a..13bf362 100644\n--- a/sklearn/utils/_show_versions.py\n+++ b/sklearn/utils/_show_versions.py\n@@ -48,6 +48,7 @@ def _get_deps_info():\n         \"Cython\",\n         \"pandas\",\n         \"matplotlib\",\n+        \"joblib\",\n     ]\n \n     def get_version(module):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-7236", "model_patch": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 28ce115..38ab826 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -220,7 +220,7 @@ class TestCaseFunction(Function):\n             # arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed\n-            if self.config.getoption(\"usepdb\"):\n+            if self.config.getoption(\"usepdb\") and not self._testcase._outcome.skipped:\n                 self._explicit_tearDown = self._testcase.tearDown\n                 setattr(self._testcase, \"tearDown\", lambda *args: None)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24970", "model_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex bd73e56..bbe7012 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -727,9 +727,9 @@ class Colormap:\n                 xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n-        xa[xa > self.N - 1] = self._i_over\n-        xa[xa < 0] = self._i_under\n-        xa[mask_bad] = self._i_bad\n+        xa[xa > self.N - 1] = np.uint8(self._i_over)\n+        xa[xa < 0] = np.uint8(self._i_under)\n+        xa[mask_bad] = np.uint8(self._i_bad)\n \n         lut = self._lut\n         if bytes:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pylint-dev__pylint-4661", "model_patch": "diff --git a/pylint/config/find_default_config_files.py b/pylint/config/find_default_config_files.py\nindex 4b2d9f4..0a176f8 100644\n--- a/pylint/config/find_default_config_files.py\n+++ b/pylint/config/find_default_config_files.py\n@@ -58,7 +58,8 @@ def find_default_config_files():\n     else:\n         user_home = os.path.expanduser(\"~\")\n         if user_home not in (\"~\", \"/root\"):\n-            home_rc = os.path.join(user_home, \".pylintrc\")\n+            xdg_config_home = os.environ.get(\"XDG_CONFIG_HOME\", os.path.join(user_home, \".config\"))\n+            home_rc = os.path.join(xdg_config_home, \"pylintrc\")\n             if os.path.isfile(home_rc):\n                 yield home_rc\n             home_rc = os.path.join(user_home, \".config\", \"pylintrc\")\n@@ -66,4 +67,4 @@ def find_default_config_files():\n                 yield home_rc\n \n     if os.path.isfile(\"/etc/pylintrc\"):\n-        yield \"/etc/pylintrc\"\n+        yield \"/etc/pylintrc\"\ndiff --git a/pylint/lint/pylinter.py b/pylint/lint/pylinter.py\nindex 1b8a20a..262df8f 100644\n--- a/pylint/lint/pylinter.py\n+++ b/pylint/lint/pylinter.py\n@@ -479,6 +479,7 @@ class PyLinter(\n         self._reporters = {}\n         self._checkers = collections.defaultdict(list)\n         self._pragma_lineno = {}\n+        self.data_dir = self._get_data_dir()\n         self._ignore_file = False\n         # visit variables\n         self.file_state = FileState()\n@@ -528,6 +529,12 @@ class PyLinter(\n         if not self.reporter:\n             self._load_reporters()\n \n+    def _get_data_dir(self):\n+        \"\"\"Retrieve the appropriate data directory based on the XDG Base Directory Specification.\"\"\"\n+        user_home = os.path.expanduser(\"~\")\n+        xdg_data_home = os.environ.get(\"XDG_DATA_HOME\", os.path.join(user_home, \".local\", \"share\"))\n+        return os.path.join(xdg_data_home, \"pylint\")\n+\n     def load_plugin_modules(self, modnames):\n         \"\"\"take a list of module names which are pylint plugins and load\n         and register them\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-16256", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-12585", "model_patch": "diff --git a/sklearn/base.py b/sklearn/base.py\nindex 8dd093e..42f6f43 100644\n--- a/sklearn/base.py\n+++ b/sklearn/base.py\n@@ -48,7 +48,7 @@ def clone(estimator, safe=True):\n     # XXX: not handling dictionaries\n     if estimator_type in (list, tuple, set, frozenset):\n         return estimator_type([clone(e, safe=safe) for e in estimator])\n-    elif not hasattr(estimator, 'get_params'):\n+    elif not hasattr(estimator, 'get_params') or isinstance(estimator, type):\n         if not safe:\n             return copy.deepcopy(estimator)\n         else:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-22871", "model_patch": "diff --git a/lib/matplotlib/dates.py b/lib/matplotlib/dates.py\nindex cc65fc1..41efa68 100644\n--- a/lib/matplotlib/dates.py\n+++ b/lib/matplotlib/dates.py\n@@ -798,7 +798,8 @@ class ConciseDateFormatter(ticker.Formatter):\n         for level in range(5, -1, -1):\n             if len(np.unique(tickdate[:, level])) > 1:\n                 if level < 2:\n-                    show_offset = False\n+                    # Ensure that the year is always shown in the offset string\n+                    show_offset = True\n                 break\n             elif level == 0:\n                 # all tickdate are the same, so only micros might be different\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-8399", "model_patch": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex ae115dc..07abb32 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -144,7 +144,7 @@ def _make_xunit_fixture(\n         scope=scope,\n         autouse=True,\n         # Use a unique name to speed up lookup.\n-        name=f\"unittest_{setup_name}_fixture_{obj.__qualname__}\",\n+        name=f\"_unittest_{setup_name}_fixture_{obj.__qualname__}\",\n     )\n     def fixture(self, request: FixtureRequest) -> Generator[None, None, None]:\n         if _is_skipped(self):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-14496", "model_patch": "diff --git a/sklearn/cluster/optics_.py b/sklearn/cluster/optics_.py\nindex 29ab900..301f9cf 100644\n--- a/sklearn/cluster/optics_.py\n+++ b/sklearn/cluster/optics_.py\n@@ -437,7 +437,7 @@ if metric=\u2019precomputed\u2019.\n     n_samples = X.shape[0]\n     _validate_size(min_samples, n_samples, 'min_samples')\n     if min_samples <= 1:\n-        min_samples = max(2, min_samples * n_samples)\n+        min_samples = int(round(max(2, min_samples * n_samples)))\n \n     # Start all points as 'unprocessed' ##\n     reachability_ = np.empty(n_samples)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-6461", "model_patch": "diff --git a/xarray/core/ops.py b/xarray/core/ops.py\nindex 00a392c..e98eb28 100644\n--- a/xarray/core/ops.py\n+++ b/xarray/core/ops.py\n@@ -150,7 +150,7 @@ def fillna(data, other, join=\"left\", dataset_join=\"left\"):\n         dask=\"allowed\",\n         dataset_join=dataset_join,\n         dataset_fill_value=np.nan,\n-        keep_attrs=True,\n+        keep_attrs=False if np.isscalar(other) else True,\n     )\n \n \n@@ -181,7 +181,7 @@ def where_method(self, cond, other=dtypes.NA):\n         join=join,\n         dataset_join=join,\n         dask=\"allowed\",\n-        keep_attrs=True,\n+        keep_attrs=False if np.isscalar(other) else True,\n     )\n \n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-10051", "model_patch": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex 9234395..d71c46d 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -441,6 +441,7 @@ class LogCaptureFixture:\n     def clear(self) -> None:\n         \"\"\"Reset the list of log records and the captured log text.\"\"\"\n         self.handler.reset()\n+        self._item.stash[caplog_records_key].clear()\n \n     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n         \"\"\"Set the level of a logger for the duration of a test.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-10844", "model_patch": "diff --git a/sklearn/metrics/cluster/supervised.py b/sklearn/metrics/cluster/supervised.py\nindex a5624b4..5454538 100644\n--- a/sklearn/metrics/cluster/supervised.py\n+++ b/sklearn/metrics/cluster/supervised.py\n@@ -856,7 +856,7 @@ def fowlkes_mallows_score(labels_true, labels_pred, sparse=False):\n     tk = np.dot(c.data, c.data) - n_samples\n     pk = np.sum(np.asarray(c.sum(axis=0)).ravel() ** 2) - n_samples\n     qk = np.sum(np.asarray(c.sum(axis=1)).ravel() ** 2) - n_samples\n-    return tk / np.sqrt(pk * qk) if tk != 0. else 0.\n+    return np.sqrt(tk / pk) * np.sqrt(tk / qk) if tk != 0. else 0.\n \n \n def entropy(labels):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-7490", "model_patch": "diff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 1ea0522..7fd0364 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -632,6 +632,15 @@ class Item(Node):\n     def runtest(self) -> None:\n         raise NotImplementedError(\"runtest must be implemented by Item subclass\")\n \n+    def add_marker(self, marker):\n+        \"\"\"\n+        Dynamically adds a marker to the test item and refreshes xfail evaluation.\n+        \"\"\"\n+        super().add_marker(marker)\n+        if marker.name == \"xfail\":\n+            from _pytest.skipping import evaluate_xfail_marks\n+            evaluate_xfail_marks(self, refresh=True)\n+\n     def add_report_section(self, when: str, key: str, content: str) -> None:\n         \"\"\"\n         Adds a new report section, similar to what's done internally to add stdout and\ndiff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 1316da9..da380a7 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -197,7 +197,13 @@ class Xfail:\n     raises = attr.ib(type=Optional[Tuple[\"Type[BaseException]\", ...]])\n \n \n-def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n+def evaluate_xfail_marks(item: Item, refresh: bool = False) -> Optional[Xfail]:\n+    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\n+    \n+    If `refresh` is True, re-evaluates xfail marks in case new ones were added dynamically.\n+    \"\"\"\n+    if refresh:\n+        item._store[xfailed_key] = None  # Refresh cached xfail evaluation\n     \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n     for mark in item.iter_markers(name=\"xfail\"):\n         run = mark.kwargs.get(\"run\", True)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13439", "model_patch": "diff --git a/sklearn/pipeline.py b/sklearn/pipeline.py\nindex 4594f40..5884bd4 100644\n--- a/sklearn/pipeline.py\n+++ b/sklearn/pipeline.py\n@@ -223,6 +223,10 @@ class Pipeline(_BaseComposition):\n     def _estimator_type(self):\n         return self.steps[-1][1]._estimator_type\n \n+    def __len__(self):\n+        \"\"\"Return the number of steps in the pipeline.\"\"\"\n+        return len(self.steps)\n+\n     @property\n     def named_steps(self):\n         # Use Bunch object to improve autocomplete\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-15100", "model_patch": "diff --git a/sklearn/feature_extraction/text.py b/sklearn/feature_extraction/text.py\nindex d954f48..f6d64db 100644\n--- a/sklearn/feature_extraction/text.py\n+++ b/sklearn/feature_extraction/text.py\n@@ -130,10 +130,7 @@ def strip_accents_unicode(s):\n         ASCII equivalent.\n     \"\"\"\n     normalized = unicodedata.normalize('NFKD', s)\n-    if normalized == s:\n-        return s\n-    else:\n-        return ''.join([c for c in normalized if not unicodedata.combining(c)])\n+    return ''.join([c for c in normalized if not unicodedata.combining(c)])\n \n \n def strip_accents_ascii(s):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "django__django-15973", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-12973", "model_patch": "diff --git a/sklearn/linear_model/least_angle.py b/sklearn/linear_model/least_angle.py\nindex b1d16f1..31cb8d7 100644\n--- a/sklearn/linear_model/least_angle.py\n+++ b/sklearn/linear_model/least_angle.py\n@@ -1479,7 +1479,7 @@ class LassoLarsIC(LassoLars):\n         self.eps = eps\n         self.fit_path = True\n \n-    def fit(self, X, y, copy_X=True):\n+    def fit(self, X, y, copy_X=None):\n         \"\"\"Fit the model using X, y as training data.\n \n         Parameters\n@@ -1490,8 +1490,9 @@ class LassoLarsIC(LassoLars):\n         y : array-like, shape (n_samples,)\n             target values. Will be cast to X's dtype if necessary\n \n-        copy_X : boolean, optional, default True\n+        copy_X : boolean, optional, default None\n             If ``True``, X will be copied; else, it may be overwritten.\n+            If ``None``, the value set during initialization will be used.\n \n         Returns\n         -------\n@@ -1500,8 +1501,11 @@ class LassoLarsIC(LassoLars):\n         \"\"\"\n         X, y = check_X_y(X, y, y_numeric=True)\n \n+        if copy_X is None:\n+            copy_X = self.copy_X\n+\n         X, y, Xmean, ymean, Xstd = LinearModel._preprocess_data(\n-            X, y, self.fit_intercept, self.normalize, self.copy_X)\n+            X, y, self.fit_intercept, self.normalize, copy_X)\n         max_iter = self.max_iter\n \n         Gram = self.precompute\n@@ -1543,4 +1547,4 @@ class LassoLarsIC(LassoLars):\n         self.alpha_ = alphas_[n_best]\n         self.coef_ = coef_path_[:, n_best]\n         self._set_intercept(Xmean, ymean, Xstd)\n-        return self\n+        return self\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-11578", "model_patch": "diff --git a/sklearn/linear_model/logistic.py b/sklearn/linear_model/logistic.py\nindex 6a330d0..62cb0da 100644\n--- a/sklearn/linear_model/logistic.py\n+++ b/sklearn/linear_model/logistic.py\n@@ -922,7 +922,7 @@ def _log_reg_scoring_path(X, y, train, test, pos_class=None, Cs=10,\n         check_input=False, max_squared_sum=max_squared_sum,\n         sample_weight=sample_weight)\n \n-    log_reg = LogisticRegression(fit_intercept=fit_intercept)\n+    log_reg = LogisticRegression(fit_intercept=fit_intercept, multi_class=multi_class)\n \n     # The score method of Logistic Regression has a classes_ attribute.\n     if multi_class == 'ovr':\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13135", "model_patch": "diff --git a/sklearn/preprocessing/_discretization.py b/sklearn/preprocessing/_discretization.py\nindex c5fe0ab..97d55d6 100644\n--- a/sklearn/preprocessing/_discretization.py\n+++ b/sklearn/preprocessing/_discretization.py\n@@ -172,7 +172,7 @@ class KBinsDiscretizer(BaseEstimator, TransformerMixin):\n                 # 1D k-means procedure\n                 km = KMeans(n_clusters=n_bins[jj], init=init, n_init=1)\n                 centers = km.fit(column[:, None]).cluster_centers_[:, 0]\n-                bin_edges[jj] = (centers[1:] + centers[:-1]) * 0.5\n+                bin_edges[jj] = np.sort((centers[1:] + centers[:-1]) * 0.5)\n                 bin_edges[jj] = np.r_[col_min, bin_edges[jj], col_max]\n \n         self.bin_edges_ = bin_edges\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-3993", "model_patch": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex 4198249..157de86 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -3481,17 +3481,17 @@ class DataArray(AbstractArray, DataWithCoords):\n         return self._from_temp_dataset(ds)\n \n     def integrate(\n-        self, dim: Union[Hashable, Sequence[Hashable]], datetime_unit: str = None\n+        self, coord: Union[Hashable, Sequence[Hashable]], datetime_unit: str = None\n     ) -> \"DataArray\":\n         \"\"\" integrate the array with the trapezoidal rule.\n \n         .. note::\n-            This feature is limited to simple cartesian geometry, i.e. dim\n+            This feature is limited to simple cartesian geometry, i.e. coord\n             must be one dimensional.\n \n         Parameters\n         ----------\n-        dim : hashable, or sequence of hashable\n+        coord : hashable, or sequence of hashable\n             Coordinate(s) used for the integration.\n         datetime_unit : {\"Y\", \"M\", \"W\", \"D\", \"h\", \"m\", \"s\", \"ms\", \"us\", \"ns\", \\\n                          \"ps\", \"fs\", \"as\"}, optional\n@@ -3528,7 +3528,7 @@ class DataArray(AbstractArray, DataWithCoords):\n         array([5.4, 6.6, 7.8])\n         Dimensions without coordinates: y\n         \"\"\"\n-        ds = self._to_temp_dataset().integrate(dim, datetime_unit)\n+        ds = self._to_temp_dataset().integrate(coord, datetime_unit)\n         return self._from_temp_dataset(ds)\n \n     def unify_chunks(self) -> \"DataArray\":\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-7233", "model_patch": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex c0dd828..f9be2e5 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -1104,6 +1104,11 @@ class Dataset(\n             new_variables.pop(k)\n         new_variables.update(no_index_variables)\n \n+        # Ensure non-dimensional coordinates remain as coordinates\n+        for name in no_index_variables:\n+            if name in self._coord_names:\n+                new_coord_names.add(name)\n+\n         for name in drop_indexes:\n             new_indexes.pop(name)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-14053", "model_patch": "diff --git a/sklearn/tree/export.py b/sklearn/tree/export.py\nindex 8644d61..dde038b 100644\n--- a/sklearn/tree/export.py\n+++ b/sklearn/tree/export.py\n@@ -890,7 +890,10 @@ def export_text(decision_tree, feature_names=None, max_depth=10,\n         value_fmt = \"{}{} value: {}\\n\"\n \n     if feature_names:\n-        feature_names_ = [feature_names[i] for i in tree_.feature]\n+        feature_names_ = [\n+            feature_names[i] if i != _tree.TREE_UNDEFINED else \"undefined\"\n+            for i in tree_.feature\n+        ]\n     else:\n         feature_names_ = [\"feature_{}\".format(i) for i in tree_.feature]\n \n@@ -954,4 +957,4 @@ def export_text(decision_tree, feature_names=None, max_depth=10,\n                                                             trunc_report)\n \n     print_tree_recurse(0, 1)\n-    return export_text.report\n+    return export_text.report\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5787", "model_patch": "diff --git a/src/_pytest/terminal.py b/src/_pytest/terminal.py\nindex b402911..211bb31 100644\n--- a/src/_pytest/terminal.py\n+++ b/src/_pytest/terminal.py\n@@ -431,6 +431,10 @@ class TerminalReporter:\n                 else:\n                     self._tw.write(\" \")\n                 self._tw.write(word, **markup)\n+                if rep.failed and hasattr(rep.longrepr, 'chain'):\n+                    for exc_info in rep.longrepr.chain:\n+                        self._tw.write(\"\\n\")\n+                        self._tw.write(str(exc_info[0]) + \": \" + str(exc_info[1]), red=True)\n                 self._tw.write(\" \" + line)\n                 self.currentfspath = -2\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13124", "model_patch": "diff --git a/sklearn/model_selection/_split.py b/sklearn/model_selection/_split.py\nindex 1bd5697..4aca0e4 100644\n--- a/sklearn/model_selection/_split.py\n+++ b/sklearn/model_selection/_split.py\n@@ -651,9 +651,16 @@ class StratifiedKFold(_BaseKFold):\n         # NOTE: Passing the data corresponding to ith class say X[y==class_i]\n         # will break when the data is not 100% stratifiable for all classes.\n         # So we pass np.zeroes(max(c, n_splits)) as data to the KFold\n+        if self.shuffle:\n+            rng = check_random_state(self.random_state)\n+            for cls in unique_y:\n+                cls_indices = np.where(y == cls)[0]\n+                rng.shuffle(cls_indices)\n+                y[cls_indices] = cls  # Preserve class labels after shuffle\n+\n         per_cls_cvs = [\n-            KFold(self.n_splits, shuffle=self.shuffle,\n-                  random_state=rng).split(np.zeros(max(count, self.n_splits)))\n+            KFold(self.n_splits, shuffle=False,  # Turn off shuffle here; already handled\n+                  random_state=None).split(np.zeros(max(count, self.n_splits)))\n             for count in y_counts]\n \n         test_folds = np.zeros(n_samples, dtype=np.int)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13779", "model_patch": "diff --git a/sklearn/ensemble/voting.py b/sklearn/ensemble/voting.py\nindex 858d868..b0942af 100644\n--- a/sklearn/ensemble/voting.py\n+++ b/sklearn/ensemble/voting.py\n@@ -78,7 +78,7 @@ class _BaseVoting(_BaseComposition, TransformerMixin):\n \n         if sample_weight is not None:\n             for name, step in self.estimators:\n-                if not has_fit_parameter(step, 'sample_weight'):\n+                if step is not None and not has_fit_parameter(step, 'sample_weight'):\n                     raise ValueError('Underlying estimator \\'%s\\' does not'\n                                      ' support sample weights.' % name)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25775", "model_patch": "diff --git a/lib/matplotlib/backends/backend_agg.py b/lib/matplotlib/backends/backend_agg.py\nindex 5d9b9b4..483cb37 100644\n--- a/lib/matplotlib/backends/backend_agg.py\n+++ b/lib/matplotlib/backends/backend_agg.py\n@@ -205,8 +205,8 @@ class RendererAgg(RendererBase):\n         # We pass '0' for angle here, since it will be rotated (in raster\n         # space) in the following call to draw_text_image).\n         font.set_text(s, 0, flags=get_hinting_flag())\n-        font.draw_glyphs_to_bitmap(\n-            antialiased=mpl.rcParams['text.antialiased'])\n+        antialiased = mtext.get_antialiased() if mtext else mpl.rcParams['text.antialiased']\n+        font.draw_glyphs_to_bitmap(antialiased=antialiased)\n         d = font.get_descent() / 64.0\n         # The descent needs to be adjusted for the angle.\n         xo, yo = font.get_bitmap_offset()\ndiff --git a/lib/matplotlib/backends/backend_svg.py b/lib/matplotlib/backends/backend_svg.py\nindex e4c8312..49431d2 100644\n--- a/lib/matplotlib/backends/backend_svg.py\n+++ b/lib/matplotlib/backends/backend_svg.py\n@@ -1263,7 +1263,8 @@ class RendererSVG(RendererBase):\n             self.writer.start('a', {'xlink:href': gc.get_url()})\n \n         if mpl.rcParams['svg.fonttype'] == 'path':\n-            self._draw_text_as_path(gc, x, y, s, prop, angle, ismath, mtext)\n+            antialiased = mtext.get_antialiased() if mtext else mpl.rcParams['text.antialiased']\n+            self._draw_text_as_path(gc, x, y, s, prop, angle, ismath, mtext, antialiased=antialiased)\n         else:\n             self._draw_text_as_text(gc, x, y, s, prop, angle, ismath, mtext)\n \ndiff --git a/lib/matplotlib/text.py b/lib/matplotlib/text.py\nindex c2b18d4..85f894e 100644\n--- a/lib/matplotlib/text.py\n+++ b/lib/matplotlib/text.py\n@@ -183,12 +183,29 @@ class Text(Artist):\n         self._transform_rotates_text = transform_rotates_text\n         self._bbox_patch = None  # a FancyBboxPatch instance\n         self._renderer = None\n+        self._antialiased = None  # Default to None, falling back to rcParams.\n         if linespacing is None:\n             linespacing = 1.2  # Maybe use rcParam later.\n         self.set_linespacing(linespacing)\n         self.set_rotation_mode(rotation_mode)\n \n-    def update(self, kwargs):\n+    def get_antialiased(self):\n+        \"\"\"Return the antialiased setting for the text.\"\"\"\n+        if self._antialiased is None:\n+            return mpl.rcParams[\"text.antialiased\"]\n+        return self._antialiased\n+\n+    def set_antialiased(self, antialiased):\n+        \"\"\"\n+        Set the antialiased setting for the text.\n+\n+        Parameters\n+        ----------\n+        antialiased : bool or None\n+            Whether to apply antialiasing. If None, the value from\n+            rcParams[\"text.antialiased\"] will be used.\n+        \"\"\"\n+        self._antialiased = antialiased\n         # docstring inherited\n         kwargs = cbook.normalize_kwargs(kwargs, Text)\n         sentinel = object()  # bbox can be None, so use another sentinel.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-7521", "model_patch": "diff --git a/src/_pytest/capture.py b/src/_pytest/capture.py\nindex f40cad0..86dc1eb 100644\n--- a/src/_pytest/capture.py\n+++ b/src/_pytest/capture.py\n@@ -192,7 +192,7 @@ class EncodedFile(io.TextIOWrapper):\n \n class CaptureIO(io.TextIOWrapper):\n     def __init__(self) -> None:\n-        super().__init__(io.BytesIO(), encoding=\"UTF-8\", newline=\"\", write_through=True)\n+        super().__init__(io.BytesIO(), encoding=\"UTF-8\", newline=None, write_through=True)\n \n     def getvalue(self) -> str:\n         assert isinstance(self.buffer, io.BytesIO)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13496", "model_patch": "diff --git a/sklearn/ensemble/iforest.py b/sklearn/ensemble/iforest.py\nindex 17608bc..490b8ed 100644\n--- a/sklearn/ensemble/iforest.py\n+++ b/sklearn/ensemble/iforest.py\n@@ -170,6 +170,7 @@ class IsolationForest(BaseBagging, OutlierMixin):\n                  contamination=\"legacy\",\n                  max_features=1.,\n                  bootstrap=False,\n+                 warm_start=False,\n                  n_jobs=None,\n                  behaviour='old',\n                  random_state=None,\n@@ -182,6 +183,7 @@ class IsolationForest(BaseBagging, OutlierMixin):\n             # here above max_features has no links with self.max_features\n             bootstrap=bootstrap,\n             bootstrap_features=False,\n+            warm_start=warm_start,\n             n_estimators=n_estimators,\n             max_samples=max_samples,\n             max_features=max_features,\n@@ -190,6 +192,7 @@ class IsolationForest(BaseBagging, OutlierMixin):\n             verbose=verbose)\n \n         self.behaviour = behaviour\n+        self.warm_start = warm_start\n         self.contamination = contamination\n \n     def _set_oob_score(self, X, y):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-26466", "model_patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 7ccddf3..1a43a14 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -705,7 +705,8 @@ class Axes(_AxesBase):\n                  arrowprops=None, annotation_clip=None, **kwargs):\n         # Signature must match Annotation. This is verified in\n         # test_annotate_signature().\n-        a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,\n+        # Ensure `xy` is copied to avoid mutations affecting the annotation\n+        a = mtext.Annotation(text, np.array(xy, copy=True), xytext=xytext, xycoords=xycoords,\n                              textcoords=textcoords, arrowprops=arrowprops,\n                              annotation_clip=annotation_clip, **kwargs)\n         a.set_transform(mtransforms.IdentityTransform())\ndiff --git a/lib/matplotlib/text.py b/lib/matplotlib/text.py\nindex a4bce05..fe32299 100644\n--- a/lib/matplotlib/text.py\n+++ b/lib/matplotlib/text.py\n@@ -1810,8 +1810,9 @@ or callable, default: value of *xycoords*\n         :ref:`plotting-guide-annotation`\n \n         \"\"\"\n+        # Ensure `xy` is copied to avoid mutations affecting the annotation\n         _AnnotationBase.__init__(self,\n-                                 xy,\n+                                 np.array(xy, copy=True),\n                                  xycoords=xycoords,\n                                  annotation_clip=annotation_clip)\n         # warn about wonky input data\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-6744", "model_patch": "diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex eae2351..2af013d 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -274,6 +274,10 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n         starts = stops - int(self.window[0])\n         starts[: int(self.window[0])] = 0\n         for (label, start, stop) in zip(self.window_labels, starts, stops):\n+            if self.center:\n+                center_offset = (stop - start - 1) // 2\n+                start = max(0, start - center_offset)\n+                stop = min(len(self.window_labels), stop - center_offset)\n             window = self.obj.isel({self.dim[0]: slice(start, stop)})\n \n             counts = window.count(dim=self.dim[0])\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24149", "model_patch": "diff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 63a9e60..2d19625 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1746,7 +1746,10 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n         raise RuntimeError(\"matplotlib does not \"\n                            \"support generators as input\")\n     else:\n-        return next(val for val in obj if safe_isfinite(val))\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            return None\n \n \n def sanitize_sequence(data):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-10908", "model_patch": "diff --git a/sklearn/feature_extraction/text.py b/sklearn/feature_extraction/text.py\nindex 7e240fc..9a5900b 100644\n--- a/sklearn/feature_extraction/text.py\n+++ b/sklearn/feature_extraction/text.py\n@@ -993,7 +993,7 @@ class CountVectorizer(BaseEstimator, VectorizerMixin):\n \n     def get_feature_names(self):\n         \"\"\"Array mapping from feature integer indices to feature name\"\"\"\n-        self._check_vocabulary()\n+        self._validate_vocabulary()\n \n         return [t for t, i in sorted(six.iteritems(self.vocabulary_),\n                                      key=itemgetter(1))]\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-3151", "model_patch": "diff --git a/xarray/core/combine.py b/xarray/core/combine.py\nindex fe3f23b..2350bca 100644\n--- a/xarray/core/combine.py\n+++ b/xarray/core/combine.py\n@@ -66,42 +66,43 @@ def _infer_concat_order_from_coords(datasets):\n                 raise ValueError(\"Every dimension needs a coordinate for \"\n                                  \"inferring concatenation order\")\n \n-            # If dimension coordinate values are same on every dataset then\n-            # should be leaving this dimension alone (it's just a \"bystander\")\n-            if not all(index.equals(indexes[0]) for index in indexes[1:]):\n-\n-                # Infer order datasets should be arranged in along this dim\n-                concat_dims.append(dim)\n-\n-                if all(index.is_monotonic_increasing for index in indexes):\n-                    ascending = True\n-                elif all(index.is_monotonic_decreasing for index in indexes):\n-                    ascending = False\n-                else:\n-                    raise ValueError(\"Coordinate variable {} is neither \"\n-                                     \"monotonically increasing nor \"\n-                                     \"monotonically decreasing on all datasets\"\n-                                     .format(dim))\n-\n-                # Assume that any two datasets whose coord along dim starts\n-                # with the same value have the same coord values throughout.\n-                if any(index.size == 0 for index in indexes):\n-                    raise ValueError('Cannot handle size zero dimensions')\n-                first_items = pd.Index([index.take([0])\n-                                        for index in indexes])\n-\n-                # Sort datasets along dim\n-                # We want rank but with identical elements given identical\n-                # position indices - they should be concatenated along another\n-                # dimension, not along this one\n-                series = first_items.to_series()\n-                rank = series.rank(method='dense', ascending=ascending)\n-                order = rank.astype(int).values - 1\n-\n-                # Append positions along extra dimension to structure which\n-                # encodes the multi-dimensional concatentation order\n-                tile_ids = [tile_id + (position,) for tile_id, position\n-                            in zip(tile_ids, order)]\n+            # If dimension coordinate values are the same on every dataset,\n+            # ignore this dimension without requiring monotonicity (it's just a \"bystander\").\n+            if all(index.equals(indexes[0]) for index in indexes[1:]):\n+                continue\n+\n+            # Infer order datasets should be arranged in along this dim\n+            concat_dims.append(dim)\n+\n+            if all(index.is_monotonic_increasing for index in indexes):\n+                ascending = True\n+            elif all(index.is_monotonic_decreasing for index in indexes):\n+                ascending = False\n+            else:\n+                raise ValueError(\"Coordinate variable {} is neither \"\n+                                 \"monotonically increasing nor \"\n+                                 \"monotonically decreasing on all datasets\"\n+                                 .format(dim))\n+\n+            # Assume that any two datasets whose coord along dim starts\n+            # with the same value have the same coord values throughout.\n+            if any(index.size == 0 for index in indexes):\n+                raise ValueError('Cannot handle size zero dimensions')\n+            first_items = pd.Index([index.take([0])\n+                                    for index in indexes])\n+\n+            # Sort datasets along dim\n+            # We want rank but with identical elements given identical\n+            # position indices - they should be concatenated along another\n+            # dimension, not along this one\n+            series = first_items.to_series()\n+            rank = series.rank(method='dense', ascending=ascending)\n+            order = rank.astype(int).values - 1\n+\n+            # Append positions along extra dimension to structure which\n+            # encodes the multi-dimensional concatentation order\n+            tile_ids = [tile_id + (position,) for tile_id, position\n+                        in zip(tile_ids, order)]\n \n     if len(datasets) > 1 and not concat_dims:\n         raise ValueError(\"Could not find any dimension coordinates to use to \"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-25747", "model_patch": "diff --git a/sklearn/pipeline.py b/sklearn/pipeline.py\nindex 2f2ca70..34fd779 100644\n--- a/sklearn/pipeline.py\n+++ b/sklearn/pipeline.py\n@@ -1280,7 +1280,9 @@ class FeatureUnion(TransformerMixin, _BaseComposition):\n         config = _get_output_config(\"transform\", self)\n         if config[\"dense\"] == \"pandas\" and all(hasattr(X, \"iloc\") for X in Xs):\n             pd = check_pandas_support(\"transform\")\n-            return pd.concat(Xs, axis=1)\n+            concatenated = pd.concat(Xs, axis=1)\n+            concatenated.index = pd.RangeIndex(len(concatenated))\n+            return concatenated\n \n         if any(sparse.issparse(f) for f in Xs):\n             Xs = sparse.hstack(Xs).tocsr()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-7432", "model_patch": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 1e94c70..e72cdb5 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -291,12 +291,12 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n-    elif (\n+    if (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n         and type(rep.longrepr) is tuple\n     ):\n-        # skipped by mark.skipif; change the location of the failure\n+        # skipped by mark.skipif or mark.skip; change the location of the failure\n         # to point to the item definition, otherwise it will display\n         # the location of where the skip exception was raised within pytest\n         _, _, reason = rep.longrepr\n@@ -311,4 +311,4 @@ def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str\n             return \"xfailed\", \"x\", \"XFAIL\"\n         elif report.passed:\n             return \"xpassed\", \"X\", \"XPASS\"\n-    return None\n+    return None\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-25931", "model_patch": "diff --git a/sklearn/ensemble/_iforest.py b/sklearn/ensemble/_iforest.py\nindex d995c25..70821da 100644\n--- a/sklearn/ensemble/_iforest.py\n+++ b/sklearn/ensemble/_iforest.py\n@@ -345,7 +345,10 @@ class IsolationForest(OutlierMixin, BaseBagging):\n             return self\n \n         # else, define offset_ wrt contamination parameter\n-        self.offset_ = np.percentile(self.score_samples(X), 100.0 * self.contamination)\n+        self.offset_ = np.percentile(\n+            self.score_samples(self._validate_data(X, reset=False)), \n+            100.0 * self.contamination\n+        )\n \n         return self\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-10356", "model_patch": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex d345d83..5645747 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -357,7 +357,10 @@ class MarkDecorator:\n \n def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n     \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n+    # Collect pytestmark from all classes in the MRO to ensure markers are merged.\n+    mark_list = []\n+    for cls in getattr(obj, \"__mro__\", [obj]):\n+        mark_list.extend(getattr(cls, \"pytestmark\", []))\n     if not isinstance(mark_list, list):\n         mark_list = [mark_list]\n     return normalize_mark_list(mark_list)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-14629", "model_patch": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 224ebb4..5f9f696 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -855,10 +855,16 @@ def _fit_and_predict(estimator, X, y, train, test, verbose, fit_params,\n     predictions = func(X_test)\n     if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n         if isinstance(predictions, list):\n-            predictions = [_enforce_prediction_order(\n-                estimator.classes_[i_label], predictions[i_label],\n-                n_classes=len(set(y[:, i_label])), method=method)\n-                for i_label in range(len(predictions))]\n+            if hasattr(estimator, \"estimators_\"):\n+                predictions = [_enforce_prediction_order(\n+                    estimator.estimators_[i_label].classes_, predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n+            else:\n+                predictions = [_enforce_prediction_order(\n+                    estimator.classes_[i_label], predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n         else:\n             # A 2D y array should be a binary label indicator matrix\n             n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-7571", "model_patch": "diff --git a/src/_pytest/runner.py b/src/_pytest/runner.py\nindex a18956e..aa4f54e 100644\n--- a/src/_pytest/runner.py\n+++ b/src/_pytest/runner.py\n@@ -164,6 +164,11 @@ def pytest_runtest_call(item: Item) -> None:\n def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:\n     _update_current_test_var(item, \"teardown\")\n     item.session._setupstate.teardown_exact(item, nextitem)\n+\n+    # Finalize log capturing to restore log levels\n+    caplog_fixture = getattr(item, '_caplog_fixture', None)\n+    if caplog_fixture is not None:\n+        caplog_fixture._finalize()\n     _update_current_test_var(item, None)\n \n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4629", "model_patch": "diff --git a/xarray/core/merge.py b/xarray/core/merge.py\nindex 1328b95..5caed6a 100644\n--- a/xarray/core/merge.py\n+++ b/xarray/core/merge.py\n@@ -501,7 +501,7 @@ def merge_attrs(variable_attrs, combine_attrs):\n     if combine_attrs == \"drop\":\n         return {}\n     elif combine_attrs == \"override\":\n-        return variable_attrs[0]\n+        return dict(variable_attrs[0])\n     elif combine_attrs == \"no_conflicts\":\n         result = dict(variable_attrs[0])\n         for attrs in variable_attrs[1:]:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-6721", "model_patch": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex bb1e004..1ee99ce 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -2135,7 +2135,8 @@ class Dataset(\n         Dataset.chunksizes\n         xarray.unify_chunks\n         \"\"\"\n-        return get_chunksizes(self.variables.values())\n+        # Ensure lazy access to chunk sizes to avoid loading data into memory\n+        return get_chunksizes(var for var in self.variables.values())\n \n     @property\n     def chunksizes(self) -> Mapping[Hashable, tuple[int, ...]]:\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 1775e6c..5bd023e 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -339,7 +339,8 @@ class Variable(AbstractArray, NdimSizeLenMixin, VariableArithmetic):\n         if is_duck_array(self._data):\n             return self._data\n         else:\n-            return self.values\n+            # Avoid accessing self.values directly to prevent premature loading of data.\n+            raise ValueError(\"Data cannot be eagerly loaded in this context.\")\n \n     @data.setter\n     def data(self, data):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-7393", "model_patch": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex 0194550..73c48ed 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -4534,6 +4534,12 @@ class Dataset(\n                     product_vars.update(idx_vars)\n \n             if len(product_vars) == len(dims):\n+                # Ensure the dtype of product_vars is preserved before stacking\n+                for key in product_vars:\n+                    orig_dtype = self.variables[key].dtype\n+                    if product_vars[key].dtype != orig_dtype:\n+                        product_vars[key] = product_vars[key].astype(orig_dtype)\n+\n                 idx = index_cls.stack(product_vars, new_dim)\n                 new_indexes[new_dim] = idx\n                 new_indexes.update({k: idx for k in product_vars})\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex f056c40..16622fd 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -1696,6 +1696,10 @@ class Variable(AbstractArray, NdimSizeLenMixin, VariableArithmetic):\n         new_data = duck_array_ops.reshape(reordered.data, new_shape)\n         new_dims = reordered.dims[: len(other_dims)] + (new_dim,)\n \n+        # Preserve dtype explicitly\n+        if reordered.dtype != new_data.dtype:\n+            new_data = new_data.astype(reordered.dtype)\n+\n         return Variable(new_dims, new_data, self._attrs, self._encoding, fastpath=True)\n \n     def stack(self, dimensions=None, **dimensions_kwargs):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-6992", "model_patch": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex 1a9b7a7..779078f 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -365,7 +365,9 @@ class DataVariables(Mapping[Any, \"DataArray\"]):\n         )\n \n     def __len__(self) -> int:\n-        return len(self._dataset._variables) - len(self._dataset._coord_names)\n+        return sum(\n+            1 for key in self._dataset._variables if key not in self._dataset._coord_names\n+        )\n \n     def __contains__(self, key: Hashable) -> bool:\n         return key in self._dataset._variables and key not in self._dataset._coord_names\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-7229", "model_patch": "diff --git a/xarray/core/merge.py b/xarray/core/merge.py\nindex 952c546..b0ac24a 100644\n--- a/xarray/core/merge.py\n+++ b/xarray/core/merge.py\n@@ -642,6 +642,9 @@ def merge_attrs(variable_attrs, combine_attrs, context=None):\n     elif combine_attrs == \"drop\":\n         return {}\n     elif combine_attrs == \"override\":\n+        # Ensure coordinate attributes are preserved when merging\n+        if context and 'variable_name' in context and context['variable_name'] in context.get('coordinate_names', set()):\n+            return dict(variable_attrs[-1])  # Prefer the last item's attributes for coordinates\n         return dict(variable_attrs[0])\n     elif combine_attrs == \"no_conflicts\":\n         result = dict(variable_attrs[0])\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-11510", "model_patch": "diff --git a/sphinx/io.py b/sphinx/io.py\nindex 2cbe59f..aefb621 100644\n--- a/sphinx/io.py\n+++ b/sphinx/io.py\n@@ -112,6 +112,9 @@ class SphinxStandaloneReader(SphinxBaseReader):\n         # emit \"source-read\" event\n         arg = [content]\n         env.events.emit('source-read', env.docname, arg)\n+\n+        # Ensure modified content propagates to included files\n+        self.source = StringInput(arg[0])\n         return arg[0]\n \n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7462", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex c9ffcef..5ba23fe 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -100,7 +100,8 @@ def _parse_annotation(annotation: str) -> List[Node]:\n             for elem in node.elts:\n                 result.extend(unparse(elem))\n                 result.append(addnodes.desc_sig_punctuation('', ', '))\n-            result.pop()\n+            if result:\n+                result.pop()\n             result.append(addnodes.desc_sig_punctuation('', ']'))\n             return result\n         elif isinstance(node, ast.Module):\n@@ -118,7 +119,8 @@ def _parse_annotation(annotation: str) -> List[Node]:\n             for elem in node.elts:\n                 result.extend(unparse(elem))\n                 result.append(addnodes.desc_sig_punctuation('', ', '))\n-            result.pop()\n+            if result:\n+                result.pop()\n             return result\n         else:\n             raise SyntaxError  # unsupported syntax\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-11310", "model_patch": "diff --git a/sklearn/model_selection/_search.py b/sklearn/model_selection/_search.py\nindex 0f3216b..4927044 100644\n--- a/sklearn/model_selection/_search.py\n+++ b/sklearn/model_selection/_search.py\n@@ -766,10 +766,12 @@ class BaseSearchCV(six.with_metaclass(ABCMeta, BaseEstimator,\n         if self.refit:\n             self.best_estimator_ = clone(base_estimator).set_params(\n                 **self.best_params_)\n+            start_time = time.time()\n             if y is not None:\n                 self.best_estimator_.fit(X, y, **fit_params)\n             else:\n                 self.best_estimator_.fit(X, **fit_params)\n+            self.refit_time_ = time.time() - start_time\n \n         # Store the only scorer not as a dict for single metric evaluation\n         self.scorer_ = scorers if self.multimetric_ else scorers['score']\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8056", "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex f955f19..046718f 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -1094,7 +1094,10 @@ class NumpyDocstring(GoogleDocstring):\n             _name, _, _type = self._partition_field_on_colon(line)\n         else:\n             _name, _type = line, ''\n+        # Properly handle grouped names and optional types in the parameter list\n         _name, _type = _name.strip(), _type.strip()\n+        if \"optional\" in _type:\n+            _type = f\"({_type.strip()})\"\n         _name = self._escape_args_and_kwargs(_name)\n         _type = _convert_numpy_type_spec(\n             _type,\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10466", "model_patch": "diff --git a/sphinx/builders/gettext.py b/sphinx/builders/gettext.py\nindex c138802..528b046 100644\n--- a/sphinx/builders/gettext.py\n+++ b/sphinx/builders/gettext.py\n@@ -57,7 +57,7 @@ class Catalog:\n \n     def __iter__(self) -> Generator[Message, None, None]:\n         for message in self.messages:\n-            positions = [(source, line) for source, line, uuid in self.metadata[message]]\n+            positions = list(set((source, line) for source, line, uuid in self.metadata[message]))\n             uuids = [uuid for source, line, uuid in self.metadata[message]]\n             yield Message(message, positions, uuids)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-11445", "model_patch": "diff --git a/sphinx/parsers.py b/sphinx/parsers.py\nindex 1ab7d44..28cc39a 100644\n--- a/sphinx/parsers.py\n+++ b/sphinx/parsers.py\n@@ -82,7 +82,10 @@ class RSTParser(docutils.parsers.rst.Parser, Parser):\n \n     def decorate(self, content: StringList) -> None:\n         \"\"\"Preprocess reST content before parsing.\"\"\"\n-        prepend_prolog(content, self.config.rst_prolog)\n+        if self.config.rst_prolog:\n+            prolog_lines = StringList(self.config.rst_prolog.splitlines())\n+            # Ensure prolog lines are added after preserving document heading structure\n+            content[:0] = prolog_lines\n         append_epilog(content, self.config.rst_epilog)\n \n \n@@ -93,4 +96,4 @@ def setup(app: Sphinx) -> dict[str, Any]:\n         'version': 'builtin',\n         'parallel_read_safe': True,\n         'parallel_write_safe': True,\n-    }\n+    }\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7440", "model_patch": "diff --git a/sphinx/environment/collectors/indexentries.py b/sphinx/environment/collectors/indexentries.py\nindex b1cd81b..7cd24c0 100644\n--- a/sphinx/environment/collectors/indexentries.py\n+++ b/sphinx/environment/collectors/indexentries.py\n@@ -45,7 +45,8 @@ class IndexEntriesCollector(EnvironmentCollector):\n         for node in doctree.traverse(addnodes.index):\n             try:\n                 for entry in node['entries']:\n-                    split_index_msg(entry[0], entry[1])\n+                    # Force case-sensitive comparison for glossary entries\n+                    split_index_msg(entry[0].lower(), entry[1])\n             except ValueError as exc:\n                 logger.warning(str(exc), location=node)\n                 node.parent.remove(node)\n@@ -61,4 +62,4 @@ def setup(app: Sphinx) -> Dict[str, Any]:\n         'version': 'builtin',\n         'parallel_read_safe': True,\n         'parallel_write_safe': True,\n-    }\n+    }\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-6938", "model_patch": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex 8aa32fc..82b2a6f 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -3773,7 +3773,7 @@ class Dataset(\n             dims = tuple(dims_dict.get(dim, dim) for dim in v.dims)\n             if k in result_dims:\n                 var = v.to_index_variable()\n-                var.dims = dims\n+                var = var._replace(dims=dims)\n                 if k in self._indexes:\n                     indexes[k] = self._indexes[k]\n                     variables[k] = var\n@@ -3784,7 +3784,7 @@ class Dataset(\n                     coord_names.update(index_vars)\n             else:\n                 var = v.to_base_variable()\n-                var.dims = dims\n+                var = var._replace(dims=dims)\n                 variables[k] = var\n \n         return self._replace_with_new_dims(variables, coord_names, indexes=indexes)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-3677", "model_patch": "diff --git a/xarray/core/merge.py b/xarray/core/merge.py\nindex cad360a..5503716 100644\n--- a/xarray/core/merge.py\n+++ b/xarray/core/merge.py\n@@ -814,6 +814,11 @@ def dataset_merge_method(\n     else:\n         overwrite_vars = {overwrite_vars}\n \n+    from .dataarray import DataArray\n+\n+    if isinstance(other, DataArray):\n+        other = other.to_dataset()\n+\n     if not overwrite_vars:\n         objs = [dataset, other]\n         priority_arg = None\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-25232", "model_patch": "diff --git a/sklearn/impute/_iterative.py b/sklearn/impute/_iterative.py\nindex 62cdd57..3fa2940 100644\n--- a/sklearn/impute/_iterative.py\n+++ b/sklearn/impute/_iterative.py\n@@ -322,6 +322,7 @@ class IterativeImputer(_BaseImputer):\n         self.tol = tol\n         self.n_nearest_features = n_nearest_features\n         self.initial_strategy = initial_strategy\n+        self.fill_value = fill_value\n         self.imputation_order = imputation_order\n         self.skip_complete = skip_complete\n         self.min_value = min_value\n@@ -607,12 +608,20 @@ class IterativeImputer(_BaseImputer):\n         )\n         _check_inputs_dtype(X, self.missing_values)\n \n+        # Validate 'fill_value' only if 'initial_strategy' is 'constant'\n+        if self.initial_strategy == \"constant\" and np.isscalar(self.fill_value):\n+            if not isinstance(self.fill_value, (int, float, str, np.number)):\n+                raise ValueError(\n+                    \"`fill_value` must be a scalar (e.g., int, float, str) for `initial_strategy='constant'`.\"\n+                )\n+\n         X_missing_mask = _get_mask(X, self.missing_values)\n         mask_missing_values = X_missing_mask.copy()\n         if self.initial_imputer_ is None:\n             self.initial_imputer_ = SimpleImputer(\n                 missing_values=self.missing_values,\n                 strategy=self.initial_strategy,\n+                fill_value=self.fill_value if self.initial_strategy == \"constant\" else None,\n                 keep_empty_features=self.keep_empty_features,\n             )\n             X_filled = self.initial_imputer_.fit_transform(X)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-12682", "model_patch": "diff --git a/sklearn/decomposition/dict_learning.py b/sklearn/decomposition/dict_learning.py\nindex 8cfbe5f..ab1927f 100644\n--- a/sklearn/decomposition/dict_learning.py\n+++ b/sklearn/decomposition/dict_learning.py\n@@ -141,7 +141,7 @@ def _sparse_encode(X, dictionary, gram, cov=None, algorithm='lasso_lars',\n         # argument that we could pass in from Lasso.\n         clf = Lasso(alpha=alpha, fit_intercept=False, normalize=False,\n                     precompute=gram, max_iter=max_iter, warm_start=True,\n-                    positive=positive)\n+                    positive=positive, **additional_params)\n \n         if init is not None:\n             clf.coef_ = init\n@@ -187,6 +187,7 @@ def _sparse_encode(X, dictionary, gram, cov=None, algorithm='lasso_lars',\n def sparse_encode(X, dictionary, gram=None, cov=None, algorithm='lasso_lars',\n                   n_nonzero_coefs=None, alpha=None, copy_cov=True, init=None,\n                   max_iter=1000, n_jobs=None, check_input=True, verbose=0,\n+                  additional_params=None,\n                   positive=False):\n     \"\"\"Sparse coding\n \n@@ -311,6 +312,7 @@ def sparse_encode(X, dictionary, gram=None, cov=None, algorithm='lasso_lars',\n                               regularization=regularization, copy_cov=copy_cov,\n                               init=init,\n                               max_iter=max_iter,\n+                              additional_params=additional_params or {},\n                               check_input=False,\n                               verbose=verbose,\n                               positive=positive)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-14894", "model_patch": "diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py\nindex b637f36..ad521b8 100644\n--- a/sklearn/svm/base.py\n+++ b/sklearn/svm/base.py\n@@ -286,12 +286,16 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):\n             n_class = 1\n         n_SV = self.support_vectors_.shape[0]\n \n-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n-                                     dual_coef_indices.size / n_class)\n-        self.dual_coef_ = sp.csr_matrix(\n-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n-            (n_class, n_SV))\n+        if n_SV == 0:\n+            # No support vectors; set dual_coef_ to an empty sparse matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                         dual_coef_indices.size / n_class)\n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n \n     def predict(self, X):\n         \"\"\"Perform regression on samples in X.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-25973", "model_patch": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 295d6b7..c0896f4 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -1943,9 +1943,11 @@ def _aggregate_score_dicts(scores):\n     {'a': array([1, 2, 3, 10]),\n      'b': array([10, 2, 3, 10])}\n     \"\"\"\n+    if not scores:\n+        return {}\n     return {\n         key: np.asarray([score[key] for score in scores])\n         if isinstance(scores[0][key], numbers.Number)\n         else [score[key] for score in scores]\n         for key in scores[0]\n-    }\n+    }\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7910", "model_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f48faa1..6d5a7ed 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -138,7 +138,11 @@ def unwrap_all(obj: Any, *, stop: Callable = None) -> Any:\n         elif ispartial(obj):\n             obj = obj.func\n         elif inspect.isroutine(obj) and hasattr(obj, '__wrapped__'):\n+            # Preserve the original globals context when unwrapping\n+            original_globals = getattr(obj, '__globals__', None)\n             obj = obj.__wrapped__\n+            if original_globals and not hasattr(obj, '__globals__'):\n+                obj.__globals__ = original_globals\n         elif isclassmethod(obj):\n             obj = obj.__func__\n         elif isstaticmethod(obj):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10673", "model_patch": "diff --git a/sphinx/environment/collectors/toctree.py b/sphinx/environment/collectors/toctree.py\nindex 7757742..01a8e03 100644\n--- a/sphinx/environment/collectors/toctree.py\n+++ b/sphinx/environment/collectors/toctree.py\n@@ -109,7 +109,11 @@ class TocTreeCollector(EnvironmentCollector):\n                         item = toctreenode.copy()\n                         entries.append(item)\n                         # important: do the inventory stuff\n-                        TocTree(app.env).note(docname, toctreenode)\n+                        # Handle special references to autogenerated pages\n+                        if toctreenode.get('refuri') in {'genindex', 'modindex', 'search'}:\n+                            app.env.note_reread()\n+                        else:\n+                            TocTree(app.env).note(docname, toctreenode)\n             if entries:\n                 return nodes.bullet_list('', *entries)\n             return None\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-26194", "model_patch": "diff --git a/sklearn/metrics/_ranking.py b/sklearn/metrics/_ranking.py\nindex 0841d1d..830941f 100644\n--- a/sklearn/metrics/_ranking.py\n+++ b/sklearn/metrics/_ranking.py\n@@ -1083,7 +1083,11 @@ def roc_curve(\n     # to make sure that the curve starts at (0, 0)\n     tps = np.r_[0, tps]\n     fps = np.r_[0, fps]\n-    thresholds = np.r_[thresholds[0] + 1, thresholds]\n+    # Adjust the extra threshold position to ensure it does not exceed 1\n+    extra_threshold = thresholds[0] + 1\n+    if thresholds.max() <= 1:\n+        extra_threshold = min(extra_threshold, 1)\n+    thresholds = np.r_[extra_threshold, thresholds]\n \n     if fps[-1] <= 0:\n         warnings.warn(\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8459", "model_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex 6f90bd7..ee1d2dd 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -30,9 +30,15 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n             sig = inspect.signature(obj)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n-                    annotation[param.name] = typing.stringify(param.annotation)\n+                    if isinstance(param.annotation, str) and param.annotation in app.config.autodoc_type_aliases:\n+                        annotation[param.name] = app.config.autodoc_type_aliases[param.annotation]\n+                    else:\n+                        annotation[param.name] = typing.stringify(param.annotation)\n             if sig.return_annotation is not sig.empty:\n-                annotation['return'] = typing.stringify(sig.return_annotation)\n+                if isinstance(sig.return_annotation, str) and sig.return_annotation in app.config.autodoc_type_aliases:\n+                    annotation['return'] = app.config.autodoc_type_aliases[sig.return_annotation]\n+                else:\n+                    annotation['return'] = typing.stringify(sig.return_annotation)\n     except (TypeError, ValueError):\n         pass\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-10297", "model_patch": "diff --git a/sklearn/linear_model/ridge.py b/sklearn/linear_model/ridge.py\nindex c320acd..a9f4f55 100644\n--- a/sklearn/linear_model/ridge.py\n+++ b/sklearn/linear_model/ridge.py\n@@ -1301,6 +1301,10 @@ class RidgeClassifierCV(LinearClassifierMixin, _BaseRidgeCV):\n         weights inversely proportional to class frequencies in the input data\n         as ``n_samples / (n_classes * np.bincount(y))``\n \n+    store_cv_values : boolean, optional, default False\n+        If True, store the cross-validation values in the `cv_values_`\n+        attribute (only available if `cv=None`).\n+\n     Attributes\n     ----------\n     cv_values_ : array, shape = [n_samples, n_alphas] or \\\n@@ -1333,10 +1337,11 @@ class RidgeClassifierCV(LinearClassifierMixin, _BaseRidgeCV):\n     advantage of the multi-variate response support in Ridge.\n     \"\"\"\n     def __init__(self, alphas=(0.1, 1.0, 10.0), fit_intercept=True,\n-                 normalize=False, scoring=None, cv=None, class_weight=None):\n+                 normalize=False, scoring=None, cv=None, class_weight=None,\n+                 store_cv_values=False):\n         super(RidgeClassifierCV, self).__init__(\n             alphas=alphas, fit_intercept=fit_intercept, normalize=normalize,\n-            scoring=scoring, cv=cv)\n+            scoring=scoring, cv=cv, store_cv_values=store_cv_values)\n         self.class_weight = class_weight\n \n     def fit(self, X, y, sample_weight=None):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4687", "model_patch": "diff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 6e607da..8e69c39 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1114,7 +1114,7 @@ def apply_ufunc(\n         func = functools.partial(func, **kwargs)\n \n     if keep_attrs is None:\n-        keep_attrs = _get_keep_attrs(default=False)\n+        keep_attrs = _get_keep_attrs(default=True)\n \n     if isinstance(keep_attrs, bool):\n         keep_attrs = \"override\" if keep_attrs else \"drop\"\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex f1ee1d0..ce79d3d 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -1737,8 +1737,8 @@ class Variable(AbstractArray, NdimSizeLenMixin, VariableArithmetic):\n     def fillna(self, value):\n         return ops.fillna(self, value)\n \n-    def where(self, cond, other=dtypes.NA):\n-        return ops.where_method(self, cond, other)\n+    def where(self, cond, other=dtypes.NA, keep_attrs=True):\n+        return ops.where_method(self, cond, other, keep_attrs=keep_attrs)\n \n     def clip(self, min=None, max=None):\n         \"\"\"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13142", "model_patch": "diff --git a/sklearn/mixture/base.py b/sklearn/mixture/base.py\nindex a853e4a..0f41ec4 100644\n--- a/sklearn/mixture/base.py\n+++ b/sklearn/mixture/base.py\n@@ -188,7 +188,7 @@ class BaseMixture(DensityMixin, BaseEstimator, metaclass=ABCMeta):\n         -------\n         self\n         \"\"\"\n-        self.fit_predict(X, y)\n+        self.fit(X, y)\n         return self\n \n     def fit_predict(self, X, y=None):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7985", "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex 4e6b0df..67ad5ee 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -213,7 +213,12 @@ class CheckExternalLinksBuilder(Builder):\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n             elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+                # Validate local file paths\n+                local_path = path.join(self.env.srcdir, uri)\n+                if path.exists(local_path):\n+                    return 'working', 'local', 0\n+                else:\n+                    return 'broken', 'local file not found', 0\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-25102", "model_patch": "diff --git a/sklearn/utils/_set_output.py b/sklearn/utils/_set_output.py\nindex 52acc1f..19e033b 100644\n--- a/sklearn/utils/_set_output.py\n+++ b/sklearn/utils/_set_output.py\n@@ -1,3 +1,4 @@\n+\n from functools import wraps\n \n from scipy.sparse import issparse\n@@ -12,8 +13,9 @@ def _wrap_in_pandas_container(\n     *,\n     columns,\n     index=None,\n+    dtypes=None,\n ):\n-    \"\"\"Create a Pandas DataFrame.\n+    \"\"\"Create a Pandas DataFrame while optionally preserving dtypes.\n \n     If `data_to_wrap` is a DataFrame, then the `columns` and `index` will be changed\n     inplace. If `data_to_wrap` is a ndarray, then a new DataFrame is created with\n@@ -59,7 +61,10 @@ def _wrap_in_pandas_container(\n             data_to_wrap.index = index\n         return data_to_wrap\n \n-    return pd.DataFrame(data_to_wrap, index=index, columns=columns)\n+    df = pd.DataFrame(data_to_wrap, index=index, columns=columns)\n+    if dtypes is not None:\n+        df = df.astype(dtypes)\n+    return df\n \n \n def _get_output_config(method, estimator=None):\n@@ -127,7 +132,9 @@ def _wrap_data_with_container(method, data_to_wrap, original_input, estimator):\n         return data_to_wrap\n \n     # dense_config == \"pandas\"\n+    dtypes = getattr(original_input, \"dtypes\", None)\n     return _wrap_in_pandas_container(\n+        dtypes=dtypes,\n         data_to_wrap=data_to_wrap,\n         index=getattr(original_input, \"index\", None),\n         columns=estimator.get_feature_names_out,\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10449", "model_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex 671dde0..812cf45 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -169,10 +169,9 @@ def augment_descriptions_with_types(\n             node += field\n \n     # Add 'rtype' if 'return' is present and 'rtype' isn't.\n-    if 'return' in annotations:\n+    if 'return' in annotations and annotations['return'] != \"None\":\n         rtype = annotations['return']\n-        if 'return' not in has_type and ('return' in has_description or\n-                                         (force_rtype and rtype != \"None\")):\n+        if 'return' not in has_type and ('return' in has_description or force_rtype):\n             field = nodes.field()\n             field += nodes.field_name('', 'rtype')\n             field += nodes.field_body('', nodes.paragraph('', rtype))\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7757", "model_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 16613a0..d55a9cf 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -652,9 +652,20 @@ class Signature:\n                                                                   None):\n                 args.append('*')\n \n-            if param.kind in (param.POSITIONAL_ONLY,\n-                              param.POSITIONAL_OR_KEYWORD,\n-                              param.KEYWORD_ONLY):\n+            if param.kind == param.POSITIONAL_ONLY:\n+                arg.write(param.name)\n+                if show_annotation and param.annotation is not param.empty:\n+                    arg.write(': ')\n+                    arg.write(stringify_annotation(get_annotation(param)))\n+                if param.default is not param.empty:\n+                    if param.annotation is param.empty or show_annotation is False:\n+                        arg.write('=')\n+                        arg.write(object_description(param.default))\n+                    else:\n+                        arg.write(' = ')\n+                        arg.write(object_description(param.default))\n+            elif param.kind in (param.POSITIONAL_OR_KEYWORD,\n+                                param.KEYWORD_ONLY):\n                 arg.write(param.name)\n                 if show_annotation and param.annotation is not param.empty:\n                     arg.write(': ')\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10614", "model_patch": "diff --git a/sphinx/ext/inheritance_diagram.py b/sphinx/ext/inheritance_diagram.py\nindex 5f0da13..796ce57 100644\n--- a/sphinx/ext/inheritance_diagram.py\n+++ b/sphinx/ext/inheritance_diagram.py\n@@ -413,12 +413,12 @@ def html_visit_inheritance_diagram(self: HTML5Translator, node: inheritance_diag\n     for child in pending_xrefs:\n         if child.get('refuri') is not None:\n             if graphviz_output_format == 'SVG':\n-                urls[child['reftitle']] = \"../\" + child.get('refuri')\n+                urls[child['reftitle']] = relative_uri(current_filename, child.get('refuri'))\n             else:\n                 urls[child['reftitle']] = child.get('refuri')\n         elif child.get('refid') is not None:\n             if graphviz_output_format == 'SVG':\n-                urls[child['reftitle']] = '../' + current_filename + '#' + child.get('refid')\n+                urls[child['reftitle']] = relative_uri(current_filename, current_filename + '#' + child.get('refid'))\n             else:\n                 urls[child['reftitle']] = '#' + child.get('refid')\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-26323", "model_patch": "diff --git a/sklearn/compose/_column_transformer.py b/sklearn/compose/_column_transformer.py\nindex eec24f1..d7f5b13 100644\n--- a/sklearn/compose/_column_transformer.py\n+++ b/sklearn/compose/_column_transformer.py\n@@ -615,6 +615,10 @@ class ColumnTransformer(TransformerMixin, _BaseComposition):\n         names = [\n             name for name, _, _, _ in self._iter(fitted=True, replace_strings=True)\n         ]\n+        # Ensure the output is set for the remainder transformer if it's an estimator\n+        if hasattr(self.remainder, \"set_output\"):\n+            self.remainder.set_output(transform=config)\n+\n         for Xs, name in zip(result, names):\n             if not getattr(Xs, \"ndim\", 0) == 2:\n                 raise ValueError(\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8120", "model_patch": "diff --git a/sphinx/util/i18n.py b/sphinx/util/i18n.py\nindex e138044..e426e78 100644\n--- a/sphinx/util/i18n.py\n+++ b/sphinx/util/i18n.py\n@@ -95,6 +95,11 @@ class CatalogRepository:\n             if path.exists(path.join(locale_dir, self.language, 'LC_MESSAGES')):\n                 yield locale_dir\n \n+        # Additionally check if custom translations exist within the source directory\n+        default_locale_dir = path.join(self.basedir, 'locale', self.language, 'LC_MESSAGES')\n+        if path.exists(default_locale_dir):\n+            yield path.join(self.basedir, 'locale')\n+\n     @property\n     def pofiles(self) -> Generator[Tuple[str, str], None, None]:\n         for locale_dir in self.locale_dirs:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7889", "model_patch": "diff --git a/sphinx/ext/autodoc/mock.py b/sphinx/ext/autodoc/mock.py\nindex 6801938..5d1bd52 100644\n--- a/sphinx/ext/autodoc/mock.py\n+++ b/sphinx/ext/autodoc/mock.py\n@@ -70,7 +70,7 @@ class _MockObject:\n \n def _make_subclass(name: str, module: str, superclass: Any = _MockObject,\n                    attributes: Any = None) -> Any:\n-    attrs = {'__module__': module, '__display_name__': module + '.' + name}\n+    attrs = {'__module__': module, '__display_name__': module + '.' + str(name)}\n     attrs.update(attributes or {})\n \n     return type(name, (superclass,), attrs)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8035", "model_patch": "diff --git a/sphinx/ext/autodoc/directive.py b/sphinx/ext/autodoc/directive.py\nindex 846a505..272695b 100644\n--- a/sphinx/ext/autodoc/directive.py\n+++ b/sphinx/ext/autodoc/directive.py\n@@ -133,6 +133,11 @@ class AutodocDirective(SphinxDirective):\n \n         # process the options with the selected documenter's option_spec\n         try:\n+            # Support filtering specific private members via :private-members:\n+            if ':private-members:' in self.options:\n+                private_members_option = self.options[':private-members:']\n+                if isinstance(private_members_option, str):\n+                    self.options[':private-members:'] = [member.strip() for member in private_members_option.split(',')]\n             documenter_options = process_documenter_options(doccls, self.config, self.options)\n         except (KeyError, ValueError, TypeError) as exc:\n             # an option is either unknown or has a wrong type\n@@ -143,6 +148,11 @@ class AutodocDirective(SphinxDirective):\n         # generate the output\n         params = DocumenterBridge(self.env, reporter, documenter_options, lineno, self.state)\n         documenter = doccls(params, self.arguments[0])\n+\n+        # Filter private members based on the provided list in :private-members:\n+        if ':private-members:' in documenter.options and isinstance(documenter.options[':private-members:'], list):\n+            private_members = documenter.options[':private-members:']\n+            documenter.options['members'] = [member for member in documenter.options['members'] if member in private_members]\n         documenter.generate(more_content=self.content)\n         if not params.result:\n             return []\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-16597", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10323", "model_patch": "diff --git a/sphinx/directives/code.py b/sphinx/directives/code.py\nindex 2bf31d0..6e5921e 100644\n--- a/sphinx/directives/code.py\n+++ b/sphinx/directives/code.py\n@@ -343,7 +343,10 @@ class LiteralIncludeReader:\n     def prepend_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:\n         prepend = self.options.get('prepend')\n         if prepend:\n-            lines.insert(0, prepend + '\\n')\n+            # Calculate leading whitespace from the first line of the included code\n+            leading_whitespace = len(lines[0]) - len(lines[0].lstrip()) if lines else 0\n+            indented_prepend = ' ' * leading_whitespace + prepend + '\\n'\n+            lines.insert(0, indented_prepend)\n \n         return lines\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-14087", "model_patch": "diff --git a/sklearn/linear_model/logistic.py b/sklearn/linear_model/logistic.py\nindex dbd459e..1189291 100644\n--- a/sklearn/linear_model/logistic.py\n+++ b/sklearn/linear_model/logistic.py\n@@ -2171,7 +2171,7 @@ class LogisticRegressionCV(LogisticRegression, BaseEstimator,\n                 # all coefficients corresponding to the best scores.\n                 best_indices = np.argmax(scores, axis=1)\n                 if self.multi_class == 'ovr':\n-                    w = np.mean([coefs_paths[i, best_indices[i], :]\n+                    w = np.mean([coefs_paths[:, i, best_indices[i], :]\n                                  for i in range(len(folds))], axis=0)\n                 else:\n                     w = np.mean([coefs_paths[:, i, best_indices[i], :]\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8269", "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex 8266583..5285044 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -166,10 +166,14 @@ class CheckExternalLinksBuilder(Builder):\n                     # Read the whole document and see if #anchor exists\n                     response = requests.get(req_url, stream=True, config=self.app.config,\n                                             auth=auth_info, **kwargs)\n-                    found = check_anchor(response, unquote(anchor))\n+                    try:\n+                        response.raise_for_status()\n+                    except HTTPError as err:\n+                        return 'broken', str(err), 0\n \n+                    found = check_anchor(response, unquote(anchor))\n                     if not found:\n-                        raise Exception(__(\"Anchor '%s' not found\") % anchor)\n+                        return 'broken', __(\"Anchor '%s' not found\") % anchor, 0\n                 else:\n                     try:\n                         # try a HEAD request first, which should be easier on\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10435", "model_patch": "diff --git a/sphinx/writers/latex.py b/sphinx/writers/latex.py\nindex 2dc462a..ace821a 100644\n--- a/sphinx/writers/latex.py\n+++ b/sphinx/writers/latex.py\n@@ -1710,7 +1710,7 @@ class LaTeXTranslator(SphinxTranslator):\n         # TODO: Use nowrap option once LaTeX formatter supports it\n         # https://github.com/pygments/pygments/pull/1343\n         hlcode = hlcode.replace(r'\\begin{Verbatim}[commandchars=\\\\\\{\\}]',\n-                                r'\\sphinxcode{\\sphinxupquote{')\n+                                r'\\sphinxcode{\\sphinxupquote{%')\n         # get consistent trailer\n         hlcode = hlcode.rstrip()[:-14]  # strip \\end{Verbatim}\n         self.body.append(hlcode)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8595", "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 598a973..e1286bc 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1074,10 +1074,15 @@ class ModuleDocumenter(Documenter):\n     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n         members = self.get_module_members()\n         if want_all:\n-            if not self.__all__:\n+            if self.__all__ is None:\n                 # for implicit module members, check __module__ to avoid\n                 # documenting imported objects\n                 return True, list(members.values())\n+            elif not self.__all__:\n+                # explicitly empty __all__ should result in no members being documented\n+                for member in members.values():\n+                    member.skipped = True\n+                return False, []\n             else:\n                 for member in members.values():\n                     if member.__name__ not in self.__all__:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4695", "model_patch": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex 81d2785..0a3f810 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1164,6 +1164,13 @@ class DataArray(AbstractArray, DataWithCoords):\n         method : {None, \"nearest\", \"pad\", \"ffill\", \"backfill\", \"bfill\"}, optional\n             Method to use for inexact matches:\n \n+        .. note::\n+            If a dimension name conflicts with the `method` parameter,\n+            the dimension name must be passed as part of the `indexers`\n+            dictionary to avoid ambiguity. For example, instead of\n+            `sel(dim1=value, method='nearest')`, use\n+            `sel(indexers={'dim1': value}, method='nearest')`.\n+\n             * None (default): only exact matches\n             * pad / ffill: propagate last valid index value forward\n             * backfill / bfill: propagate next valid index value backward\n@@ -1201,7 +1208,11 @@ class DataArray(AbstractArray, DataWithCoords):\n             drop=drop,\n             method=method,\n             tolerance=tolerance,\n-            **indexers_kwargs,\n+            **{\n+                k: v\n+                for k, v in indexers_kwargs.items()\n+                if k not in self.dims or k == \"method\"\n+            },\n         )\n         return self._from_temp_dataset(ds)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-14983", "model_patch": "diff --git a/sklearn/model_selection/_split.py b/sklearn/model_selection/_split.py\nindex 8743303..b4a5e0b 100644\n--- a/sklearn/model_selection/_split.py\n+++ b/sklearn/model_selection/_split.py\n@@ -1165,6 +1165,8 @@ class _RepeatedSplits(metaclass=ABCMeta):\n \n \n class RepeatedKFold(_RepeatedSplits):\n+    def __repr__(self):\n+        return f\"{self.__class__.__name__}(n_splits={self.n_splits}, n_repeats={self.n_repeats}, random_state={self.random_state})\"\n     \"\"\"Repeated K-Fold cross validator.\n \n     Repeats K-Fold n times with different randomization in each repetition.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-16766", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-9288", "model_patch": "diff --git a/sklearn/cluster/k_means_.py b/sklearn/cluster/k_means_.py\nindex 915d041..810fe60 100644\n--- a/sklearn/cluster/k_means_.py\n+++ b/sklearn/cluster/k_means_.py\n@@ -378,7 +378,8 @@ def k_means(X, n_clusters, sample_weight=None, init='k-means++',\n                 best_n_iter = n_iter_\n     else:\n         # parallelisation of k-means runs\n-        seeds = random_state.randint(np.iinfo(np.int32).max, size=n_init)\n+        # Ensure deterministic random states for parallel runs\n+        seeds = [random_state.randint(np.iinfo(np.int32).max) for _ in range(n_init)]\n         results = Parallel(n_jobs=n_jobs, verbose=0)(\n             delayed(kmeans_single)(X, sample_weight, n_clusters,\n                                    max_iter=max_iter, init=init,\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9258", "model_patch": "diff --git a/sphinx/pycode/parser.py b/sphinx/pycode/parser.py\nindex 581aa9b..7700045 100644\n--- a/sphinx/pycode/parser.py\n+++ b/sphinx/pycode/parser.py\n@@ -274,7 +274,13 @@ class VariableCommentPicker(ast.NodeVisitor):\n         qualname = self.get_qualname_for(name)\n         if qualname:\n             basename = \".\".join(qualname[:-1])\n-            self.annotations[(basename, name)] = unparse(annotation)\n+            if isinstance(annotation, ast.BinOp) and isinstance(annotation.op, ast.BitOr):\n+                # Handle union types specified using '|'\n+                left = unparse(annotation.left)\n+                right = unparse(annotation.right)\n+                self.annotations[(basename, name)] = f\"{left} | {right}\"\n+            else:\n+                self.annotations[(basename, name)] = unparse(annotation)\n \n     def is_final(self, decorators: List[ast.expr]) -> bool:\n         final = []\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7454", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex c0a03a8..64bbfb3 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -92,6 +92,9 @@ def _parse_annotation(annotation: str) -> List[Node]:\n         elif isinstance(node, ast.Module):\n             return sum((unparse(e) for e in node.body), [])\n         elif isinstance(node, ast.Name):\n+            if node.id == \"None\":\n+                return [pending_xref('', nodes.Text(\"None\"),\n+                                     refdomain='py', reftype='class', reftarget='None')]\n             return [nodes.Text(node.id)]\n         elif isinstance(node, ast.Subscript):\n             result = unparse(node.value)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13091", "model_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex a947e2a..2db6971 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -313,7 +313,7 @@ class Basic(with_metaclass(ManagedProperties)):\n             try:\n                 other = _sympify(other)\n             except SympifyError:\n-                return False    # sympy != other\n+                return NotImplemented    # sympy != other\n \n             if type(self) != type(other):\n                 return False\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-14710", "model_patch": "diff --git a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\nindex f6e53af..e46cab5 100644\n--- a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n+++ b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n@@ -426,11 +426,15 @@ class BaseHistGradientBoosting(BaseEstimator, ABC):\n \n         Scores are computed on validation data or on training data.\n         \"\"\"\n+        if hasattr(self, 'classes_'):\n+            y_small_train = self.classes_[y_small_train.astype(int)]\n         self.train_score_.append(\n             self.scorer_(self, X_binned_small_train, y_small_train)\n         )\n \n         if self._use_validation_data:\n+            if hasattr(self, 'classes_'):\n+                y_val = self.classes_[y_val.astype(int)]\n             self.validation_score_.append(\n                 self.scorer_(self, X_binned_val, y_val)\n             )\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8551", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex f44a82b..986492f 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -1294,7 +1294,8 @@ class PythonDomain(Domain):\n                      ) -> Element:\n         modname = node.get('py:module')\n         clsname = node.get('py:class')\n-        searchmode = 1 if node.hasattr('refspecific') else 0\n+        # Respect the \"refspecific\" attribute to prioritize the current module and its hierarchy\n+        searchmode = 1 if node.get('refspecific', False) else 0\n         matches = self.find_obj(env, modname, clsname, target,\n                                 type, searchmode)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9591", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 38aeecb..f1c0c0c 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -179,7 +179,7 @@ def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Nod\n         tree = ast_parse(annotation)\n         result = unparse(tree)\n         for i, node in enumerate(result):\n-            if isinstance(node, nodes.Text) and node.strip():\n+            if isinstance(node, nodes.Text) and str(node).strip():\n                 result[i] = type_to_xref(str(node), env)\n         return result\n     except SyntaxError:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9281", "model_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 40a5e6d..9993355 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -457,10 +457,14 @@ def object_description(object: Any) -> str:\n         else:\n             return \"frozenset({%s})\" % \", \".join(object_description(x)\n                                                  for x in sorted_values)\n-    try:\n-        s = repr(object)\n-    except Exception as exc:\n-        raise ValueError from exc\n+    if isinstance(object, Enum):\n+        # Format Enum values cleanly as `EnumName.ValueName`\n+        s = f\"{object.__class__.__name__}.{object.name}\"\n+    else:\n+        try:\n+            s = repr(object)\n+        except Exception as exc:\n+            raise ValueError from exc\n     # Strip non-deterministic memory addresses such as\n     # ``<__main__.A at 0x7f68cb685710>``\n     s = memory_address_re.sub('', s)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-11618", "model_patch": "diff --git a/sympy/geometry/point.py b/sympy/geometry/point.py\nindex 7c58cbf..3a59706 100644\n--- a/sympy/geometry/point.py\n+++ b/sympy/geometry/point.py\n@@ -266,8 +266,9 @@ class Point(GeometryEntity):\n         sqrt(x**2 + y**2)\n \n         \"\"\"\n-        return sqrt(sum([(a - b)**2 for a, b in zip(\n-            self.args, p.args if isinstance(p, Point) else p)]))\n+        from itertools import zip_longest\n+        return sqrt(sum([(a - b)**2 for a, b in zip_longest(\n+            self.args, p.args if isinstance(p, Point) else p, fillvalue=0)]))\n \n     def taxicab_distance(self, p):\n         \"\"\"The Taxicab Distance from self to point p.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9320", "model_patch": "diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py\nindex 9978773..f7b4e8c 100644\n--- a/sphinx/cmd/quickstart.py\n+++ b/sphinx/cmd/quickstart.py\n@@ -223,7 +223,7 @@ def ask_user(d: Dict) -> None:\n         print(__('sphinx-quickstart will not overwrite existing Sphinx projects.'))\n         print()\n         d['path'] = do_prompt(__('Please enter a new root path (or just Enter to exit)'),\n-                              '', is_path)\n+                              '', lambda x: is_path(x) if x else x)\n         if not d['path']:\n             sys.exit(1)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15017", "model_patch": "diff --git a/sympy/tensor/array/ndim_array.py b/sympy/tensor/array/ndim_array.py\nindex 0b1a18b..72306b1 100644\n--- a/sympy/tensor/array/ndim_array.py\n+++ b/sympy/tensor/array/ndim_array.py\n@@ -175,6 +175,8 @@ class NDimArray(object):\n         9\n \n         \"\"\"\n+        if self.shape == ():\n+            return 1  # Rank-0 arrays (scalars) have a length of 1\n         return self._loop_size\n \n     @property\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9711", "model_patch": "diff --git a/sphinx/extension.py b/sphinx/extension.py\nindex 6ac780b..bae77a7 100644\n--- a/sphinx/extension.py\n+++ b/sphinx/extension.py\n@@ -51,7 +51,8 @@ def verify_needs_extensions(app: \"Sphinx\", config: Config) -> None:\n                               'but it is not loaded.'), extname)\n             continue\n \n-        if extension.version == 'unknown version' or reqversion > extension.version:\n+        from packaging.version import Version\n+        if extension.version == 'unknown version' or Version(extension.version) < Version(reqversion):\n             raise VersionRequirementError(__('This project needs the extension %s at least in '\n                                              'version %s and therefore cannot be built with '\n                                              'the loaded version (%s).') %\n@@ -65,4 +66,4 @@ def setup(app: \"Sphinx\") -> Dict[str, Any]:\n         'version': 'builtin',\n         'parallel_read_safe': True,\n         'parallel_write_safe': True,\n-    }\n+    }\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-16886", "model_patch": "diff --git a/sympy/crypto/crypto.py b/sympy/crypto/crypto.py\nindex 156e471..d9cd917 100644\n--- a/sympy/crypto/crypto.py\n+++ b/sympy/crypto/crypto.py\n@@ -1524,7 +1524,7 @@ morse_char = {\n     \"..---\": \"2\", \"...--\": \"3\",\n     \"....-\": \"4\", \".....\": \"5\",\n     \"-....\": \"6\", \"--...\": \"7\",\n-    \"---..\": \"8\", \"----.\": \"9\",\n+    \"---..\": \"8\", \".----\": \"1\", \"----.\": \"9\",\n     \".-.-.-\": \".\", \"--..--\": \",\",\n     \"---...\": \":\", \"-.-.-.\": \";\",\n     \"..--..\": \"?\", \"-....-\": \"-\",\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-14711", "model_patch": "diff --git a/sympy/physics/vector/vector.py b/sympy/physics/vector/vector.py\nindex 77e79b6..52e3de7 100644\n--- a/sympy/physics/vector/vector.py\n+++ b/sympy/physics/vector/vector.py\n@@ -57,6 +57,8 @@ class Vector(object):\n \n     def __add__(self, other):\n         \"\"\"The add operator for Vector. \"\"\"\n+        if other == 0:\n+            return self\n         other = _check_vector(other)\n         return Vector(self.args + other.args)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13031", "model_patch": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 79b3d5e..5ea1bb4 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -378,6 +378,9 @@ class MatrixShaping(MatrixRequired):\n             return cls._new()\n \n         kls = type(args[0])\n+        if all(arg.rows == 0 for arg in args):  # Handle case where all matrices have zero rows\n+            total_cols = sum(arg.cols for arg in args)\n+            return cls.zeros(0, total_cols)\n         return reduce(kls.row_join, args)\n \n     def reshape(self, rows, cols):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15345", "model_patch": "diff --git a/sympy/printing/mathematica.py b/sympy/printing/mathematica.py\nindex 7ecda40..c06b754 100644\n--- a/sympy/printing/mathematica.py\n+++ b/sympy/printing/mathematica.py\n@@ -99,6 +99,9 @@ class MCodePrinter(CodePrinter):\n             for cond, mfunc in cond_mfunc:\n                 if cond(*expr.args):\n                     return \"%s[%s]\" % (mfunc, self.stringify(expr.args, \", \"))\n+        # Ensure proper ordering for Max in Mathematica\n+        if expr.func.__name__ == \"Max\":\n+            return \"Max[%s]\" % self.stringify(expr.args, \", \")\n         return expr.func.__name__ + \"[%s]\" % self.stringify(expr.args, \", \")\n \n     def _print_Integral(self, expr):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13328", "model_patch": "diff --git a/sklearn/linear_model/huber.py b/sklearn/linear_model/huber.py\nindex 774a22b..d590d35 100644\n--- a/sklearn/linear_model/huber.py\n+++ b/sklearn/linear_model/huber.py\n@@ -252,6 +252,7 @@ class HuberRegressor(LinearModel, RegressorMixin, BaseEstimator):\n         \"\"\"\n         X, y = check_X_y(\n             X, y, copy=False, accept_sparse=['csr'], y_numeric=True)\n+        X = as_float_array(X, copy=False)\n         if sample_weight is not None:\n             sample_weight = np.array(sample_weight)\n             check_consistent_length(y, sample_weight)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8548", "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 60d49fe..1a679c5 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -672,10 +672,12 @@ class Documenter:\n                     if cls.__name__ == self.options.inherited_members and cls != self.object:\n                         # given member is a member of specified *super class*\n                         return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n+                    elif name in cls.__dict__ or name in self.get_attr(cls, '__annotations__', {}):\n+                        # Member is defined or annotated in this class\n                         return False\n+                    elif any(name in base.__dict__ for base in cls.__bases__):\n+                        # Member is defined in a base class\n+                        return True\n \n             return False\n \ndiff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex 6a4748c..c93877d 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -285,17 +285,18 @@ def get_class_members(subject: Any, objpath: List[str], attrgetter: Callable,\n         pass\n \n     # other members\n-    for name in dir(subject):\n-        try:\n-            value = attrgetter(subject, name)\n-            unmangled = unmangle(subject, name)\n-            if unmangled and unmangled not in members:\n-                if name in obj_dict:\n-                    members[unmangled] = ClassAttribute(subject, unmangled, value)\n-                else:\n-                    members[unmangled] = ClassAttribute(None, unmangled, value)\n-        except AttributeError:\n-            continue\n+    for cls in getmro(subject):\n+        for name in dir(cls):\n+            try:\n+                value = attrgetter(cls, name)\n+                unmangled = unmangle(cls, name)\n+                if unmangled and unmangled not in members:\n+                    if name in cls.__dict__:\n+                        members[unmangled] = ClassAttribute(cls, unmangled, value)\n+                    else:\n+                        members[unmangled] = ClassAttribute(None, unmangled, value)\n+            except AttributeError:\n+                continue\n \n     # annotation only member (ex. attr: int)\n     for cls in getmro(subject):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8621", "model_patch": "diff --git a/sphinx/roles.py b/sphinx/roles.py\nindex 307975f..4adbecb 100644\n--- a/sphinx/roles.py\n+++ b/sphinx/roles.py\n@@ -460,7 +460,24 @@ class EmphasizedLiteral(SphinxRole):\n     parens_re = re.compile(r'(\\\\\\\\|\\\\{|\\\\}|{|})')\n \n     def run(self) -> Tuple[List[Node], List[system_message]]:\n-        children = self.parse(self.text)\n+        # Parse the input text for the :kbd: role\n+        # Modify parsing to differentiate between standalone and separator use cases\n+        if 'kbd' in self.name:\n+            parts = re.split(r'(-|\\+|\\^)', self.text)  # Split on separators\n+            children = []\n+            for idx, part in enumerate(parts):\n+                if part in ('-', '+', '^'):  # If it's a separator\n+                    if idx == 0 or idx == len(parts) - 1 or parts[idx - 1] == '' or parts[idx + 1] == '':\n+                        # Treat as a literal character if it's at the boundary or surrounded by empty values\n+                        children.append(nodes.literal(part, part, classes=['kbd']))\n+                    else:\n+                        # Otherwise, treat it as a separator\n+                        children.append(nodes.Text(part, part))\n+                else:\n+                    # Treat as a regular keystroke\n+                    children.append(nodes.literal(part, part, classes=['kbd']))\n+        else:\n+            children = self.parse(self.text)\n         node = nodes.literal(self.rawtext, '', *children,\n                              role=self.name.lower(), classes=[self.name])\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7590", "model_patch": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex 71a23bd..1d3ee98 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -4682,7 +4682,13 @@ class DefinitionParser(BaseParser):\n                 self.fail(\"Can not handle character literal\"\n                           \" resulting in multiple decoded characters.\")\n \n-        # TODO: user-defined lit\n+        # user-defined literal\n+        if self.match(integer_literal_re) or self.match(float_literal_re):\n+            value = self.last_match.group()\n+            self.skip_ws()\n+            if self.match(identifier_re):  # Match the UDL suffix\n+                suffix = self.last_match.group()\n+                return ASTUserDefinedLiteral(value, suffix)\n         return None\n \n     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8475", "model_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex 49ae1f0..f38e38e 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -172,9 +172,9 @@ class CheckExternalLinksBuilder(Builder):\n                                                  config=self.app.config, auth=auth_info,\n                                                  **kwargs)\n                         response.raise_for_status()\n-                    except HTTPError:\n+                    except (HTTPError, requests.exceptions.TooManyRedirects):\n                         # retry with GET request if that fails, some servers\n-                        # don't like HEAD requests.\n+                        # don't like HEAD requests or redirect in loops.\n                         response = requests.get(req_url, stream=True, config=self.app.config,\n                                                 auth=auth_info, **kwargs)\n                         response.raise_for_status()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8721", "model_patch": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex 27202ee..54eab91 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,9 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n-    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n-        return\n+    if app.builder.name.startswith(\"epub\"):\n+        if not env.config.viewcode_enable_epub:\n+            return\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9229", "model_patch": "diff --git a/sphinx/ext/autodoc/directive.py b/sphinx/ext/autodoc/directive.py\nindex c513d14..d9dd0c7 100644\n--- a/sphinx/ext/autodoc/directive.py\n+++ b/sphinx/ext/autodoc/directive.py\n@@ -159,7 +159,13 @@ class AutodocDirective(SphinxDirective):\n         # generate the output\n         params = DocumenterBridge(self.env, reporter, documenter_options, lineno, self.state)\n         documenter = doccls(params, self.arguments[0])\n+        # Generate the documentation\n         documenter.generate(more_content=self.content)\n+\n+        # Ensure type alias docstrings are included\n+        if hasattr(documenter, 'objtype') and documenter.objtype == 'data':\n+            if hasattr(documenter.object, '__doc__') and documenter.object.__doc__:\n+                params.result = [documenter.object.__doc__] + params.result\n         if not params.result:\n             return []\n \n@@ -171,4 +177,4 @@ class AutodocDirective(SphinxDirective):\n             self.state.document.settings.record_dependencies.add(fn)\n \n         result = parse_generated_content(self.state, params.result, documenter)\n-        return result\n+        return result\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8265", "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex facb103..37c7cb1 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -1090,7 +1090,10 @@ class NumpyDocstring(GoogleDocstring):\n     def _escape_args_and_kwargs(self, name: str) -> str:\n         func = super()._escape_args_and_kwargs\n \n-        if \", \" in name:\n+        if name.startswith('(') and name.endswith(')'):\n+            # Handle tuple arguments by escaping the entire tuple as-is\n+            return name\n+        elif \", \" in name:\n             return \", \".join(func(param) for param in name.split(\", \"))\n         else:\n             return func(name)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8593", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex b1d3c04..227f3a7 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -1052,7 +1052,7 @@ class PyXRefRole(XRefRole):\n         return title, target\n \n \n-def filter_meta_fields(app: Sphinx, domain: str, objtype: str, content: Element) -> None:\n+def filter_meta_fields(app: Sphinx, domain: str, objtype: str, content: Element, target_variables: dict = None) -> None:\n     \"\"\"Filter ``:meta:`` field from its docstring.\"\"\"\n     if domain != 'py':\n         return\ndiff --git a/sphinx/ext/autodoc/directive.py b/sphinx/ext/autodoc/directive.py\nindex 846a505..b2cf1d7 100644\n--- a/sphinx/ext/autodoc/directive.py\n+++ b/sphinx/ext/autodoc/directive.py\n@@ -143,7 +143,8 @@ class AutodocDirective(SphinxDirective):\n         # generate the output\n         params = DocumenterBridge(self.env, reporter, documenter_options, lineno, self.state)\n         documenter = doccls(params, self.arguments[0])\n-        documenter.generate(more_content=self.content)\n+        # Set 'skip' to False if ':meta public:' is present\n+        documenter.generate(more_content=self.content, no_skip=True)\n         if not params.result:\n             return []\n \n@@ -155,4 +156,4 @@ class AutodocDirective(SphinxDirective):\n             self.state.document.settings.record_dependencies.add(fn)\n \n         result = parse_generated_content(self.state, params.result, documenter)\n-        return result\n+        return result\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13878", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15976", "model_patch": "diff --git a/sympy/printing/mathml.py b/sympy/printing/mathml.py\nindex 85af872..403b399 100644\n--- a/sympy/printing/mathml.py\n+++ b/sympy/printing/mathml.py\n@@ -781,7 +781,7 @@ class MathMLPresentationPrinter(MathMLPrinterBase):\n         mname.appendChild(self.dom.createTextNode(name))\n         if len(supers) == 0:\n             if len(subs) == 0:\n-                x.appendChild(self.dom.createTextNode(name))\n+                x.appendChild(mname)\n             else:\n                 msub = self.dom.createElement('msub')\n                 msub.appendChild(mname)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9698", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex bcb7471..aaa0b4e 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -796,7 +796,7 @@ class PyMethod(PyObject):\n         if 'classmethod' in self.options:\n             return _('%s() (%s class method)') % (methname, clsname)\n         elif 'property' in self.options:\n-            return _('%s() (%s property)') % (methname, clsname)\n+            return _('%s (%s property)') % (methname, clsname)\n         elif 'staticmethod' in self.options:\n             return _('%s() (%s static method)') % (methname, clsname)\n         else:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-12489", "model_patch": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 007fa70..375fbef 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -924,13 +924,13 @@ class Permutation(Basic):\n         obj._size = size\n         return obj\n \n-    @staticmethod\n-    def _af_new(perm):\n+    @classmethod\n+    def _af_new(cls, perm):\n         \"\"\"A method to produce a Permutation object from a list;\n         the list is bound to the _array_form attribute, so it must\n         not be modified; this method is meant for internal use only;\n         the list ``a`` is supposed to be generated as a temporary value\n-        in a method, so p = Perm._af_new(a) is the only object\n+        in a method, so p = cls._af_new(a) is the only object\n         to hold a reference to ``a``::\n \n         Examples\n@@ -944,7 +944,7 @@ class Permutation(Basic):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13480", "model_patch": "diff --git a/sympy/functions/elementary/hyperbolic.py b/sympy/functions/elementary/hyperbolic.py\nindex d6c64f7..59a67af 100644\n--- a/sympy/functions/elementary/hyperbolic.py\n+++ b/sympy/functions/elementary/hyperbolic.py\n@@ -587,6 +587,7 @@ class coth(HyperbolicFunction):\n                 x, m = _peeloff_ipi(arg)\n                 if m:\n                     cothm = coth(m)\n+                    cotm = cot(m)\n                     if cotm is S.ComplexInfinity:\n                         return coth(x)\n                     else: # cothm == 0\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13798", "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex e32266f..e0c5940 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -156,11 +156,16 @@ class LatexPrinter(Printer):\n             \"times\": r\" \\times \"\n         }\n \n-        self._settings['mul_symbol_latex'] = \\\n-            mul_symbol_table[self._settings['mul_symbol']]\n+        if self._settings['mul_symbol'] in mul_symbol_table:\n+            self._settings['mul_symbol_latex'] = \\\n+                mul_symbol_table[self._settings['mul_symbol']]\n \n-        self._settings['mul_symbol_latex_numbers'] = \\\n-            mul_symbol_table[self._settings['mul_symbol'] or 'dot']\n+            self._settings['mul_symbol_latex_numbers'] = \\\n+                mul_symbol_table[self._settings['mul_symbol'] or 'dot']\n+        else:\n+            # Allow arbitrary LaTeX strings for mul_symbol\n+            self._settings['mul_symbol_latex'] = self._settings['mul_symbol']\n+            self._settings['mul_symbol_latex_numbers'] = self._settings['mul_symbol']\n \n         self._delim_dict = {'(': ')', '[': ']'}\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9367", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 8c0104e..c606597 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -149,10 +149,15 @@ def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Nod\n         elif isinstance(node, ast.Tuple):\n             if node.elts:\n                 result = []\n-                for elem in node.elts:\n-                    result.extend(unparse(elem))\n-                    result.append(addnodes.desc_sig_punctuation('', ', '))\n-                result.pop()\n+                if len(node.elts) == 1:\n+                    # Handle 1-element tuple specifically to include trailing comma\n+                    result.extend(unparse(node.elts[0]))\n+                    result.append(addnodes.desc_sig_punctuation('', ','))\n+                else:\n+                    for elem in node.elts:\n+                        result.extend(unparse(elem))\n+                        result.append(addnodes.desc_sig_punctuation('', ', '))\n+                    result.pop()\n             else:\n                 result = [addnodes.desc_sig_punctuation('', '('),\n                           addnodes.desc_sig_punctuation('', ')')]\ndiff --git a/sphinx/pycode/ast.py b/sphinx/pycode/ast.py\nindex 5db5a4a..3826193 100644\n--- a/sphinx/pycode/ast.py\n+++ b/sphinx/pycode/ast.py\n@@ -214,6 +214,9 @@ class _UnparseVisitor(ast.NodeVisitor):\n \n     def visit_Tuple(self, node: ast.Tuple) -> str:\n         if node.elts:\n+            # Ensure a trailing comma for 1-element tuples\n+            if len(node.elts) == 1:\n+                return \"(\" + self.visit(node.elts[0]) + \",)\"\n             return \"(\" + \", \".join(self.visit(e) for e in node.elts) + \")\"\n         else:\n             return \"()\"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9230", "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex ea465e6..c5011fd 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -436,7 +436,8 @@ class GoogleDocstring:\n                 if '`' in _type:\n                     field = '**%s** (%s)%s' % (_name, _type, separator)\n                 else:\n-                    field = '**%s** (*%s*)%s' % (_name, _type, separator)\n+                    # Ensure balanced parentheses in type strings like dict(str, str)\n+                    field = '**%s** (*%s*)%s' % (_name, _type.replace(',', ', '), separator)\n             else:\n                 field = '**%s**%s' % (_name, separator)\n         elif _type:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9658", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 4f93108..2adb26c 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -1406,6 +1406,11 @@ def builtin_resolver(app: Sphinx, env: BuildEnvironment,\n         if inspect.isclass(getattr(builtins, reftarget, None)):\n             # built-in class\n             return contnode\n+        elif hasattr(node, \"py:class\") and node[\"py:class\"]:\n+            # Resolve mocked class base properly\n+            modname = node.get(\"py:module\", \"\")\n+            clsname = node[\"py:class\"]\n+            return contnode.__class__(f\"{modname}.{clsname}\")\n         elif istyping(reftarget):\n             # typing class\n             return contnode\ndiff --git a/sphinx/ext/autodoc/mock.py b/sphinx/ext/autodoc/mock.py\nindex 281da6f..e13b129 100644\n--- a/sphinx/ext/autodoc/mock.py\n+++ b/sphinx/ext/autodoc/mock.py\n@@ -52,6 +52,9 @@ class _MockObject:\n         return iter([])\n \n     def __mro_entries__(self, bases: Tuple) -> Tuple:\n+        # Handle mocked class bases properly\n+        if self.__display_name__:\n+            return (type(self.__display_name__, bases, {}),)\n         return (self.__class__,)\n \n     def __getitem__(self, key: Any) -> \"_MockObject\":\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 4fd04da..3e5a111 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -183,6 +183,9 @@ def getmro(obj: Any) -> Tuple[Type, ...]:\n     __mro__ = safe_getattr(obj, '__mro__', None)\n     if isinstance(__mro__, tuple):\n         return __mro__\n+    elif hasattr(obj, \"__mro_entries__\"):\n+        # Mocked object resolution\n+        return tuple(obj.__mro_entries__(tuple()))\n     else:\n         return tuple()\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7748", "model_patch": "diff --git a/sphinx/util/docstrings.py b/sphinx/util/docstrings.py\nindex 65bd1aa..ba8c6cc 100644\n--- a/sphinx/util/docstrings.py\n+++ b/sphinx/util/docstrings.py\n@@ -61,6 +61,13 @@ def prepare_docstring(s: str, ignore: int = None, tabsize: int = 8) -> List[str]\n                       RemovedInSphinx50Warning, stacklevel=2)\n \n     lines = s.expandtabs(tabsize).splitlines()\n+    # Detect and separate any overloaded method signatures at the start of the docstring.\n+    if lines and lines[0].startswith('('):  # Check if the first line looks like a method signature\n+        signatures = []\n+        while lines and lines[0].startswith('('):  # Collect all signatures\n+            signatures.append(lines.pop(0))\n+        # Append all signatures as separate lines after processing the rest of the docstring.\n+        lines = signatures + [''] + lines\n     # Find minimum indentation of any non-blank lines after ignored lines.\n     margin = sys.maxsize\n     for line in lines[ignore:]:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8638", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex ec7a051..71bdc53 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -1184,9 +1184,14 @@ class PythonDomain(Domain):\n         modname = node.get('py:module')\n         clsname = node.get('py:class')\n         searchmode = 1 if node.hasattr('refspecific') else 0\n+        # Adjust find_obj to prioritize instance variables within the class context\n         matches = self.find_obj(env, modname, clsname, target,\n                                 type, searchmode)\n \n+        # Filter matches to ensure only local scope matches are prioritized\n+        if clsname:\n+            matches = [match for match in matches if match[0].startswith(f\"{modname}.{clsname}.\")]\n+\n         if not matches and type == 'attr':\n             # fallback to meth (for property)\n             matches = self.find_obj(env, modname, clsname, target, 'meth', searchmode)\n@@ -1194,7 +1199,9 @@ class PythonDomain(Domain):\n         if not matches:\n             return None\n         elif len(matches) > 1:\n-            logger.warning(__('more than one target found for cross-reference %r: %s'),\n+            # Log a warning but explicitly note unrelated cross-package matches\n+            logger.warning(__('more than one target found for cross-reference %r: %s. '\n+                              'Some matches may be unrelated cross-package references.'),\n                            target, ', '.join(match[0] for match in matches),\n                            type='ref', subtype='python', location=node)\n         name, obj = matches[0]\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13551", "model_patch": "diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py\nindex 65aca3f..5fbd2fc 100644\n--- a/sympy/concrete/products.py\n+++ b/sympy/concrete/products.py\n@@ -253,6 +253,16 @@ class Product(ExprWithIntLimits):\n \n         dif = n - a\n         if dif.is_Integer:\n+            if term.is_Add and term.has(Pow):\n+                # Special case for terms like `n + 1 / 2**k`\n+                base, exponent = None, None\n+                for t in term.args:\n+                    if t.is_Pow and t.base == S.Half:\n+                        base, exponent = t.base, t.exp\n+                if base is not None and exponent == -k:\n+                    from sympy import qPochhammer\n+                    sum_term = term - 1 / base**k\n+                    return qPochhammer(sum_term, base, dif + 1)\n             return Mul(*[term.subs(k, a + i) for i in range(dif + 1)])\n \n         elif term.is_polynomial(k):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-16792", "model_patch": "diff --git a/sympy/utilities/codegen.py b/sympy/utilities/codegen.py\nindex 9f5c4dd..1f56bfe 100644\n--- a/sympy/utilities/codegen.py\n+++ b/sympy/utilities/codegen.py\n@@ -910,7 +910,7 @@ class CCodeGen(CodeGen):\n         type_args = []\n         for arg in routine.arguments:\n             name = self.printer.doprint(arg.name)\n-            if arg.dimensions or isinstance(arg, ResultBase):\n+            if arg.dimensions or isinstance(arg, ResultBase) or isinstance(arg, MatrixSymbol):\n                 type_args.append((arg.get_datatype('C'), \"*%s\" % name))\n             else:\n                 type_args.append((arg.get_datatype('C'), name))\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13372", "model_patch": "diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py\nindex d47040b..c314605 100644\n--- a/sympy/core/evalf.py\n+++ b/sympy/core/evalf.py\n@@ -1301,12 +1301,16 @@ def evalf(x, prec, options):\n             elif re.is_number:\n                 re = re._to_mpmath(prec, allow_ints=False)._mpf_\n                 reprec = prec\n+            else:\n+                raise NotImplementedError\n             if im == 0:\n                 im = None\n                 imprec = None\n             elif im.is_number:\n                 im = im._to_mpmath(prec, allow_ints=False)._mpf_\n                 imprec = prec\n+            else:\n+                raise NotImplementedError\n             r = re, im, reprec, imprec\n         except AttributeError:\n             raise NotImplementedError\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-19346", "model_patch": "diff --git a/sympy/printing/repr.py b/sympy/printing/repr.py\nindex b3c364b..24cfeac 100644\n--- a/sympy/printing/repr.py\n+++ b/sympy/printing/repr.py\n@@ -30,6 +30,22 @@ class ReprPrinter(Printer):\n         \"\"\"\n         return sep.join([self.doprint(item) for item in args])\n \n+    def _print_dict(self, expr):\n+        \"\"\"\n+        Custom printer for dictionaries.\n+        \"\"\"\n+        items = []\n+        for key, value in expr.items():\n+            items.append(f\"{self.doprint(key)}: {self.doprint(value)}\")\n+        return \"{%s}\" % \", \".join(items)\n+\n+    def _print_set(self, expr):\n+        \"\"\"\n+        Custom printer for sets.\n+        \"\"\"\n+        items = [self.doprint(item) for item in sorted(expr, key=repr)]\n+        return \"{%s}\" % \", \".join(items)\n+\n     def emptyPrinter(self, expr):\n         \"\"\"\n         The fallback printer.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13647", "model_patch": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex fb4452b..5bfb0dd 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -86,7 +86,7 @@ class MatrixShaping(MatrixRequired):\n                 return self[i, j]\n             elif pos <= j < pos + other.cols:\n                 return other[i, j - pos]\n-            return self[i, j - pos - other.cols]\n+            return self[i, j - other.cols]\n \n         return self._new(self.rows, self.cols + other.cols,\n                          lambda i, j: entry(i, j))\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-12096", "model_patch": "diff --git a/sympy/core/function.py b/sympy/core/function.py\nindex 654774e..ef0f19b 100644\n--- a/sympy/core/function.py\n+++ b/sympy/core/function.py\n@@ -507,7 +507,10 @@ class Function(Application, Expr):\n             func = getattr(mpmath, fname)\n         except (AttributeError, KeyError):\n             try:\n-                return Float(self._imp_(*self.args), prec)\n+                result = self._imp_(*self.args)\n+                if isinstance(result, Expr):\n+                    return result.evalf(prec)\n+                return Float(result, prec)\n             except (AttributeError, TypeError, ValueError):\n                 return\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-18763", "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 675a3c4..ff754f7 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -703,7 +703,7 @@ class LatexPrinter(Printer):\n         latex_new = (self._print(e) for e in new)\n         latex_subs = r'\\\\ '.join(\n             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))\n-        return r'\\left. %s \\right|_{\\substack{ %s }}' % (latex_expr,\n+        return r'\\left. %s \\right|_{\\substack{ %s }}' % (self.parenthesize(expr, PRECEDENCE[\"Mul\"]),\n                                                          latex_subs)\n \n     def _print_Integral(self, expr):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-16450", "model_patch": "diff --git a/sympy/core/symbol.py b/sympy/core/symbol.py\nindex 9a1c686..a00aa1c 100644\n--- a/sympy/core/symbol.py\n+++ b/sympy/core/symbol.py\n@@ -177,7 +177,7 @@ class Symbol(AtomicExpr, Boolean):\n             raise ValueError(\n                 '%scommutativity must be True or False.' % whose)\n \n-        # sanitize other assumptions so 1 -> True and 0 -> False\n+        # Ensure that all relevant assumptions (finite, integer, rational, etc.) are preserved\n         for key in list(assumptions.keys()):\n             from collections import defaultdict\n             from sympy.utilities.exceptions import SymPyDeprecationWarning\n@@ -199,6 +199,13 @@ class Symbol(AtomicExpr, Boolean):\n                 continue\n             assumptions[key] = bool(v)\n \n+        # Explicitly propagate the 'finite' assumption if present\n+        if 'finite' in assumptions:\n+            assumptions['infinite'] = not assumptions['finite']\n+        else:\n+            assumptions['finite'] = None\n+            assumptions['infinite'] = None\n+\n     def __new__(cls, name, **assumptions):\n         \"\"\"Symbols are identified by name and assumptions::\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-18698", "model_patch": "diff --git a/sympy/polys/sqfreetools.py b/sympy/polys/sqfreetools.py\nindex fbdbcb2..f2007de 100644\n--- a/sympy/polys/sqfreetools.py\n+++ b/sympy/polys/sqfreetools.py\n@@ -328,7 +328,13 @@ def dup_sqf_list(f, K, all=False):\n         g, p, q = dup_inner_gcd(p, h, K)\n \n         if all or dup_degree(g) > 0:\n-            result.append((g, i))\n+            # Group factors with the same multiplicity correctly\n+            if result and result[-1][1] == i:\n+                # Combine with last factor if multiplicities match\n+                combined = dup_mul(result[-1][0], g, K)\n+                result[-1] = (combined, i)\n+            else:\n+                result.append((g, i))\n \n         i += 1\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15349", "model_patch": "diff --git a/sympy/algebras/quaternion.py b/sympy/algebras/quaternion.py\nindex 091da2d..cbe5689 100644\n--- a/sympy/algebras/quaternion.py\n+++ b/sympy/algebras/quaternion.py\n@@ -529,10 +529,10 @@ class Quaternion(Expr):\n \n         m10 = 2*s*(q.b*q.c + q.d*q.a)\n         m11 = 1 - 2*s*(q.b**2 + q.d**2)\n-        m12 = 2*s*(q.c*q.d + q.b*q.a)\n+        m12 = 2*s*(q.c*q.d - q.b*q.a)\n \n         m20 = 2*s*(q.b*q.d - q.c*q.a)\n-        m21 = 2*s*(q.c*q.d + q.b*q.a)\n+        m21 = 2*s*(q.c*q.d - q.b*q.a)\n         m22 = 1 - 2*s*(q.b**2 + q.c**2)\n \n         if not v:\n@@ -548,4 +548,4 @@ class Quaternion(Expr):\n             m33 = 1\n \n             return Matrix([[m00, m01, m02, m03], [m10, m11, m12, m13],\n-                          [m20, m21, m22, m23], [m30, m31, m32, m33]])\n+                          [m20, m21, m22, m23], [m30, m31, m32, m33]])\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9602", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex fbfe7b9..f21638a 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -179,7 +179,7 @@ def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Nod\n         tree = ast_parse(annotation)\n         result = unparse(tree)\n         for i, node in enumerate(result):\n-            if isinstance(node, nodes.Text) and node.strip():\n+            if isinstance(node, nodes.Text) and node.strip() and not node.strip() in ('True', 'False', 'None'):\n                 result[i] = type_to_xref(str(node), env)\n         return result\n     except SyntaxError:\ndiff --git a/sphinx/util/typing.py b/sphinx/util/typing.py\nindex 1be1286..1a60aaf 100644\n--- a/sphinx/util/typing.py\n+++ b/sphinx/util/typing.py\n@@ -381,7 +381,7 @@ def _stringify_py37(annotation: Any) -> str:\n             returns = stringify(annotation.__args__[-1])\n             return '%s[[%s], %s]' % (qualname, args, returns)\n         elif qualname == 'Literal':\n-            args = ', '.join(repr(a) for a in annotation.__args__)\n+            args = ', '.join(str(a) if isinstance(a, (int, float, str, bool)) else repr(a) for a in annotation.__args__)\n             return '%s[%s]' % (qualname, args)\n         elif str(annotation).startswith('typing.Annotated'):  # for py39+\n             return stringify(annotation.__args__[0])\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13757", "model_patch": "diff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex c4501f6..6db13e7 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -4049,11 +4049,16 @@ class Poly(Expr):\n \n     @_sympifyit('g', NotImplemented)\n     def __rmul__(f, g):\n+        from sympy.core.expr import Expr\n+\n+        if isinstance(g, Expr):\n+            return g * f.as_expr()\n+\n         if not g.is_Poly:\n             try:\n                 g = f.__class__(g, *f.gens)\n             except PolynomialError:\n-                return g*f.as_expr()\n+                return g * f.as_expr()\n \n         return g.mul(f)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-20154", "model_patch": "diff --git a/sympy/utilities/iterables.py b/sympy/utilities/iterables.py\nindex aef37ab..9f6e1bb 100644\n--- a/sympy/utilities/iterables.py\n+++ b/sympy/utilities/iterables.py\n@@ -1802,9 +1802,9 @@ def partitions(n, m=None, k=None, size=False):\n         keys.append(r)\n     room = m - q - bool(r)\n     if size:\n-        yield sum(ms.values()), ms\n+        yield sum(ms.values()), ms.copy()\n     else:\n-        yield ms\n+        yield ms.copy()\n \n     while keys != [1]:\n         # Reuse any 1's.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9673", "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex ea465e6..86efcdc 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -776,8 +776,9 @@ class GoogleDocstring:\n \n         lines: List[str] = []\n         for _name, _type, _desc in fields:\n-            if use_rtype:\n-                field = self._format_field(_name, '', _desc)\n+            if use_rtype or self._config.autodoc_typehints_description_target == \"documented\":\n+                full_desc = _desc if not _type else f\"{_desc} ({_type})\".strip()\n+                field = self._format_field(_name, '', full_desc)\n             else:\n                 field = self._format_field(_name, _type, _desc)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13852", "model_patch": "diff --git a/sympy/functions/special/zeta_functions.py b/sympy/functions/special/zeta_functions.py\nindex b3765de..9475fd4 100644\n--- a/sympy/functions/special/zeta_functions.py\n+++ b/sympy/functions/special/zeta_functions.py\n@@ -291,7 +291,7 @@ class polylog(Function):\n         from sympy import log, expand_mul, Dummy, exp_polar, I\n         s, z = self.args\n         if s == 1:\n-            return -log(1 + exp_polar(-I*pi)*z)\n+            return -log(1 - z)\n         if s.is_Integer and s <= 0:\n             u = Dummy('u')\n             start = u/(1 - u)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-14531", "model_patch": "diff --git a/sympy/printing/str.py b/sympy/printing/str.py\nindex 2f140fa..5d76ab2 100644\n--- a/sympy/printing/str.py\n+++ b/sympy/printing/str.py\n@@ -216,9 +216,9 @@ class StrPrinter(Printer):\n     def _print_Limit(self, expr):\n         e, z, z0, dir = expr.args\n         if str(dir) == \"+\":\n-            return \"Limit(%s, %s, %s)\" % (e, z, z0)\n+            return \"Limit(%s, %s, %s)\" % (self._print(e), self._print(z), self._print(z0))\n         else:\n-            return \"Limit(%s, %s, %s, dir='%s')\" % (e, z, z0, dir)\n+            return \"Limit(%s, %s, %s, dir='%s')\" % (self._print(e), self._print(z), self._print(z0), dir)\n \n     def _print_list(self, expr):\n         return \"[%s]\" % self.stringify(expr, \", \")\n@@ -630,7 +630,7 @@ class StrPrinter(Printer):\n         }\n \n         if expr.rel_op in charmap:\n-            return '%s(%s, %s)' % (charmap[expr.rel_op], expr.lhs, expr.rhs)\n+            return '%s(%s, %s)' % (charmap[expr.rel_op], self._print(expr.lhs), self._print(expr.rhs))\n \n         return '%s %s %s' % (self.parenthesize(expr.lhs, precedence(expr)),\n                            self._relationals.get(expr.rel_op) or expr.rel_op,\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15809", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-23413", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13615", "model_patch": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex e78d679..847d159 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -1957,15 +1957,26 @@ class FiniteSet(Set, EvalfMixin):\n                 c = sympify(other.contains(i))\n                 if c is not S.true and c is not S.false:\n                     unk.append(i)\n-            unk = FiniteSet(*unk)\n-            if unk == self:\n-                return\n+            unk = FiniteSet(*unk)  # Symbols that are not definitively in or out of 'other'\n+            nums = [m for m in self.args if m.is_number]  # Numbers in the current set\n             not_true = []\n-            for i in other:\n+            for i in other:  # Elements of 'other' not definitely in the current set\n                 c = sympify(self.contains(i))\n                 if c is not S.true:\n                     not_true.append(i)\n-            return Complement(FiniteSet(*not_true), unk)\n+\n+            num_complement = Complement(FiniteSet(*not_true), unk)  # Complement for known numbers\n+            if nums:\n+                intervals = Interval(S.NegativeInfinity, S.Infinity).complement(FiniteSet(*nums))\n+                if unk:\n+                    return Complement(Union(intervals, FiniteSet(*not_true)), unk)\n+                else:\n+                    return Union(intervals, FiniteSet(*not_true))\n+\n+            if unk:\n+                return Complement(FiniteSet(*not_true), unk)\n+            else:\n+                return FiniteSet(*not_true)\n \n         return Set._complement(self, other)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-18211", "model_patch": "diff --git a/sympy/solvers/solveset.py b/sympy/solvers/solveset.py\nindex e1103b7..0a9478a 100644\n--- a/sympy/solvers/solveset.py\n+++ b/sympy/solvers/solveset.py\n@@ -567,7 +567,7 @@ def _solve_trig1(f, symbol, domain):\n \n     solns = solveset_complex(g, y) - solveset_complex(h, y)\n     if isinstance(solns, ConditionSet):\n-        raise NotImplementedError\n+        return ConditionSet(symbol, Eq(f_original, 0), domain)\n \n     if isinstance(solns, FiniteSet):\n         if any(isinstance(s, RootOf) for s in solns):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-23824", "model_patch": "diff --git a/sympy/physics/hep/gamma_matrices.py b/sympy/physics/hep/gamma_matrices.py\nindex 8ce17be..bf43fac 100644\n--- a/sympy/physics/hep/gamma_matrices.py\n+++ b/sympy/physics/hep/gamma_matrices.py\n@@ -694,7 +694,7 @@ def kahane_simplify(expression):\n \n     # If `first_dum_pos` is not zero, it means that there are trailing free gamma\n     # matrices in front of `expression`, so multiply by them:\n-    for i in range(0, first_dum_pos):\n+    for i in range(first_dum_pos - 1, -1, -1):\n         [ri.insert(0, free_pos[i]) for ri in resulting_indices]\n \n     resulting_expr = S.Zero\n@@ -714,4 +714,4 @@ def kahane_simplify(expression):\n         pass\n     else:\n         t = eye(4)*t\n-    return t\n+    return t\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-12481", "model_patch": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 4042fdb..81137a9 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -895,12 +895,13 @@ class Permutation(Basic):\n         # counting starts from 1.\n \n         temp = flatten(args)\n-        if has_dups(temp):\n-            if is_cycle:\n-                raise ValueError('there were repeated elements; to resolve '\n-                'cycles use Cycle%s.' % ''.join([str(tuple(c)) for c in args]))\n-            else:\n-                raise ValueError('there were repeated elements.')\n+        if has_dups(temp) and is_cycle:\n+            c = Cycle()\n+            for ci in args:\n+                c = c(*ci)  # Apply cycles in left-to-right order.\n+            aform = c.list()\n+        elif has_dups(temp):\n+            raise ValueError('there were repeated elements.')\n         temp = set(temp)\n \n         if not is_cycle and \\\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9461", "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 00b90de..cbdbfd5 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2140,6 +2140,18 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n     def document_members(self, all_members: bool = False) -> None:\n         pass\n \n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        \"\"\"Override to handle classmethod-property hybrids.\"\"\"\n+        if isinstance(self.object, classmethod) and isinstance(self.object.__func__, property):\n+            docstring = getdoc(self.object.__func__, self.get_attr,\n+                               self.config.autodoc_inherit_docstrings,\n+                               self.parent, self.object_name)\n+            if docstring:\n+                tab_width = self.directive.state.document.settings.tab_width\n+                return [prepare_docstring(docstring, tabsize=tab_width)]\n+        else:\n+            return super().get_doc(ignore)\n+\n     def format_signature(self, **kwargs: Any) -> str:\n         sigs = []\n         if (self.analyzer and\n@@ -2510,6 +2522,18 @@ class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type:\n     def document_members(self, all_members: bool = False) -> None:\n         pass\n \n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        \"\"\"Override to handle classmethod-property hybrids.\"\"\"\n+        if isinstance(self.object, classmethod) and isinstance(self.object.__func__, property):\n+            docstring = getdoc(self.object.__func__, self.get_attr,\n+                               self.config.autodoc_inherit_docstrings,\n+                               self.parent, self.object_name)\n+            if docstring:\n+                tab_width = self.directive.state.document.settings.tab_width\n+                return [prepare_docstring(docstring, tabsize=tab_width)]\n+        else:\n+            return super().get_doc(ignore)\n+\n     def isinstanceattribute(self) -> bool:\n         \"\"\"Check the subject is an instance attribute.\"\"\"\n         warnings.warn('AttributeDocumenter.isinstanceattribute() is deprecated.',\n@@ -2649,6 +2673,9 @@ class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type:\n \n \n class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n+    \"\"\"\n+    Specialized Documenter subclass for properties and classmethod-property hybrids.\n+    \"\"\"\n     \"\"\"\n     Specialized Documenter subclass for properties.\n     \"\"\"\n@@ -2666,6 +2693,18 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n     def document_members(self, all_members: bool = False) -> None:\n         pass\n \n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        \"\"\"Override to handle classmethod-property hybrids.\"\"\"\n+        if isinstance(self.object, classmethod) and isinstance(self.object.__func__, property):\n+            docstring = getdoc(self.object.__func__, self.get_attr,\n+                               self.config.autodoc_inherit_docstrings,\n+                               self.parent, self.object_name)\n+            if docstring:\n+                tab_width = self.directive.state.document.settings.tab_width\n+                return [prepare_docstring(docstring, tabsize=tab_width)]\n+        else:\n+            return super().get_doc(ignore)\n+\n     def get_real_modname(self) -> str:\n         real_modname = self.get_attr(self.parent or self.object, '__module__', None)\n         return real_modname or self.modname\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 9e39b23..a80927d 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -384,7 +384,9 @@ def iscoroutinefunction(obj: Any) -> bool:\n \n \n def isproperty(obj: Any) -> bool:\n-    \"\"\"Check if the object is property.\"\"\"\n+    \"\"\"Check if the object is property or a classmethod-property hybrid.\"\"\"\n+    if isinstance(obj, classmethod) and isinstance(obj.__func__, property):\n+        return True\n     if sys.version_info >= (3, 8):\n         from functools import cached_property  # cached_property is available since py3.8\n         if isinstance(obj, cached_property):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13877", "model_patch": "diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex 3216a40..482e519 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -185,6 +185,9 @@ class MatrixDeterminant(MatrixCommon):\n         # Recursively implemented Bareiss' algorithm as per Deanna Richelle Leggett's\n         # thesis http://www.math.usm.edu/perry/Research/Thesis_DRL.pdf\n         def bareiss(mat, cumm=1):\n+            # Check for symbolic entries in the matrix\n+            if any(entry.has(Symbol) for entry in mat):\n+                raise ValueError(\"Bareiss algorithm is not suitable for matrices containing symbolic entries.\")\n             if mat.rows == 0:\n                 return S.One\n             elif mat.rows == 1:\n@@ -213,7 +216,11 @@ class MatrixDeterminant(MatrixCommon):\n \n             return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)\n \n-        return cancel(bareiss(self))\n+        try:\n+            return cancel(bareiss(self))\n+        except ValueError:\n+            # Fall back to Berkowitz algorithm if Bareiss is not applicable\n+            return self._eval_det_berkowitz()\n \n     def _eval_det_berkowitz(self):\n         \"\"\" Use the Berkowitz algorithm to compute the determinant.\"\"\"\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-20916", "model_patch": "diff --git a/sympy/printing/pretty/pretty_symbology.py b/sympy/printing/pretty/pretty_symbology.py\nindex c7b65c7..9e0f2d3 100644\n--- a/sympy/printing/pretty/pretty_symbology.py\n+++ b/sympy/printing/pretty/pretty_symbology.py\n@@ -556,7 +556,7 @@ def pretty_symbol(symb_name, bold_name=False):\n     # glue the results into one string\n     if pretty_subs is None:  # nice formatting of sups/subs did not work\n         if subs:\n-            name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n+            name += '_'+'_'.join([sub.get(s, translate(s, bold_name)) for s in subs])\n         if sups:\n             name += '__'+'__'.join([translate(s, bold_name) for s in sups])\n         return name\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-18189", "model_patch": "diff --git a/sympy/solvers/diophantine.py b/sympy/solvers/diophantine.py\nindex b9f5e3f..25ef604 100644\n--- a/sympy/solvers/diophantine.py\n+++ b/sympy/solvers/diophantine.py\n@@ -181,8 +181,11 @@ def diophantine(eq, param=symbols(\"t\", integer=True), syms=None,\n             syms = [i for i in syms if i in var]\n             if syms != var:\n                 dict_sym_index = dict(zip(syms, range(len(syms))))\n-                return {tuple([t[dict_sym_index[i]] for i in var])\n-                            for t in diophantine(eq, param)}\n+                solutions = diophantine(eq, param)\n+                if permute:\n+                    solutions = {tuple([t[dict_sym_index[i]] for i in var]) for t in solutions}\n+                    return {tuple([s[dict_sym_index[i]] for i in var]) for s in solutions}\n+                return {tuple([t[dict_sym_index[i]] for i in var]) for t in solutions}\n         n, d = eq.as_numer_denom()\n         if n.is_number:\n             return set()\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-18199", "model_patch": "diff --git a/sympy/polys/polyroots.py b/sympy/polys/polyroots.py\nindex abaffad..0af0c80 100644\n--- a/sympy/polys/polyroots.py\n+++ b/sympy/polys/polyroots.py\n@@ -967,7 +967,7 @@ def roots(f, *gens, **flags):\n     (k,), f = f.terms_gcd()\n \n     if not k:\n-        zeros = {}\n+        zeros = {S.Zero: 1}\n     else:\n         zeros = {S.Zero: k}\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15875", "model_patch": "diff --git a/sympy/core/add.py b/sympy/core/add.py\nindex 1046af8..0b35f8a 100644\n--- a/sympy/core/add.py\n+++ b/sympy/core/add.py\n@@ -561,7 +561,7 @@ class Add(Expr, AssocOp):\n             if not im_or_z and not im:\n                 return True\n             if im and not im_or_z:\n-                return False\n+                return None\n         if b.is_zero is False:\n             return False\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15599", "model_patch": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex a9cb773..4ea630e 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -123,9 +123,10 @@ class Mod(Function):\n             for arg in p.args:\n                 both_l[isinstance(arg, cls)].append(arg)\n \n-            if mod_l and all(inner.args[1] == q for inner in mod_l):\n-                # finding distributive term\n-                non_mod_l = [cls(x, q) for x in non_mod_l]\n+            was = non_mod_l[:]\n+            non_mod_l = [cls(x, q) for x in non_mod_l]\n+            changed = was != non_mod_l\n+            if changed or mod_l and all(inner.args[1] == q for inner in mod_l):\n                 mod = []\n                 non_mod = []\n                 for j in non_mod_l:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-22914", "model_patch": "diff --git a/sympy/printing/codeprinter.py b/sympy/printing/codeprinter.py\nindex 971a180..8e91562 100644\n--- a/sympy/printing/codeprinter.py\n+++ b/sympy/printing/codeprinter.py\n@@ -568,6 +568,12 @@ class CodePrinter(StrPrinter):\n     # The following can not be simply translated into C or Fortran\n     _print_Basic = _print_not_supported\n     _print_ComplexInfinity = _print_not_supported\n+\n+    def _print_Min(self, expr):\n+        return \"min({})\".format(\", \".join(self._print(arg) for arg in expr.args))\n+\n+    def _print_Max(self, expr):\n+        return \"max({})\".format(\", \".join(self._print(arg) for arg in expr.args))\n     _print_Derivative = _print_not_supported\n     _print_ExprCondPair = _print_not_supported\n     _print_GeometryEntity = _print_not_supported\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-14976", "model_patch": "diff --git a/sympy/utilities/lambdify.py b/sympy/utilities/lambdify.py\nindex 48d6783..d073316 100644\n--- a/sympy/utilities/lambdify.py\n+++ b/sympy/utilities/lambdify.py\n@@ -660,6 +660,10 @@ class _EvaluatorPrinter(object):\n         if not iterable(args):\n             args = [args]\n \n+        from sympy import Float\n+        if self.module == 'mpmath':\n+            from mpmath import mpf\n+            expr = expr.xreplace({r: Float(r).evalf() for r in expr.atoms(Rational)})\n         argstrs, expr = self._preprocess(args, expr)\n \n         # Generate argument unpacking and final argument list\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24213", "model_patch": "diff --git a/sympy/physics/units/unitsystem.py b/sympy/physics/units/unitsystem.py\nindex f6b73be..5705c82 100644\n--- a/sympy/physics/units/unitsystem.py\n+++ b/sympy/physics/units/unitsystem.py\n@@ -175,7 +175,7 @@ class UnitSystem(_QuantityMapper):\n             for addend in expr.args[1:]:\n                 addend_factor, addend_dim = \\\n                     self._collect_factor_and_dimension(addend)\n-                if dim != addend_dim:\n+                if not self.get_dimension_system().equivalent_dims(dim, addend_dim):\n                     raise ValueError(\n                         'Dimension of \"{}\" is {}, '\n                         'but it should be {}'.format(\n@@ -202,4 +202,4 @@ class UnitSystem(_QuantityMapper):\n         \"\"\"\n         Return the units of the system that do not have a prefix.\n         \"\"\"\n-        return set(filter(lambda u: not u.is_prefixed and not u.is_physical_constant, self._units))\n+        return set(filter(lambda u: not u.is_prefixed and not u.is_physical_constant, self._units))\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-17630", "model_patch": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 5a4ea29..2238cc0 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -164,7 +164,14 @@ class BlockMatrix(MatrixExpr):\n     def _blockmul(self, other):\n         if (isinstance(other, BlockMatrix) and\n                 self.colblocksizes == other.rowblocksizes):\n-            return BlockMatrix(self.blocks*other.blocks)\n+            result_blocks = self.blocks * other.blocks\n+            for i in range(result_blocks.rows):\n+                for j in range(result_blocks.cols):\n+                    if result_blocks[i, j] == S.Zero:\n+                        result_blocks[i, j] = ZeroMatrix(\n+                            self.blocks[i, 0].rows, other.blocks[0, j].cols\n+                        )\n+            return BlockMatrix(result_blocks)\n \n         return self * other\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-17139", "model_patch": "diff --git a/sympy/simplify/fu.py b/sympy/simplify/fu.py\nindex 0cdedc1..f0bc8a9 100644\n--- a/sympy/simplify/fu.py\n+++ b/sympy/simplify/fu.py\n@@ -501,9 +501,9 @@ def _TR56(rv, f, g, h, max, pow):\n         if not (rv.is_Pow and rv.base.func == f):\n             return rv\n \n-        if (rv.exp < 0) == True:\n+        if rv.exp.is_real and (rv.exp < 0) == True:\n             return rv\n-        if (rv.exp > max) == True:\n+        if rv.exp.is_real and (rv.exp > max) == True:\n             return rv\n         if rv.exp == 2:\n             return h(g(rv.base.args[0])**2)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-19783", "model_patch": "diff --git a/sympy/physics/quantum/operator.py b/sympy/physics/quantum/operator.py\nindex 9e9a129..ac4b65f 100644\n--- a/sympy/physics/quantum/operator.py\n+++ b/sympy/physics/quantum/operator.py\n@@ -179,6 +179,8 @@ class Operator(QExpr):\n     def __mul__(self, other):\n \n         if isinstance(other, IdentityOperator):\n+            if isinstance(self, Dagger):\n+                return self\n             return self\n \n         return Mul(self, other)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-19637", "model_patch": "diff --git a/sympy/core/sympify.py b/sympy/core/sympify.py\nindex fe0315b..faf5b3d 100644\n--- a/sympy/core/sympify.py\n+++ b/sympy/core/sympify.py\n@@ -513,6 +513,7 @@ def kernS(s):\n             while kern in s:\n                 kern += choice(string.ascii_letters + string.digits)\n             s = s.replace(' ', kern)\n+        kern = None\n         hit = kern in s\n \n     for i in range(2):\n@@ -542,4 +543,4 @@ def kernS(s):\n \n \n # Avoid circular import\n-from .basic import Basic\n+from .basic import Basic\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-20438", "model_patch": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex d2cbd5e..57d36e2 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -392,6 +392,13 @@ class Set(Basic):\n         # XXX: We shouldn't do this. A query like this should be handled\n         # without evaluating new Set objects. It should be the other way round\n         # so that the intersect method uses is_subset for evaluation.\n+        if isinstance(self, ProductSet) and isinstance(other, FiniteSet):\n+            # Check if every element of the FiniteSet is also in the ProductSet\n+            for elem in other:\n+                if not self.contains(elem):\n+                    return False\n+            return True\n+\n         if self.intersect(other) == self:\n             return True\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24539", "model_patch": "diff --git a/sympy/polys/rings.py b/sympy/polys/rings.py\nindex 8995407..ac6b93c 100644\n--- a/sympy/polys/rings.py\n+++ b/sympy/polys/rings.py\n@@ -618,7 +618,7 @@ class PolyElement(DomainElement, DefaultPrinting, CantSympify, dict):\n     def as_expr(self, *symbols):\n         if symbols and len(symbols) != self.ring.ngens:\n             raise ValueError(\"not enough symbols, expected %s got %s\" % (self.ring.ngens, len(symbols)))\n-        else:\n+        if not symbols:\n             symbols = self.ring.symbols\n \n         return expr_from_dict(self.as_expr_dict(), *symbols)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-12419", "model_patch": "diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex b7978a4..182676e 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -1362,8 +1362,7 @@ class MatrixOperations(MatrixRequired):\n \n     def trace(self):\n         \"\"\"\n-        Returns the trace of a square matrix i.e. the sum of the\n-        diagonal elements.\n+        Returns the sum of the diagonal elements of a square matrix.\n \n         Examples\n         ========\n@@ -1378,6 +1377,26 @@ class MatrixOperations(MatrixRequired):\n             raise NonSquareMatrixError()\n         return self._eval_trace()\n \n+    def total_sum(self):\n+        \"\"\"\n+        Returns the total sum of all elements in the matrix. For special matrices\n+        like the identity matrix, this method ensures correct symbolic evaluation.\n+\n+        Examples\n+        ========\n+\n+        >>> from sympy import Matrix, eye\n+        >>> A = Matrix(2, 2, [1, 2, 3, 4])\n+        >>> A.total_sum()\n+        10\n+\n+        >>> I = eye(3)\n+        >>> I.total_sum()\n+        3\n+\n+        \"\"\"\n+        return sum(self[i, j] for i in range(self.rows) for j in range(self.cols))\n+\n     def transpose(self):\n         \"\"\"\n         Returns the transpose of the matrix.\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24443", "model_patch": "diff --git a/sympy/combinatorics/homomorphisms.py b/sympy/combinatorics/homomorphisms.py\nindex 0a601d4..fc76113 100644\n--- a/sympy/combinatorics/homomorphisms.py\n+++ b/sympy/combinatorics/homomorphisms.py\n@@ -333,7 +333,7 @@ def _check_homomorphism(domain, codomain, images):\n             # both indices\n             while i < len(r):\n                 power = r_arr[j][1]\n-                if isinstance(domain, PermutationGroup) and r[i] in gens:\n+                if isinstance(domain, PermutationGroup) and (r[i] in gens or r[i]**-1 in gens):\n                     s = domain.generators[gens.index(r[i])]\n                 else:\n                     s = r[i]\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-21930", "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 6e027b7..807a345 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -1582,7 +1582,7 @@ class LatexPrinter(Printer):\n \n         # glue all items together:\n         if supers:\n-            name += \"^{%s}\" % \" \".join(supers)\n+            name += \"^{%s}\" % \"\".join([\"{%s}\" % sup for sup in supers])\n         if subs:\n             name += \"_{%s}\" % \" \".join(subs)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-17318", "model_patch": "diff --git a/sympy/simplify/radsimp.py b/sympy/simplify/radsimp.py\nindex a31ce02..f0eba6c 100644\n--- a/sympy/simplify/radsimp.py\n+++ b/sympy/simplify/radsimp.py\n@@ -1077,6 +1077,8 @@ def split_surds(expr):\n     coeff_muls = [x.as_coeff_Mul() for x in args]\n     surds = [x[1]**2 for x in coeff_muls if x[1].is_Pow]\n     surds.sort(key=default_sort_key)\n+    if not surds:\n+        return S.One, S.Zero, expr  # Handle empty surds case\n     g, b1, b2 = _split_gcd(*surds)\n     g2 = g\n     if not b2 and len(b1) >= 2:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-21612", "model_patch": "diff --git a/sympy/parsing/latex/_parse_latex_antlr.py b/sympy/parsing/latex/_parse_latex_antlr.py\nindex 67c729c..cc7f529 100644\n--- a/sympy/parsing/latex/_parse_latex_antlr.py\n+++ b/sympy/parsing/latex/_parse_latex_antlr.py\n@@ -384,9 +384,9 @@ def convert_frac(frac):\n     expr_bot = convert_expr(frac.lower)\n     inverse_denom = sympy.Pow(expr_bot, -1, evaluate=False)\n     if expr_top == 1:\n-        return inverse_denom\n+        return sympy.Pow(expr_bot, -1, evaluate=False)\n     else:\n-        return sympy.Mul(expr_top, inverse_denom, evaluate=False)\n+        return sympy.Mul(expr_top, sympy.Pow(expr_bot, -1, evaluate=False), evaluate=False)\n \n def convert_binom(binom):\n     expr_n = convert_expr(binom.n)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-14248", "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex d02494c..23afcb9 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -310,8 +310,9 @@ class LatexPrinter(Printer):\n             if i == 0:\n                 pass\n             elif _coeff_isneg(term):\n-                tex += \" - \"\n-                term = -term\n+                term_tex = self._print(-term)\n+                tex += \" - \" + term_tex\n+                continue\n             else:\n                 tex += \" + \"\n             term_tex = self._print(term)\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 41521ad..c15ff63 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1438,8 +1438,8 @@ class PrettyPrinter(Printer):\n \n         for i, term in enumerate(terms):\n             if term.is_Mul and _coeff_isneg(term):\n-                coeff, other = term.as_coeff_mul(rational=False)\n-                pform = self._print(Mul(-coeff, *other, evaluate=False))\n+                coeff, factors = term.as_coeff_mul(rational=False)\n+                pform = self._print(Mul(-coeff, *factors, evaluate=False))\n                 pforms.append(pretty_negative(pform, i))\n             elif term.is_Rational and term.q > 1:\n                 pforms.append(None)\ndiff --git a/sympy/printing/str.py b/sympy/printing/str.py\nindex 29d16bd..7870145 100644\n--- a/sympy/printing/str.py\n+++ b/sympy/printing/str.py\n@@ -56,9 +56,11 @@ class StrPrinter(Printer):\n         l = []\n         for term in terms:\n             t = self._print(term)\n-            if t.startswith('-'):\n-                sign = \"-\"\n-                t = t[1:]\n+            if term.is_Mul and _coeff_isneg(term):\n+                coeff, other = term.as_coeff_mul(rational=False)\n+                l.append(\"-\")\n+                l.append(self._print(Mul(-coeff, *other, evaluate=False)))\n+                continue\n             else:\n                 sign = \"+\"\n             if precedence(term) < PREC:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-17655", "model_patch": "diff --git a/sympy/geometry/point.py b/sympy/geometry/point.py\nindex a708f18..f75a37e 100644\n--- a/sympy/geometry/point.py\n+++ b/sympy/geometry/point.py\n@@ -213,6 +213,20 @@ class Point(GeometryEntity):\n         sympy.geometry.point.Point.translate\n \n         \"\"\"\n+        from sympy.core.mul import Mul\n+        from sympy.core.expr import Expr\n+\n+        if isinstance(other, Mul):\n+            # Handle scalar multiplication like 2.0 * Point2D(1, 1)\n+            scalar, pt = None, None\n+            for arg in other.args:\n+                if isinstance(arg, Expr) and scalar is None:\n+                    scalar = arg\n+                elif isinstance(arg, Point) and pt is None:\n+                    pt = arg\n+            if scalar is not None and pt is not None:\n+                other = Point([scalar * coord for coord in pt.args], evaluate=False)\n+\n         try:\n             s, o = Point._normalize_dimension(self, Point(other, evaluate=False))\n         except TypeError:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24661", "model_patch": "diff --git a/sympy/core/relational.py b/sympy/core/relational.py\nindex c35b72b..77774f5 100644\n--- a/sympy/core/relational.py\n+++ b/sympy/core/relational.py\n@@ -173,7 +173,7 @@ class Relational(Boolean, EvalfMixin):\n                     real expressions.\n                 '''))\n \n-        return cls(lhs, rhs, **assumptions)\n+        return cls(lhs, rhs, evaluate=assumptions.pop('evaluate', True), **assumptions)\n \n     @property\n     def lhs(self):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-21379", "model_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex 229596e..300451d 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -1032,7 +1032,11 @@ class Basic(Printable, metaclass=ManagedProperties):\n             for i, arg in enumerate(args):\n                 if not hasattr(arg, '_eval_subs'):\n                     continue\n-                arg = arg._subs(old, new, **hints)\n+                # Handle Piecewise separately to avoid triggering errors\n+                if isinstance(arg, Piecewise):\n+                    arg = arg.xreplace({old: new})\n+                else:\n+                    arg = arg._subs(old, new, **hints)\n                 if not _aresame(arg, args[i]):\n                     hit = True\n                     args[i] = arg\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-23262", "model_patch": "diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex 9b53255..c041b66 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -308,6 +308,8 @@ class AbstractPythonCodePrinter(CodePrinter):\n \n     def _print_Return(self, ret):\n         arg, = ret.args\n+        if isinstance(arg, tuple) and len(arg) == 1:\n+            return 'return (%s,)' % self._print(arg[0])\n         return 'return %s' % self._print(arg)\n \n     def _print_Print(self, prnt):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-19040", "model_patch": "diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py\nindex 39972e2..d21a64f 100644\n--- a/sympy/polys/factortools.py\n+++ b/sympy/polys/factortools.py\n@@ -1132,7 +1132,8 @@ def dup_ext_factor(f, K):\n         factors[i] = h\n \n     factors = dup_trial_division(F, factors, K)\n-    return lc, factors\n+    # Ensure all factors are returned even if improperly filtered\n+    return lc, [f for f in factors if not dmp_zero_p(f, u, K)]\n \n \n def dmp_ext_factor(f, u, K):\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-23950", "model_patch": "diff --git a/sympy/sets/contains.py b/sympy/sets/contains.py\nindex 0b1e933..bed3ef3 100644\n--- a/sympy/sets/contains.py\n+++ b/sympy/sets/contains.py\n@@ -45,4 +45,8 @@ class Contains(BooleanFunction):\n             isinstance(i, (Eq, Ne))])\n \n     def as_set(self):\n-        raise NotImplementedError()\n+        \"\"\"\n+        Return the set for which this 'Contains' condition is defined.\n+        For example, Contains(x, Reals).as_set() should return Reals.\n+        \"\"\"\n+        return self.args[1]\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13974", "model_patch": "diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py\nindex 153c783..ba2e64c 100644\n--- a/sympy/physics/quantum/tensorproduct.py\n+++ b/sympy/physics/quantum/tensorproduct.py\n@@ -382,7 +382,13 @@ def tensor_product_simp(e, **hints):\n     if isinstance(e, Add):\n         return Add(*[tensor_product_simp(arg) for arg in e.args])\n     elif isinstance(e, Pow):\n-        return tensor_product_simp(e.base) ** e.exp\n+        base = e.base\n+        exp = e.exp\n+        if isinstance(base, TensorProduct) and exp.is_Integer and exp > 0:\n+            result = TensorProduct(*[tensor_product_simp(arg)**exp for arg in base.args])\n+            return result\n+        else:\n+            return Pow(tensor_product_simp(base), exp)\n     elif isinstance(e, Mul):\n         return tensor_product_simp_Mul(e)\n     elif isinstance(e, Commutator):\n@@ -390,4 +396,4 @@ def tensor_product_simp(e, **hints):\n     elif isinstance(e, AntiCommutator):\n         return AntiCommutator(*[tensor_product_simp(arg) for arg in e.args])\n     else:\n-        return e\n+        return e\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-23534", "model_patch": "diff --git a/sympy/core/symbol.py b/sympy/core/symbol.py\nindex e6fdcf8..c8260c5 100644\n--- a/sympy/core/symbol.py\n+++ b/sympy/core/symbol.py\n@@ -791,7 +791,7 @@ def symbols(names, *, cls=Symbol, **args) -> Any:\n         return tuple(result)\n     else:\n         for name in names:\n-            result.append(symbols(name, **args))\n+            result.append(symbols(name, cls=cls, **args))\n \n         return type(names)(result)\n \n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-20428", "model_patch": "diff --git a/sympy/polys/densetools.py b/sympy/polys/densetools.py\nindex 40b9029..60541a5 100644\n--- a/sympy/polys/densetools.py\n+++ b/sympy/polys/densetools.py\n@@ -678,7 +678,7 @@ def dup_primitive(f, K):\n \n     \"\"\"\n     if not f:\n-        return K.zero, f\n+        return K.zero, dmp_strip(f, u)\n \n     cont = dup_content(f, K)\n \n@@ -714,7 +714,7 @@ def dmp_ground_primitive(f, u, K):\n         return dup_primitive(f, K)\n \n     if dmp_zero_p(f, u):\n-        return K.zero, f\n+        return K.zero, dmp_strip(f, u)\n \n     cont = dmp_ground_content(f, u, K)\n \ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex 4dcec1f..9cafc53 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -2248,7 +2248,8 @@ class Poly(Basic):\n         else:  # pragma: no cover\n             raise OperationNotSupported(f, 'clear_denoms')\n \n-        coeff, f = dom.to_sympy(coeff), f.per(result)\n+        from sympy.polys.densebasic import dmp_strip\n+        coeff, f = dom.to_sympy(coeff), f.per(dmp_strip(result, f.lev))\n \n         if not convert or not dom.has_assoc_Ring:\n             return coeff, f\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24066", "model_patch": "diff --git a/sympy/physics/units/unitsystem.py b/sympy/physics/units/unitsystem.py\nindex 4413d8e..10b5e1f 100644\n--- a/sympy/physics/units/unitsystem.py\n+++ b/sympy/physics/units/unitsystem.py\n@@ -190,10 +190,14 @@ class UnitSystem(_QuantityMapper):\n                 dim /= idim**count\n             return factor, dim\n         elif isinstance(expr, Function):\n-            fds = [self._collect_factor_and_dimension(\n-                arg) for arg in expr.args]\n-            return (expr.func(*(f[0] for f in fds)),\n-                    *(d[1] for d in fds))\n+            fds = [self._collect_factor_and_dimension(arg) for arg in expr.args]\n+            for _, d in fds:\n+                if not self.get_dimension_system().is_dimensionless(d):\n+                    raise ValueError(\n+                        f'Dimension of argument \"{expr.args}\" in function \"{expr.func}\" '\n+                        f'is {d}, but it must be Dimension(1).'\n+                    )\n+            return expr.func(*(f[0] for f in fds)), Dimension(1)\n         elif isinstance(expr, Dimension):\n             return S.One, expr\n         else:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-22080", "model_patch": "diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex 0831e79..8aa3be8 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -234,7 +234,11 @@ class AbstractPythonCodePrinter(CodePrinter):\n \n     def _print_Mod(self, expr):\n         PREC = precedence(expr)\n-        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n+        # Use parenthesizing to ensure the structure of the Mod operation is preserved\n+        return '{} % {}'.format(\n+            self.parenthesize(expr.args[0], PREC),\n+            self.parenthesize(expr.args[1], PREC)\n+        )\n \n     def _print_Piecewise(self, expr):\n         result = []\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-21847", "model_patch": "diff --git a/sympy/polys/monomials.py b/sympy/polys/monomials.py\nindex 9019221..aaf614a 100644\n--- a/sympy/polys/monomials.py\n+++ b/sympy/polys/monomials.py\n@@ -127,7 +127,7 @@ def itermonomials(variables, max_degrees, min_degrees=None):\n                 for variable in item:\n                     if variable != 1:\n                         powers[variable] += 1\n-                if max(powers.values()) >= min_degree:\n+                if sum(powers.values()) >= min_degree:\n                     monomials_list_comm.append(Mul(*item))\n             yield from set(monomials_list_comm)\n         else:\n@@ -139,7 +139,7 @@ def itermonomials(variables, max_degrees, min_degrees=None):\n                 for variable in item:\n                     if variable != 1:\n                         powers[variable] += 1\n-                if max(powers.values()) >= min_degree:\n+                if sum(powers.values()) >= min_degree:\n                     monomials_list_non_comm.append(Mul(*item))\n             yield from set(monomials_list_non_comm)\n     else:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-20801", "model_patch": "diff --git a/sympy/core/numbers.py b/sympy/core/numbers.py\nindex ecd2cce..6afbe94 100644\n--- a/sympy/core/numbers.py\n+++ b/sympy/core/numbers.py\n@@ -1387,6 +1387,8 @@ class Float(Number):\n         except SympifyError:\n             return NotImplemented\n         if not self:\n+            if isinstance(other, Boolean):\n+                return other is S.false\n             return not other\n         if isinstance(other, Boolean):\n             return False\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-22714", "model_patch": "diff --git a/sympy/geometry/point.py b/sympy/geometry/point.py\nindex b7f7a47..600488f 100644\n--- a/sympy/geometry/point.py\n+++ b/sympy/geometry/point.py\n@@ -152,7 +152,7 @@ class Point(GeometryEntity):\n                         'warn' or 'ignore'.'''))\n         if any(coords[dim:]):\n             raise ValueError('Nonzero coordinates cannot be removed.')\n-        if any(a.is_number and im(a) for a in coords):\n+        if evaluate and any(a.is_number and im(a) for a in coords):\n             raise ValueError('Imaginary coordinates are not permitted.')\n         if not all(isinstance(a, Expr) for a in coords):\n             raise TypeError('Coordinates must be valid SymPy expressions.')\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-19954", "model_patch": "diff --git a/sympy/combinatorics/perm_groups.py b/sympy/combinatorics/perm_groups.py\nindex eb05c35..52782f3 100644\n--- a/sympy/combinatorics/perm_groups.py\n+++ b/sympy/combinatorics/perm_groups.py\n@@ -2198,7 +2198,7 @@ class PermutationGroup(Basic):\n                 for i, r in enumerate(rep_blocks):\n                     if len(r) > len(rep) and rep.issubset(r):\n                         # i-th block system is not minimal\n-                        del num_blocks[i], blocks[i]\n+                        to_remove.append(i)\n                         to_remove.append(rep_blocks[i])\n                     elif len(r) < len(rep) and r.issubset(rep):\n                         # the system being checked is not minimal\n@@ -2206,6 +2206,10 @@ class PermutationGroup(Basic):\n                         break\n                 # remove non-minimal representative blocks\n                 rep_blocks = [r for r in rep_blocks if r not in to_remove]\n+                # Remove non-minimal block systems by index\n+                for index in sorted(to_remove, reverse=True):\n+                    del num_blocks[index]\n+                    del blocks[index]\n \n                 if minimal and num_block not in num_blocks:\n                     blocks.append(block)\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-20590", "model_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex 87da872..bd8f18f 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -69,10 +69,7 @@ class Basic(Printable, metaclass=ManagedProperties):\n         >>> isinstance(B, Basic)\n         True\n     \"\"\"\n-    __slots__ = ('_mhash',              # hash value\n-                 '_args',               # arguments\n-                 '_assumptions'\n-                )\n+    __slots__ = ('_mhash', '_args', '_assumptions', '__dict__')\n \n     # To be overridden with True in the appropriate subclasses\n     is_number = False\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-22456", "model_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex 0430e95..871f54d 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -128,7 +128,7 @@ class Basic(Printable, metaclass=ManagedProperties):\n         return self.func(*self.args)\n \n     def __getnewargs__(self):\n-        return self.args\n+        return tuple(self.args)\n \n     def __getstate__(self):\n         return None\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-19495", "model_patch": "diff --git a/sympy/sets/conditionset.py b/sympy/sets/conditionset.py\nindex 934bff8..d9e72e7 100644\n--- a/sympy/sets/conditionset.py\n+++ b/sympy/sets/conditionset.py\n@@ -240,6 +240,9 @@ class ConditionSet(Set):\n             # the base set should be filtered and if new is not in\n             # the base set then this substitution is ignored\n             return self.func(sym, cond, base)\n+        # Avoid substituting into the bound variable of the ConditionSet\n+        if old == self.sym:\n+            return self\n         cond = self.condition.subs(old, new)\n         base = self.base_set.subs(old, new)\n         if cond is S.true:\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-21596", "model_patch": "diff --git a/sympy/sets/handlers/intersection.py b/sympy/sets/handlers/intersection.py\nindex 99c7e51..7c7e4e3 100644\n--- a/sympy/sets/handlers/intersection.py\n+++ b/sympy/sets/handlers/intersection.py\n@@ -1,19 +1,30 @@\n+\n from sympy import (S, Dummy, Lambda, symbols, Interval, Intersection, Set,\n                    EmptySet, FiniteSet, Union, ComplexRegion, Mul)\n from sympy.multipledispatch import dispatch\n from sympy.sets.conditionset import ConditionSet\n from sympy.sets.fancysets import (Integers, Naturals, Reals, Range,\n     ImageSet, Rationals)\n-from sympy.sets.sets import UniversalSet, imageset, ProductSet\n+from sympy.sets.sets import UniversalSet, imageset, ProductSet, FiniteSet\n \n \n @dispatch(ConditionSet, ConditionSet)  # type: ignore # noqa:F811\n def intersection_sets(a, b): # noqa:F811\n     return None\n \n-@dispatch(ConditionSet, Set)  # type: ignore # noqa:F811\n-def intersection_sets(a, b): # noqa:F811\n-    return ConditionSet(a.sym, a.condition, Intersection(a.base_set, b))\n+@dispatch(ImageSet, Reals)  # type: ignore # noqa:F811\n+def intersection_sets(a, b):  # noqa:F811\n+    # Intersect the ImageSet with Reals\n+    if not isinstance(a, ImageSet):\n+        return S.EmptySet\n+\n+    # Extract the lambda function and base set\n+    lamda, base_set = a.lamda, a.base_set\n+\n+    # Determine real values in the ImageSet\n+    real_values = FiniteSet(*[val for val in a if val.is_real])\n+\n+    return real_values if real_values else S.EmptySet\n \n @dispatch(Naturals, Integers)  # type: ignore # noqa:F811\n def intersection_sets(a, b): # noqa:F811\n", "regression_test_result": 0, "reproduction_test_result": true}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24562", "model_patch": "diff --git a/sympy/core/numbers.py b/sympy/core/numbers.py\nindex 1c28b44..b7f2445 100644\n--- a/sympy/core/numbers.py\n+++ b/sympy/core/numbers.py\n@@ -1611,13 +1611,16 @@ class Rational(Number):\n                         p, q = pq\n                         fp = fractions.Fraction(p)\n                         fq = fractions.Fraction(q)\n-                        p = fp/fq\n+                        p = fp / fq\n+                    elif q is not None:  # Handle case when q is given explicitly\n+                        p = fractions.Fraction(p)\n                     try:\n                         p = fractions.Fraction(p)\n                     except ValueError:\n                         pass  # error will raise below\n                     else:\n-                        return Rational(p.numerator, p.denominator, 1)\n+                        if q is None:  # Use default behavior when q is not provided\n+                            return Rational(p.numerator, p.denominator, 1)\n \n                 if not isinstance(p, Rational):\n                     raise TypeError('invalid input: %s' % p)\n", "regression_test_result": 0, "reproduction_test_result": true}
